#include <stdio.h>
#define NULL 0
#define EXPORT	_declspec( dllexport )
#define	MAX_ENT_LEAFS	24
#define MAX_LEVEL_CONNECTIONS	16
#define CDMG_TIMEBASED		8
#define MAX_WEAPONS		32
#define MAX_AMMO_SLOTS  32
#define MAX_ITEM_TYPES			6
#define MAX_ITEMS				5
#define CSUITPLAYLIST	4
#define CSUITNOREPEAT		32
#define CBTEXTURENAMEMAX	13
#define TEAM_NAME_LENGTH	16
#define MS_MAX_TARGETS 32
#define MAX_TEAMNAME_LENGTH	16
#define MAX_TEAMS			32
#define TEAMPLAY_TEAMLISTLENGTH		MAX_TEAMS*MAX_TEAMNAME_LENGTH
#define	MAX_WORLD_SOUNDS	64
#define MAX_EQUIP		32
#define CBSENTENCENAME_MAX 16
#define CSENTENCE_LRU_MAX	32
#define cchMapNameMost 32
#define MAX_MULTI_TARGETS	16
#define MAX_WEAPON_NAME 128
#define MAX_WEAPON_SLOTS		5
#define MAX_WEAPON_POSITIONS		MAX_WEAPON_SLOTS
#define	MAX_AMMO_TYPES	32
#define MAX_HISTORY 12
#define NUM_DMG_TYPES		12
#define MAX_SPRITE_NAME_LENGTH	24
typedef unsigned char byte;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef int BOOL;
typedef int qboolean;
typedef int AMMO;
typedef int HSPRITE;
typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];
typedef int	string_t;
typedef int EOFFSET;
typedef enum { USE_OFF = 0, USE_ON = 1, USE_SET = 2, USE_TOGGLE = 3 } USE_TYPE;
typedef enum { expRandom, expDirected} Explosions;
typedef enum { matGlass = 0, matWood, matMetal, matFlesh, matCinderBlock, matCeilingTile, matComputer, matUnbreakableGlass, matRocks, matNone, matLastMaterial } Materials;
typedef enum { GLOBAL_OFF = 0, GLOBAL_ON = 1, GLOBAL_DEAD = 2 } GLOBALESTATE;
typedef enum { TRAIN_SAFE, TRAIN_BLOCKING, TRAIN_FOLLOWING } TRAIN_CODE;
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);
typedef unsigned long CRC32_t;
typedef struct edict_s edict_t;
typedef struct globalentity_s globalentity_t;
typedef void *cache_user_t;
class CBaseEntity;
class CBaseMonster;
class CSquadMonster; // Undefined in SDK 1.0
class CBasePlayerAmmo;
class CBasePlayerItem;
class CBasePlayerWeapon;
class CBasePlayer;
class CRpg;
// TODO: Binary ninja does not seem to recognize member function pointer definitions.
/*
typedef void (CBaseEntity::*BASEPTR)(void);
typedef void (CBaseEntity::*ENTITYFUNCPTR)(CBaseEntity *pOther );
typedef void (CBaseEntity::*USEPTR)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
*/
typedef void (*BASEPTR)(void);
typedef void (*ENTITYFUNCPTR)(CBaseEntity *pOther );
typedef void (*USEPTR)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;
typedef struct
{
	byte r, g, b;
} color24;
class Vector2D __packed
{
public:
	inline Vector2D(void)									;
	inline Vector2D(float X, float Y)						;
	inline Vector2D operator+(const Vector2D& v)	const	;
	inline Vector2D operator-(const Vector2D& v)	const	;
	inline Vector2D operator*(float fl)				const	;
	inline Vector2D operator/(float fl)				const	;
	inline float Length(void)						const	;
	inline Vector2D Normalize ( void ) const;
	vec_t	x, y;
};
class Vector __packed
{
public:
	inline Vector(void)								;
	inline Vector(float X, float Y, float Z)		;
	inline Vector(const Vector& v)					;
	inline Vector(float rgfl[3])					;
	inline Vector operator-(void) const;
	inline int operator==(const Vector& v) const;
	inline int operator!=(const Vector& v) const;
	inline Vector operator+(const Vector& v) const;
	inline Vector operator-(const Vector& v) const;
	inline Vector operator*(float fl) const;
	inline Vector operator/(float fl) const;
	inline void CopyToArray(float* rgfl) const;
	inline float Length(void) const;
	operator float *();
	operator const float *() const;
	inline Vector Normalize(void) const;
	inline Vector2D Make2D ( void ) const;
	inline float Length2D(void) const;
	vec_t x, y, z;
};
class CPlane __packed
{
public:
	CPlane ( void );
	void InitializePlane ( const Vector &vecNormal, const Vector &vecPoint );
	BOOL PointInFront ( const Vector &vecPoint );
	Vector	m_vecNormal;
	float	m_flDist;
	BOOL	m_fInitialized;
};
typedef struct
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;
typedef struct rect_s
{
	int				left, right, top, bottom;
} wrect_t;
struct WEAPON
{
	char	szName[MAX_WEAPON_NAME];
	int		iAmmoType;
	int		iAmmo2Type;
	int		iMax1;
	int		iMax2;
	int		iSlot;
	int		iSlotPos;
	int		iFlags;
	int		iId;
	int		iClip;
	int		iCount;
	HSPRITE hActive;
	wrect_t rcActive;
	HSPRITE hInactive;
	wrect_t rcInactive;
	HSPRITE	hAmmo;
	wrect_t rcAmmo;
	HSPRITE hAmmo2;
	wrect_t rcAmmo2;
	HSPRITE hCrosshair;
	wrect_t rcCrosshair;
	HSPRITE hAutoaim;
	wrect_t rcAutoaim;
	HSPRITE hZoomedCrosshair;
	wrect_t rcZoomedCrosshair;
	HSPRITE hZoomedAutoaim;
	wrect_t rcZoomedAutoaim;
};
class WeaponsResource __packed
{
private:
	WEAPON		rgWeapons[MAX_WEAPONS];
	WEAPON*		rgSlots[MAX_WEAPON_SLOTS+1][MAX_WEAPON_POSITIONS+1];
	int			riAmmo[MAX_AMMO_TYPES];
public:
	void Init( void );
	void Reset( void );
	int			iOldWeaponBits;
	WEAPON *GetWeapon( int iId );
	void AddWeapon( WEAPON *wp );
	void PickupWeapon( WEAPON *wp );
	void DropWeapon( WEAPON *wp );
	void DropAllWeapons( void );
	WEAPON* GetWeaponSlot( int slot, int pos ) ;
	void LoadWeaponSprites( WEAPON* wp );
	void LoadAllWeaponSprites( void );
	WEAPON* GetFirstPos( int iSlot );
	void SelectSlot( int iSlot, int fAdvance, int iDirection );
	WEAPON* GetNextActivePos( int iSlot, int iSlotPos );
	int HasAmmo( WEAPON *p );
	AMMO GetAmmo( int iId ) ;
	void SetAmmo( int iId, int iCount ) ;
	int CountAmmo( int iId );
	HSPRITE* GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect );
};
class HistoryResource __packed
{
private:
	struct HIST_ITEM {
		int type;
		float DisplayTime;
		int iCount;
		int iId;
	};
	HIST_ITEM rgAmmoHistory[MAX_HISTORY];
public:
	void Init( void );
	void Reset( void );
	int iHistoryGap;
	int iCurrentHistorySlot;
	void AddToHistory( int iType, int iId, int iCount = 0 );
	void AddToHistory( int iType, const char *szName, int iCount = 0 );
	void CheckClearHistory( void );
	int DrawAmmoHistory( float flTime );
};
typedef struct {
	int x, y;
} POSITION;
typedef struct {
	unsigned char r,g,b,a;
} RGBA;
struct __data_var_refs vtable_for_CHudBase
{
	int (*Init)( class CHudBase* p ) ;
	int (*VidInit)( class CHudBase* p ) ;
	int (*Draw)(class CHudBase* p, float flTime) ;
	void (*Think)(class CHudBase* p) ;
	void (*Reset)(class CHudBase* p) ;
	void (*InitHUDData)( class CHudBase* p ) ;
};
class CHudBase __packed
{
  struct vtable_for_CHudBase* vtable;
public:
	POSITION  m_pos;
	int   m_type;
	int	  m_iFlags;
};
struct HUDLIST {
	CHudBase	*p;
	HUDLIST		*pNext;
};
typedef struct
{
	float fExpire;
	float fBaseline;
	int	x, y;
} DAMAGE_IMAGE;
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudHealth
{
 	int (*Init)( class CHudHealth* p );
	int (*VidInit)( class CHudHealth* p );
	int (*Draw)(class CHudHealth* p, float fTime);
	void (*Reset)( class CHudHealth* p );
};
class __base(CHudBase, 0) CHudHealth __packed
{
  struct vtable_for_CHudHealth* vtable;
public:
	int MsgFunc_Health(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf);
	int m_iHealth;
	int m_HUD_dmg_bio;
	int m_HUD_cross;
private:
	HSPRITE m_hSprite;
	HSPRITE m_hDamage;
	DAMAGE_IMAGE m_dmg[NUM_DMG_TYPES];
	int	m_bitsDamage;
	float m_fFade;
	void GetPainColor( int &r, int &g, int &b );
	int DrawPain(float fTime);
	int DrawDamage(float fTime);
	float m_fAttackFront, m_fAttackRear, m_fAttackLeft, m_fAttackRight;
	void CalcDamageDirection(vec3_t vecFrom);
	void UpdateTiles(float fTime, long bits);
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudAmmo
{
};
class __base(CHudBase, 0) CHudAmmo __packed
{
  struct vtable_for_CHudAmmo* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Think(void);
	void Reset(void);
	int DrawWList(float flTime);
	int MsgFunc_CurWeapon(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_WeaponList(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_AmmoX(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_AmmoPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_WeapPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_ItemPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_HideWeapon( const char *pszName, int iSize, void *pbuf );
	void _cdecl UserCmd_Slot1( void );
	void _cdecl UserCmd_Slot2( void );
	void _cdecl UserCmd_Slot3( void );
	void _cdecl UserCmd_Slot4( void );
	void _cdecl UserCmd_Slot5( void );
	void _cdecl UserCmd_Slot6( void );
	void _cdecl UserCmd_Slot7( void );
	void _cdecl UserCmd_Slot8( void );
	void _cdecl UserCmd_Slot9( void );
	void _cdecl UserCmd_Slot10( void );
	void _cdecl UserCmd_Close( void );
	void _cdecl UserCmd_NextWeapon( void );
	void _cdecl UserCmd_PrevWeapon( void );
private:
	float m_fFade;
	RGBA  m_rgba;
	WEAPON *m_pWeapon;
	int	m_HUD_bucket0;
	int m_HUD_selection;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudAmmoSecondary
{
};
class __base(CHudBase, 0) CHudAmmoSecondary __packed
{
  struct vtable_for_CHudAmmoSecondary* vtable;
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	int MsgFunc_SecAmmoVal( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_SecAmmoIcon( const char *pszName, int iSize, void *pbuf );
private:
	enum {
		MAX_SEC_AMMO_VALUES = 4
	};
	int m_HUD_ammoicon;
	int m_iAmmoAmounts[MAX_SEC_AMMO_VALUES];
	float m_fFade;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudGeiger
{
};
class __base(CHudBase, 0) CHudGeiger __packed
{
  struct vtable_for_CHudGeiger* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Geiger(const char *pszName, int iSize, void *pbuf);
private:
	int m_iGeigerRange;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudTrain
{
};
class __base(CHudBase, 0) CHudTrain __packed
{
  struct vtable_for_CHudTrain* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Train(const char *pszName, int iSize, void *pbuf);
private:
	HSPRITE m_hSprite;
	int m_iPos;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMOTD
{
};
class __base(CHudBase, 0) CHudMOTD __packed
{
  struct vtable_for_CHudMOTD* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	int MsgFunc_MOTD( const char *pszName, int iSize, void *pbuf );
protected:
	enum { MAX_MOTD_LENGTH = 241, };
	static int MOTD_DISPLAY_TIME;
	char m_szMOTD[ MAX_MOTD_LENGTH ];
	float m_flActiveTill;
	int m_iLines;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudStatusBar
{
};
class __base(CHudBase, 0) CHudStatusBar __packed
{
  struct vtable_for_CHudStatusBar* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	void ParseStatusString( int line_num );
	int MsgFunc_StatusText( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_StatusValue( const char *pszName, int iSize, void *pbuf );
protected:
	enum {
		MAX_STATUSTEXT_LENGTH = 128,
		MAX_STATUSBAR_VALUES = 8,
		MAX_STATUSBAR_LINES = 2,
	};
	char m_szStatusText[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];
	char m_szStatusBar[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];
	int m_iStatusValues[MAX_STATUSBAR_VALUES];
	int m_bReparseString;
};
typedef struct
{
	char *name;
	short ping;
	byte thisplayer;
	byte spectator;
	byte packetloss;
	char *model;
	short topcolor;
	short bottomcolor;
} hud_player_info_t;
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudScoreboard
{
};
class __base(CHudBase, 0) CHudScoreboard __packed
{
  struct vtable_for_CHudScoreboard* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int DrawPlayers( int xoffset, float listslot, int nameoffset = 0, char *team = NULL );
	void UserCmd_ShowScores( void );
	void UserCmd_HideScores( void );
	int MsgFunc_ScoreInfo( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_TeamInfo( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_TeamScore( const char *pszName, int iSize, void *pbuf );
	void DeathMsg( int killer, int victim );
	enum {
		MAX_PLAYERS = 64,
		MAX_TEAMS_CL = 64,
		MAX_TEAM_NAME = 16,
	};
	struct extra_player_info_t {
		short frags;
		short deaths;
		char teamname[MAX_TEAM_NAME];
	};
	struct team_info_t {
		char name[MAX_TEAM_NAME];
		short frags;
		short deaths;
		short ping;
		short packetloss;
		short ownteam;
		short players;
		int already_drawn;
		int scores_overriden;
	};
	hud_player_info_t m_PlayerInfoList[MAX_PLAYERS+1];
	extra_player_info_t m_PlayerExtraInfo[MAX_PLAYERS+1];
	team_info_t m_TeamInfo[MAX_TEAMS_CL+1];
	int m_iNumTeams;
	int m_iLastKilledBy;
	int m_fLastKillTime;
	int m_iPlayerNum;
	int m_iShowscoresHeld;
	void GetAllPlayersInfo( void );
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudDeathNotice
{
};
class __base(CHudBase, 0) CHudDeathNotice __packed
{
  struct vtable_for_CHudDeathNotice* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int MsgFunc_DeathMsg( const char *pszName, int iSize, void *pbuf );
private:
	int m_HUD_d_skull;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMenu
{
};
class __base(CHudBase, 0) CHudMenu __packed
{
  struct vtable_for_CHudMenu* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	void Reset( void );
	int Draw( float flTime );
	int MsgFunc_ShowMenu( const char *pszName, int iSize, void *pbuf );
	void SelectMenuItem( int menu_item );
	int m_fMenuDisplayed;
	int m_bitsValidSlots;
	float m_flShutoffTime;
	int m_fWaitingForMore;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudSayText
{
};
class __base(CHudBase, 0) CHudSayText __packed
{
  struct vtable_for_CHudSayText* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int MsgFunc_SayText( const char *pszName, int iSize, void *pbuf );
	void SayTextPrint( const char *pszBuf, int iBufSize );
	void EnsureTextFitsInOneLineAndWrapIfHaveTo( int line );
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudBattery
{
};
class __base(CHudBase, 0) CHudBattery __packed
{
  struct vtable_for_CHudBattery* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Battery(const char *pszName,  int iSize, void *pbuf );
private:
	HSPRITE m_hSprite1;
	HSPRITE m_hSprite2;
	wrect_t *m_prc1;
	wrect_t *m_prc2;
	int	  m_iBat;
	float m_fFade;
	int	  m_iHeight;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudFlashlight
{
};
class __base(CHudBase, 0) CHudFlashlight __packed
{
  struct vtable_for_CHudFlashlight* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Reset( void );
	int MsgFunc_Flashlight(const char *pszName,  int iSize, void *pbuf );
	int MsgFunc_FlashBat(const char *pszName,  int iSize, void *pbuf );
private:
	HSPRITE m_hSprite1;
	HSPRITE m_hSprite2;
	HSPRITE m_hBeam;
	wrect_t *m_prc1;
	wrect_t *m_prc2;
	wrect_t *m_prcBeam;
	float m_flBat;
	int	  m_iBat;
	int	  m_fOn;
	float m_fFade;
	int	  m_iWidth;
};
typedef struct
{
	int		effect;
	byte	r1, g1, b1, a1;
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;
const int maxHUDMessages = 16;
struct message_parms_t
{
	client_textmessage_t	*pMessage;
	float	time;
	int x, y;
	int	totalWidth, totalHeight;
	int width;
	int lines;
	int lineLength;
	int length;
	int r, g, b;
	int text;
	int fadeBlend;
	float charTime;
	float fadeTime;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudTextMessage
{
};
class __base(CHudBase, 0) CHudTextMessage __packed
{
  struct vtable_for_CHudTextMessage* vtable;
public:
	int Init( void );
	char *LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size );
	char *BufferedLocaliseTextString( const char *msg );
	char *LookupString( const char *msg_name, int *msg_dest = NULL );
	int MsgFunc_TextMsg(const char *pszName, int iSize, void *pbuf);
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMessage
{
};
class __base(CHudBase, 0) CHudMessage __packed
{
  struct vtable_for_CHudMessage* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_HudText(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_GameTitle(const char *pszName, int iSize, void *pbuf);
	float FadeBlend( float fadein, float fadeout, float hold, float localTime );
	int	XPosition( float x, int width, int lineWidth );
	int YPosition( float y, int height );
	void MessageAdd( const char *pName, float time );
	void MessageDrawScan( client_textmessage_t *pMessage, float time );
	void MessageScanStart( void );
	void MessageScanNextChar( void );
	void Reset( void );
private:
	client_textmessage_t		*m_pMessages[maxHUDMessages];
	float						m_startTime[maxHUDMessages];
	message_parms_t				m_parms;
	float						m_gameTitleTime;
	client_textmessage_t		*m_pGameTitle;
	int m_HUD_title_life;
	int m_HUD_title_half;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudStatusIcons
{
};
class __base(CHudBase, 0) CHudStatusIcons __packed
{
  struct vtable_for_CHudStatusIcons* vtable;
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	int MsgFunc_StatusIcon(const char *pszName, int iSize, void *pbuf);
	enum {
		MAX_ICONSPRITENAME_LENGTH = MAX_SPRITE_NAME_LENGTH,
		MAX_ICONSPRITES = 4,
	};
	void EnableIcon( char *pszIconName, unsigned char red, unsigned char green, unsigned char blue );
	void DisableIcon( char *pszIconName );
private:
	typedef struct
	{
		char szSpriteName[MAX_ICONSPRITENAME_LENGTH];
		HSPRITE spr;
		wrect_t rc;
		unsigned char r, g, b;
	} icon_sprite_t;
	icon_sprite_t m_IconList[MAX_ICONSPRITES];
};
typedef struct client_data_s
{
	vec3_t origin;
	float viewheight;
	float maxspeed;
	vec3_t viewangles;
	vec3_t punchangle;
	int		iKeyBits;
	int		iWeaponBits;
	float	fov;
	float	view_idlescale;
	float   mouse_sensitivity;
} client_data_t;
typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;
class CHud __packed
{
private:
	HUDLIST						*m_pHudList;
	HSPRITE						m_hsprLogo;
	int							m_iLogo;
	client_sprite_t				*m_pSpriteList;
	int							m_iSpriteCount;
	int							m_iSpriteCountAllRes;
	float						m_flMouseSensitivity;
	int							m_iConcussionEffect;
public:
	float m_flTime;
	float m_fOldTime;
	double m_flTimeDelta;
	Vector	m_vecOrigin;
	Vector	m_vecAngles;
	int		m_iKeyBits;
	int		m_iHideHUDDisplay;
	int		m_iFOV;
	int		m_Teamplay;
	int		m_iRes;
	int m_iFontHeight;
	int DrawHudNumber(int x, int y, int iFlags, int iNumber, int r, int g, int b );
	int DrawHudString(int x, int y, int iMaxX, char *szString, int r, int g, int b );
	int DrawHudStringReverse( int xpos, int ypos, int iMinX, char *szString, int r, int g, int b );
	int DrawHudNumberString( int xpos, int ypos, int iMinX, int iNumber, int r, int g, int b );
	int GetNumWidth(int iNumber, int iFlags);
private:
	HSPRITE *m_rghSprites;
	wrect_t *m_rgrcRects;
	char *m_rgszSpriteNames;
public:
	HSPRITE GetSprite( int index );
	wrect_t& GetSpriteRect( int index );
	int GetSpriteIndex( const char *SpriteName );
	CHudAmmo	m_Ammo;
	CHudHealth	m_Health;
	CHudGeiger	m_Geiger;
	CHudBattery	m_Battery;
	CHudTrain	m_Train;
	CHudFlashlight m_Flash;
	CHudMessage m_Message;
	CHudScoreboard m_Scoreboard;
	CHudMOTD    m_MOTD;
	CHudStatusBar    m_StatusBar;
	CHudDeathNotice m_DeathNotice;
	CHudSayText m_SayText;
	CHudMenu	m_Menu;
	CHudAmmoSecondary	m_AmmoSecondary;
	CHudTextMessage m_TextMessage;
	CHudStatusIcons m_StatusIcons;
	void Init( void );
	void VidInit( void );
	void Think(void);
	int Redraw( float flTime, int intermission );
	int UpdateClientData( client_data_t *cdata, float time );
	CHud();
	~CHud();
	int _cdecl MsgFunc_Damage(const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_GameMode(const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_Logo(const char *pszName,  int iSize, void *pbuf);
	int _cdecl MsgFunc_ResetHUD(const char *pszName,  int iSize, void *pbuf);
	void _cdecl MsgFunc_InitHUD( const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_SetFOV(const char *pszName,  int iSize, void *pbuf);
	int  _cdecl MsgFunc_Concuss( const char *pszName, int iSize, void *pbuf );
	SCREENINFO	m_scrinfo;
	int	m_iWeaponBits;
	int	m_fPlayerDead;
	int m_iIntermission;
	int m_HUD_number_0;
	void AddHudElem(CHudBase *p);
};
typedef struct
{
	int					id;
	int					version;
	char				name[64];
	int					length;
	vec3_t				eyeposition;
	vec3_t				min;
	vec3_t				max;
	vec3_t				bbmin;
	vec3_t				bbmax;
	int					flags;
	int					numbones;
	int					boneindex;
	int					numbonecontrollers;
	int					bonecontrollerindex;
	int					numhitboxes;
	int					hitboxindex;
	int					numseq;
	int					seqindex;
	int					numseqgroups;
	int					seqgroupindex;
	int					numtextures;
	int					textureindex;
	int					texturedataindex;
	int					numskinref;
	int					numskinfamilies;
	int					skinindex;
	int					numbodyparts;
	int					bodypartindex;
	int					numattachments;
	int					attachmentindex;
	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;
	int					numtransitions;
	int					transitionindex;
} studiohdr_t;
typedef struct
{
	int					id;
	int					version;
	char				name[64];
	int					length;
} studioseqhdr_t;
typedef struct
{
	char				name[32];
	int		 			parent;
	int					flags;
	int					bonecontroller[6];
	float				value[6];
	float				scale[6];
} mstudiobone_t;
typedef struct
{
	int					bone;
	int					type;
	float				start;
	float				end;
	int					rest;
	int					index;
} mstudiobonecontroller_t;
typedef struct
{
	int					bone;
	int					group;
	vec3_t				bbmin;
	vec3_t				bbmax;
} mstudiobbox_t;
typedef struct
{
	char				label[32];
	char				name[64];
	cache_user_t		cache;
	int					data;
} mstudioseqgroup_t;
typedef struct
{
	char				label[32];
	float				fps;
	int					flags;
	int					activity;
	int					actweight;
	int					numevents;
	int					eventindex;
	int					numframes;
	int					numpivots;
	int					pivotindex;
	int					motiontype;
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;
	vec3_t				bbmin;
	vec3_t				bbmax;
	int					numblends;
	int					animindex;
	int					blendtype[2];
	float				blendstart[2];
	float				blendend[2];
	int					blendparent;
	int					seqgroup;
	int					entrynode;
	int					exitnode;
	int					nodeflags;
	int					nextseq;
} mstudioseqdesc_t;
typedef struct
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
typedef struct
{
	vec3_t				org;
	int					start;
	int					end;
} mstudiopivot_t;
typedef struct
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;
	vec3_t				vectors[3];
} mstudioattachment_t;
typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;
typedef union
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex;
} mstudiobodyparts_t;
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;
typedef struct
{
	char				name[64];
	int					type;
	float				boundingradius;
	int					nummesh;
	int					meshindex;
	int					numverts;
	int					vertinfoindex;
	int					vertindex;
	int					numnorms;
	int					norminfoindex;
	int					normindex;
	int					numgroups;
	int					groupindex;
} mstudiomodel_t;
typedef struct
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;
	int					normindex;
} mstudiomesh_t;
typedef struct
{
	short				vertindex;
	short				normindex;
	short				s,t;
} mstudiotrivert_t;
typedef struct cl_enginefuncs_s
{
	HSPRITE (*pfnSPR_Load)			( const char *szPicName );
	int		(*pfnSPR_Frames)		( HSPRITE hPic );
	int		(*pfnSPR_Height)		( HSPRITE hPic, int frame );
	int		(*pfnSPR_Width)			( HSPRITE hPic, int frame );
	void	(*pfnSPR_Set)			( HSPRITE hPic, int r, int g, int b );
	void	(*pfnSPR_Draw)			( int frame, int x, int y, const wrect_t *prc);
	void	(*pfnSPR_DrawHoles)		( int frame, int x, int y, const wrect_t *prc );
	void	(*pfnSPR_DrawAdditive)	( int frame, int x, int y, const wrect_t *prc );
	void	(*pfnSPR_EnableScissor)	( int x, int y, int width, int height );
	void	(*pfnSPR_DisableScissor)( void );
	client_sprite_t *(*pfnSPR_GetList)		( char *psz, int *piCount);
	void	(*pfnFillRGBA)			( int x, int y, int width, int height, int r, int g, int b, int a);
	int		(*pfnGetScreenInfo)		( SCREENINFO *pscrinfo);
	void	(*pfnSetCrosshair)		( HSPRITE hspr, wrect_t rc, int r, int g, int b);
	int		(*pfnRegisterVariable)  ( char *szName, char *szValue, int flags );
	float	(*pfnGetCvarFloat)		( char *szName );
	char*	(*pfnGetCvarString)		( char *szName );
	int		(*pfnAddCommand)		( char *cmd_name, void (*function)(void) );
	int		(*pfnHookUserMsg)		( char *szMsgName, pfnUserMsgHook pfn );
	int		(*pfnServerCmd)			( char *szCmdString );
	int		(*pfnClientCmd)			( char *szCmdString );
	void	(*pfnGetPlayerInfo)		( int ent_num, hud_player_info_t *pinfo );
	void	(*pfnPlaySoundByName)	( char *szSound, float volume );
	void	(*pfnPlaySoundByIndex)	( int iSound, float volume );
	void  (*pfnAngleVectors)		(const float * vecAngles, float * forward, float * right, float * up);
	client_textmessage_t	*(*pfnTextMessageGet)	( const char *pName );
	int	  (*pfnDrawCharacter)		( int x, int y, int number, int r, int g, int b );
	int   (*pfnDrawConsoleString)	( int x, int y, char *string );
	void  (*pfnDrawConsoleStringLen) (  const char *string, int *length, int *height );
	void  (*pfnConsolePrint) ( const char *string );
	void  (*pfnCenterPrint) ( const char *string );
} cl_enginefunc_t;
typedef struct
{
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;
	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;
typedef struct
{
	string_t	classname;
	string_t	globalname;
	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;
	vec3_t		movedir;
	vec3_t		angles;
	vec3_t		avelocity;
	vec3_t		punchangle;
	vec3_t		v_angle;
	int			fixangle;
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;
	int			modelindex;
	string_t	model;
	int			viewmodel;
	int			weaponmodel;
	vec3_t		absmin;
	vec3_t		absmax;
	vec3_t		mins;
	vec3_t		maxs;
	vec3_t		size;
	float		ltime;
	float		nextthink;
	int			movetype;
	int			solid;
	int			skin;
	int			body;
	int 		effects;
	float		gravity;
	float		friction;
	int			light_level;
	int			sequence;
	int			gaitsequence;
	float		frame;
	float		animtime;
	float		framerate;
	byte		controller[4];
	byte		blending[2];
	float		scale;
	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;
	float		health;
	float		frags;
	int			weapons;
	float		takedamage;
	int			deadflag;
	vec3_t		view_ofs;
	int			button;
	int			impulse;
	edict_t		*chain;
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;
	edict_t		*owner;
	edict_t		*groundentity;
	int			spawnflags;
	int			flags;
	int			colormap;
	int			team;
	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;
	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	edict_t		*pContainingEntity;
} entvars_t;
typedef struct
{
	int     entityType;
	int     number;
	int     flags;
	vec3_t	origin;
	vec3_t	angles;
	int		modelindex;
	int		sequence;
	float	frame;
	int		colormap;
	short	skin;
	short	solid;
	int		effects;
	float	scale;
	int		rendermode;
	int		renderamt;
	color24	rendercolor;
	int		renderfx;
	int     movetype;
	float   animtime;
	float   framerate;
	int     body;
	byte    controller[4];
	byte    blending[4];
	vec3_t	velocity;
	vec3_t  mins;
	vec3_t  maxs;
	int		aiment;
} entity_state_t;
typedef struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];
	entity_state_t	baseline;
	float		freetime;
	void*		pvPrivateData;
	entvars_t	v;
} edict_t;
typedef struct
{
	unsigned short	amplitude;
	unsigned short 	duration;
	unsigned short	frequency;
} ScreenShake;
typedef struct
{
	unsigned short 	duration;
	unsigned short 	holdTime;
	short			fadeFlags;
	byte			r, g, b, a;
} ScreenFade;
typedef struct KeyValueData_s
{
	char	*szClassName;
	char	*szKeyName;
	char	*szValue;
	long	fHandled;
} KeyValueData;
typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
typedef struct
{
	int			id;
	edict_t	*pent;
	int			location;
	int			size;
	int			flags;
	string_t	classname;
} ENTITYTABLE;
typedef struct saverestore_s
{
	char		*pBaseData;
	char		*pCurrentData;
	int			size;
	int			bufferSize;
	int			tokenSize;
	int			tokenCount;
	char		**pTokens;
	int			currentIndex;
	int			tableCount;
	int			connectionCount;
	ENTITYTABLE	*pTable;
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];
	int			fUseLandmark;
	char		szLandmarkName[20];
	vec3_t		vecLandmarkOffset;
	float		time;
	char		szCurrentMapName[32];
} SAVERESTOREDATA;
typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,
	FIELD_STRING,
	FIELD_ENTITY,
	FIELD_CLASSPTR,
	FIELD_EHANDLE,
	FIELD_EVARS,
	FIELD_EDICT,
	FIELD_VECTOR,
	FIELD_POSITION_VECTOR,
	FIELD_POINTER,
	FIELD_INTEGER,
	FIELD_FUNCTION,
	FIELD_BOOLEAN,
	FIELD_SHORT,
	FIELD_CHARACTER,
	FIELD_TIME,
	FIELD_MODELNAME,
	FIELD_SOUNDNAME,
	FIELD_TYPECOUNT,
} FIELDTYPE;
typedef struct
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;
class CSaveRestoreBuffer __packed
{
public:
	CSaveRestoreBuffer( void );
	CSaveRestoreBuffer( SAVERESTOREDATA *pdata );
	~CSaveRestoreBuffer( void );
	int			EntityIndex( entvars_t *pevLookup );
	int			EntityIndex( edict_t *pentLookup );
	int			EntityIndex( EOFFSET eoLookup );
	int			EntityIndex( CBaseEntity *pEntity );
	int			EntityFlags( int entityIndex, int flags ) ;
	int			EntityFlagsSet( int entityIndex, int flags );
	edict_t		*EntityFromIndex( int entityIndex );
	unsigned short	TokenHash( const char *pszToken );
protected:
	SAVERESTOREDATA		*m_pdata;
	void		BufferRewind( int size );
	unsigned int	HashString( const char *pszToken );
};
class __base(CSaveRestoreBuffer, 0) CSave __packed
{
public:
	CSave( SAVERESTOREDATA *pdata );
	void	WriteShort( const char *pname, const short *value, int count );
	void	WriteInt( const char *pname, const int *value, int count );
	void	WriteFloat( const char *pname, const float *value, int count );
	void	WriteTime( const char *pname, const float *value, int count );
	void	WriteData( const char *pname, int size, const char *pdata );
	void	WriteString( const char *pname, const char *pstring );
	void	WriteString( const char *pname, const int *stringId, int count );
	void	WriteVector( const char *pname, const Vector &value );
	void	WriteVector( const char *pname, const float *value, int count );
	void	WritePositionVector( const char *pname, const Vector &value );
	void	WritePositionVector( const char *pname, const float *value, int count );
	void	WriteFunction( const char *pname, const int *value, int count );
	int		WriteEntVars( const char *pname, entvars_t *pev );
	int		WriteFields( const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount );
private:
	int		DataEmpty( const char *pdata, int size );
	void	BufferField( const char *pname, int size, const char *pdata );
	void	BufferString( char *pdata, int len );
	void	BufferData( const char *pdata, int size );
	void	BufferHeader( const char *pname, int size );
};
typedef struct
{
	unsigned short		size;
	unsigned short		token;
	char				*pData;
} HEADER;
class __base(CSaveRestoreBuffer, 0) CRestore __packed
{
public:
	CRestore( SAVERESTOREDATA *pdata );
	int		ReadEntVars( const char *pname, entvars_t *pev );
	int		ReadFields( const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount );
	int		ReadField( void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount, int startField, int size, char *pName, void *pData );
	int		ReadInt( void );
	short	ReadShort( void );
	int		ReadNamedInt( const char *pName );
	char	*ReadNamedString( const char *pName );
	int		Empty( void ) ;
	inline	void SetGlobalMode( int global ) ;
	void	PrecacheMode( BOOL mode ) ;
private:
	char	*BufferPointer( void );
	void	BufferReadBytes( char *pOutput, int size );
	void	BufferSkipBytes( int bytes );
	int		BufferSkipZString( void );
	int		BufferCheckZString( const char *string );
	void	BufferReadHeader( HEADER *pheader );
	int		m_global;
	BOOL	m_precache;
};
struct globalentity_s
{
	char			name[64];
	char			levelName[32];
	GLOBALESTATE	state;
	globalentity_t	*pNext;
};
class CGlobalState __packed
{
public:
					CGlobalState();
	void			Reset( void );
	void			ClearStates( void );
	void			EntityAdd( string_t globalname, string_t mapName, GLOBALESTATE state );
	void			EntitySetState( string_t globalname, GLOBALESTATE state );
	void			EntityUpdate( string_t globalname, string_t mapname );
	const globalentity_t	*EntityFromTable( string_t globalname );
	GLOBALESTATE	EntityGetState( string_t globalname );
	int				EntityInTable( string_t globalname ) ;
	int				Save( CSave &save );
	int				Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	void			DumpGlobals( void );
private:
	globalentity_t	*Find( string_t globalname );
	globalentity_t	*m_pList;
	int				m_listCount;
};
typedef struct
	{
	int		fAllSolid;
	int		fStartSolid;
	int		fInOpen;
	int		fInWater;
	float	flFraction;
	vec3_t	vecEndPos;
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;
	edict_t	*pHit;
	int		iHitgroup;
	} TraceResult;
class EHANDLE __packed
{
private:
	edict_t *m_pent;
	int		m_serialnumber;
public:
	edict_t *Get( void );
	edict_t *Set( edict_t *pent );
	operator int ();
	operator CBaseEntity *();
	CBaseEntity * operator = (CBaseEntity *pEntity);
	CBaseEntity * operator ->();
};
typedef struct cvar_s
{
	char	*name;
	char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;
typedef enum
	{
	at_notice,
	at_console,
	at_aiconsole,
	at_warning,
	at_error,
	at_logged
	} ALERT_TYPE;
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(char* s);
	int			(*pfnPrecacheSound)			(char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, int iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	int			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, char *szFmt, ...);
	void		(*pfnEngineFprintf)			(FILE *pfile, char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, long cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	entvars_t*	(*pfnGetVarsOfEnt)			(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(entvars_t* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	unsigned long (*pfnFunctionFromName)	( const char *pName );
	const char *(*pfnNameForFunction)		( unsigned long function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg );
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );
	const char *(*pfnCmd_Argv)				( int argc );
	int			(*pfnCmd_Argc)				( void );
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	long		(*pfnRandomLong)			(long  lLow,  long  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName);
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e );
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);
} enginefuncs_t;
struct __data_var_refs vtable_for_CBaseEntity
{
  void	(* Spawn)( CBaseEntity* p ) ;
  void	(* Precache)( CBaseEntity* p ) ;
  void	(* KeyValue)( CBaseEntity* p, KeyValueData* pkvd) ;
  int		(* Save)( CBaseEntity* p, CSave &save );
  int		(* Restore)( CBaseEntity* p, CRestore &restore );
  int		(* ObjectCaps)( CBaseEntity* p ) ;
  void	(* Activate)( CBaseEntity* p ) ;
  void	(* SetObjectCollisionBox)( CBaseEntity* p );
  int (* Classify)( CBaseEntity* p ) ;
  void (* DeathNotice)( CBaseEntity* p, entvars_t *pevChild ) ;
  void	(* TraceAttack)( CBaseEntity* p, entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType);
  int		(* TakeDamage)( CBaseEntity* p, entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, int bitsDamageType );
  int		(* TakeHealth)( CBaseEntity* p, float flHealth, int bitsDamageType );
  void	(* Killed)( CBaseEntity* p, entvars_t *pevAttacker, int iGib );
  int		(* BloodColor)( CBaseEntity* p ) ;
  void	(* TraceBleed)( CBaseEntity* p, float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType );
  BOOL    (* IsTriggered)( CBaseEntity* p, CBaseEntity *pActivator ) ;
  CBaseMonster *(*MyMonsterPointer)( CBaseEntity* p ) ;
  CSquadMonster *(*MySquadMonsterPointer)( CBaseEntity* p ) ;
  int		(* GetToggleState)( CBaseEntity* p ) ;
  void	(* AddPoints)( CBaseEntity* p, int score, BOOL bAllowNegativeScore ) ;
  void	(* AddPointsToTeam)( CBaseEntity* p, int score, BOOL bAllowNegativeScore ) ;
  BOOL	(* AddPlayerItem)( CBaseEntity* p, CBasePlayerItem *pItem ) ;
  BOOL	(* RemovePlayerItem)( CBaseEntity* p, CBasePlayerItem *pItem ) ;
  int 	(* GiveAmmo)( CBaseEntity* p, int iAmount, char *szName, int iMax ) ;
  float	(* GetDelay)( CBaseEntity* p ) ;
  int		(* IsMoving)( CBaseEntity* p ) ;
  void	(* OverrideReset)( CBaseEntity* p ) ;
  int		(* DamageDecal)( CBaseEntity* p, int bitsDamageType );
  void	(* SetToggleState)( CBaseEntity* p, int state ) ;
  void    (* StartSneaking)( CBaseEntity* p ) ;
  void    (* StopSneaking)( CBaseEntity* p ) ;
  BOOL	(* OnControls)( CBaseEntity* p, entvars_t *pev ) ;
  BOOL    (* IsSneaking)( CBaseEntity* p ) ;
  BOOL	(* IsAlive)( CBaseEntity* p ) ;
  BOOL	(* IsBSPModel)( CBaseEntity* p ) ;
  BOOL	(* ReflectGauss)( CBaseEntity* p ) ;
  BOOL	(* HasTarget)( CBaseEntity* p, string_t targetname ) ;
  BOOL    (* IsInWorld)( CBaseEntity* p );
  BOOL	(* IsPlayer)( CBaseEntity* p ) ;
  BOOL	(* IsNetClient)( CBaseEntity* p ) ;
  const char *(* TeamID)( CBaseEntity* p ) ;
  CBaseEntity *(* GetNextTarget)( CBaseEntity* p );
  void (* Think)( CBaseEntity* p ) ;
  void (* Touch)( CBaseEntity* p, CBaseEntity *pOther ) ;
  void (* Use)( CBaseEntity* p, CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
  void (* Blocked)( CBaseEntity* p, CBaseEntity *pOther ) ;
  CBaseEntity * (* Respawn)( CBaseEntity* p ) ;
  void (* UpdateOwner)( CBaseEntity* p ) ;
  BOOL (* FBecomeProne)( CBaseEntity* p ) ;
  Vector (* Center)( CBaseEntity* p ) ;
  Vector (* EyePosition)( CBaseEntity* p ) ;
  Vector (* EarPosition)( CBaseEntity* p ) ;
  Vector (* BodyTarget)( CBaseEntity* p, const Vector &posSrc ) ;
  int (* Illumination)( CBaseEntity* p ) ;
  BOOL (* FVisible)( CBaseEntity* p, CBaseEntity *pEntity );
  BOOL (* FVisible2)( CBaseEntity* p, const Vector &vecOrigin ); // Was originally named FVisible
};
class CBaseEntity __packed
{
	struct vtable_for_CBaseEntity* vtable;
public:
	entvars_t *pev;
	CBaseEntity			*m_pGoalEnt;
	CBaseEntity			*m_pLink;
	static	TYPEDESCRIPTION m_SaveData[];
  // TODO: Binary ninja does not seem to recognize member function pointer definitions.
  /*
	void (CBaseEntity ::*m_pfnThink)(void);
	void (CBaseEntity ::*m_pfnTouch)( CBaseEntity *pOther );
	void (CBaseEntity ::*m_pfnUse)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void (CBaseEntity ::*m_pfnBlocked)( CBaseEntity *pOther );
  */
	void (*m_pfnThink)(void);
	void (*m_pfnTouch)( CBaseEntity *pOther );
	void (*m_pfnUse)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void (*m_pfnBlocked)( CBaseEntity *pOther );
    void *operator new( size_t stAllocateBlock, entvars_t *pev );
#if _MSC_VER >= 1200
	void operator delete(void *pMem, entvars_t *pev);
#endif
	void UpdateOnRemove( void );
	void EXPORT SUB_Remove( void );
	void EXPORT SUB_DoNothing( void );
	void EXPORT SUB_StartFadeOut ( void );
	void EXPORT SUB_FadeOut ( void );
	void EXPORT SUB_CallUseToggle( void ) ;
	int			ShouldToggle( USE_TYPE useType, BOOL currentState );
	void		FireBullets( ULONG	cShots, Vector  vecSrc, Vector	vecDirShooting,	Vector	vecSpread, float flDistance, int iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t *pevAttacker = NULL  );
	void SUB_UseTargets( CBaseEntity *pActivator, USE_TYPE useType, float value );
	int		Intersects( CBaseEntity *pOther );
	void	MakeDormant( void );
	int		IsDormant( void );
	BOOL    IsLockedByMaster( void ) ;
#ifdef _DEBUG
	static CBaseEntity *Instance( edict_t *pent ) ;
#else
	static CBaseEntity *Instance( edict_t *pent );
#endif
	static CBaseEntity *Instance( entvars_t *pev ) ;
	static CBaseEntity *Instance( int eoffset) ;
	CBaseMonster *GetMonsterPointer( entvars_t *pevMonster ) ;
	CBaseMonster *GetMonsterPointer( edict_t *pentMonster ) ;
#ifdef _DEBUG
	void FunctionCheck( void *pFunction, char *name ) ;
	BASEPTR	ThinkSet( BASEPTR func, char *name ) ;
	ENTITYFUNCPTR TouchSet( ENTITYFUNCPTR func, char *name ) ;
	USEPTR	UseSet( USEPTR func, char *name ) ;
	ENTITYFUNCPTR	BlockedSet( ENTITYFUNCPTR func, char *name ) ;
#endif
	static CBaseEntity *Create( char *szName, const Vector &vecOrigin, const Vector &vecAngles, edict_t *pentOwner = NULL );
	edict_t *edict() ;
	EOFFSET eoffset( ) ;
	int	  entindex( ) ;
};
class CLink __packed
{
public:
	entvars_t	*m_pLinkEnt;
};
class CGraph __packed
{
public:
	BOOL	m_fGraphPresent;
	BOOL	m_fGraphPointersSet;
	int		m_cLinks;
	CLink	*m_pLinkPool;
	void	InitGraph( void );
	int		AllocNodes ( void );
	int		CheckNODFile(char *szMapName);
	int		FLoadGraph(char *szMapName);
	int		FSetGraphPointers(void);
	void	ShowNodeConnections ( int iNode );
	int		FindNearestNode ( const Vector &vecOrigin, CBaseEntity *pEntity );
	int		FindNearestNode ( const Vector &vecOrigin, int afNodeTypes );
};
class CSound __packed
{
public:
	void	Clear ( void );
	void	Reset ( void );
	Vector	m_vecOrigin;
	int		m_iType;
	int		m_iVolume;
	float	m_flExpireTime;
	int		m_iNext;
	int		m_iNextAudible;
	BOOL	FIsSound( void );
	BOOL	FIsScent( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSoundEnt
{
	int	(* ObjectCaps)( class CSoundEnt* p ) ;
};
class __base(CBaseEntity, 0) CSoundEnt __packed
{
	struct vtable_for_CSoundEnt* vtable;
public:
	void Precache ( void );
	void Spawn( void );
	void Think( void );
	void Initialize ( void );
	static void		InsertSound ( int iType, const Vector &vecOrigin, int iVolume, float flDuration );
	static void		FreeSound ( int iSound, int iPrevious );
	static int		ActiveList( void );
	static int		FreeList( void );
	static CSound*	SoundPointerForIndex( int iIndex );
	static int		ClientSoundIndex ( edict_t *pClient );
	BOOL	IsEmpty( void ) ;
	int		ISoundsInList ( int iListType );
	int		IAllocSound ( void );
	int		m_iFreeSound;
	int		m_iActiveSound;
	int		m_cLastActiveSounds;
	BOOL	m_fShowReport;
private:
	CSound		m_SoundPool[ MAX_WORLD_SOUNDS ];
};
class __base(CBaseEntity, 0) CWorld __packed
{
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
};
class __base(CBaseEntity, 0) CWorldItem __packed
{
public:
	void	KeyValue(KeyValueData *pkvd );
	void	Spawn( void );
	int		m_iType;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSprayCan
{
	int	(* ObjectCaps)( class CSprayCan* p ) ;
};
class __base(CBaseEntity, 0) CSprayCan __packed
{
	struct vtable_for_CSprayCan* vtable;
public:
	void	Spawn ( entvars_t *pevOwner );
	void	Think( void );
};
class __base(CBaseEntity, 0) CBloodSplat __packed
{
public:
	void	Spawn ( entvars_t *pevOwner );
	void	Spray ( void );
};
class __base(CBaseEntity, 0) CDecal __packed
{
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT StaticDecal( void );
	void	EXPORT TriggerDecal( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCorpse
{
	int	(* ObjectCaps)( class CCorpse* p ) ;
};
class __base(CBaseEntity, 0) CCorpse __packed
{
  struct vtable_for_CCorpse* vtable;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPointEntity
{
	int	(* ObjectCaps)( class CPointEntity* p ) ;
};
class __base(CBaseEntity, 0) CPointEntity __packed
{
  struct vtable_for_CPointEntity* vtable;
public:
	void	Spawn( void );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CLight
{
	void	(* KeyValue)( class CLight* p, KeyValueData* pkvd );
	void	(* Spawn)( class CLight* p );
	int		(* Save)( class CLight* p, CSave &save );
	int		(* Restore)( class CLight* p, CRestore &restore );
};
class __base(CPointEntity, 0) CLight __packed
{
  struct vtable_for_CLight* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int		m_iStyle;
	int		m_iszPattern;
};
class __base(CLight, 0) CEnvLight __packed
{
public:
	void	KeyValue( KeyValueData* pkvd );
	void	Spawn( void );
};
typedef struct dynpitchvol
{
	int preset;
	int pitchrun;
	int pitchstart;
	int spinup;
	int spindown;
	int volrun;
	int volstart;
	int fadein;
	int fadeout;
	int	lfotype;
	int lforate;
	int lfomodpitch;
	int lfomodvol;
	int cspinup;
	int	cspincount;
	int pitch;
	int spinupsav;
	int spindownsav;
	int pitchfrac;
	int vol;
	int fadeinsav;
	int fadeoutsav;
	int volfrac;
	int	lfofrac;
	int	lfomult;
} dynpitchvol_t;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CAmbientGeneric
{
  int (*Save)(class CAmbientGeneric* p, CSave & save);
  int (*Restore)(class CAmbientGeneric* p, CRestore & restore);
  int (*ObjectCaps)(class CAmbientGeneric* p);
};
class __base(CBaseEntity, 0) CAmbientGeneric __packed
{
  struct vtable_for_CAmbientGeneric* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Precache( void );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT RampThink( void );
	void InitModulationParms(void);
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flAttenuation;
	dynpitchvol_t m_dpv;
	BOOL	m_fActive;
	BOOL	m_fLooping;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CMultiSource
{
  int (*Save)(class CMultiSource* p, CSave & save);
  int (*Restore)(class CMultiSource* p, CRestore & restore);
};
class __base(CPointEntity, 0) CMultiSource __packed
{
  struct vtable_for_CMultiSource* vtable;
public:
	void Spawn( );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int	ObjectCaps( void ) ;
	BOOL IsTriggered( CBaseEntity *pActivator );
	void EXPORT Register( void );
	static	TYPEDESCRIPTION m_SaveData[];
	EHANDLE		m_rgEntities[MS_MAX_TARGETS];
	int			m_rgTriggered[MS_MAX_TARGETS];
	int			m_iTotal;
	string_t	m_globalstate;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CTargetCDAudio
{
  void (*Use)(class CTargetCDAudio* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
};
class __base(CPointEntity, 0) CTargetCDAudio __packed
{
  struct vtable_for_CTargetCDAudio* vtable;
public:
	void			Spawn( void );
	void			KeyValue( KeyValueData *pkvd );
	void			Think( void );
	void			Play( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CEnvSound
{
  int (*Save)(class CEnvSound* p, CSave & save);
  int (*Restore)(class CEnvSound* p, CRestore & restore);
};
class __base(CPointEntity, 0) CEnvSound __packed
{
  struct vtable_for_CEnvSound* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Think( void );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flRadius;
	float m_flRoomtype;
};
typedef struct sentenceg
{
	char szgroupname[CBSENTENCENAME_MAX];
	int count;
	unsigned char rgblru[CSENTENCE_LRU_MAX];
} SENTENCEG;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSpeaker
{
  int (*Save)(class CSpeaker* p, CSave & save);
  int (*Restore)(class CSpeaker* p, CRestore & restore);
  int (*ObjectCaps)(class CSpeaker* p);
};
class __base(CBaseEntity, 0) CSpeaker __packed
{
  struct vtable_for_CSpeaker* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Precache( void );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT SpeakerThink( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int	m_preset;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CNullEntity
{
};
class __base(CBaseEntity, 0) CNullEntity __packed
{
  struct vtable_for_CNullEntity* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CBaseDMStart
{
};
class __base(CPointEntity, 0) CBaseDMStart __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	BOOL		IsTriggered( CBaseEntity *pEntity );
private:
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFrictionModifier
{
  int (*Save)(class CFrictionModifier* p, CSave & save);
  int (*Restore)(class CFrictionModifier* p, CRestore & restore);
  int (*ObjectCaps)(class CFrictionModifier* p);
};
class __base(CBaseEntity, 0) CFrictionModifier __packed
{
  struct vtable_for_CFrictionModifier* vtable;
public:
	void		Spawn( void );
	void		KeyValue( KeyValueData *pkvd );
	void EXPORT	ChangeFriction( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float		m_frictionFraction;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBubbling
{
  int (*Save)(class CBubbling* p, CSave & save);
  int (*Restore)(class CBubbling* p, CRestore & restore);
  int (*ObjectCaps)(class CBubbling* p);
};
class __base(CBaseEntity, 0) CBubbling __packed
{
  struct vtable_for_CBubbling* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT FizzThink( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_density;
	int		m_frequency;
	int		m_bubbleModel;
	int		m_state;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CBlood
{
};
class __base(CPointEntity, 0) CBlood __packed
{
  struct vtable_for_CBlood* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	int		Color( void ) ;
	inline	float 	BloodAmount( void ) ;
	inline	void SetColor( int color ) ;
	inline	void SetBloodAmount( float amount ) ;
	Vector	Direction( void );
	Vector	BloodPosition( CBaseEntity *pActivator );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CShake
{
};
class __base(CPointEntity, 0) CShake __packed
{
  struct vtable_for_CShake* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	float	Amplitude( void ) ;
	inline	float	Frequency( void ) ;
	inline	float	Duration( void ) ;
	inline	float	Radius( void ) ;
	inline	void	SetAmplitude( float amplitude ) ;
	inline	void	SetFrequency( float frequency ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetRadius( float radius ) ;
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CFade
{
};
class __base(CPointEntity, 0) CFade __packed
{
  struct vtable_for_CFade* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	float	Duration( void ) ;
	inline	float	HoldTime( void ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetHoldTime( float hold ) ;
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CMessage
{
};
class __base(CPointEntity, 0) CMessage __packed
{
  struct vtable_for_CMessage* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CSprite
{
  int (*Save)(class CSprite* p, CSave & save);
  int (*Restore)(class CSprite* p, CRestore & restore);
};
class __base(CPointEntity, 0) CSprite __packed
{
  struct vtable_for_CSprite* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int		ObjectCaps( void );
	void EXPORT AnimateThink( void );
	void EXPORT ExpandThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void Animate( float frames );
	void Expand( float scaleSpeed, float fadeSpeed );
	void SpriteInit( const char *pSpriteName, const Vector &origin );
	inline void SetAttachment( edict_t *pEntity, int attachment );
	void TurnOff( void );
	void TurnOn( void );
	inline float Frames( void ) ;
	inline void SetTransparency( int rendermode, int r, int g, int b, int a, int fx );
	inline void SetTexture( int spriteIndex ) ;
	inline void SetScale( float scale ) ;
	inline void SetColor( int r, int g, int b ) ;
	inline void SetBrightness( int brightness ) ;
	inline void AnimateAndDie( float framerate ) ;
	void EXPORT AnimateUntilDead( void );
	static	TYPEDESCRIPTION m_SaveData[];
	static CSprite *SpriteCreate( const char *pSpriteName, const Vector &origin, BOOL animate );
private:
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBeam
{
};
class __base(CBaseEntity, 0) CBeam __packed
{
  struct vtable_for_CBeam* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	int		ObjectCaps( void );
	void EXPORT TriggerTouch( CBaseEntity *pOther );
	inline void	SetType( int type ) ;
	inline void	SetFlags( int flags ) ;
	inline void SetStartPos( const Vector& pos ) ;
	inline void SetEndPos( const Vector& pos ) ;
	void SetStartEntity( int entityIndex );
	void SetEndEntity( int entityIndex );
	inline void SetStartAttachment( int attachment ) ;
	inline void SetEndAttachment( int attachment ) ;
	inline void SetTexture( int spriteIndex ) ;
	inline void SetWidth( int width ) ;
	inline void SetNoise( int amplitude ) ;
	inline void SetColor( int r, int g, int b ) ;
	inline void SetBrightness( int brightness ) ;
	inline void SetFrame( float frame ) ;
	inline void SetScrollRate( int speed ) ;
	inline int	GetType( void ) ;
	inline int	GetFlags( void ) ;
	inline int	GetStartEntity( void ) ;
	inline int	GetEndEntity( void ) ;
	const Vector &GetStartPos( void );
	const Vector &GetEndPos( void );
	Vector Center( void ) ;
	inline int  GetTexture( void ) ;
	inline int  GetWidth( void ) ;
	inline int  GetNoise( void ) ;
	inline int  GetBrightness( void ) ;
	inline int  GetFrame( void ) ;
	inline int  GetScrollRate( void ) ;
	void		RelinkBeam( void );
	void		DoSparks( const Vector &start, const Vector &end );
	CBaseEntity *RandomTargetname( const char *szName );
	void		BeamDamage( TraceResult *ptr );
	void		BeamInit( const char *pSpriteName, int width );
	void		PointsInit( const Vector &start, const Vector &end );
	void		PointEntInit( const Vector &start, int endIndex );
	void		EntsInit( int startIndex, int endIndex );
	void		HoseInit( const Vector &start, const Vector &direction );
	static CBeam *BeamCreate( const char *pSpriteName, int width );
	inline void LiveForTime( float time ) ;
	inline void	BeamDamageInstant( TraceResult *ptr, float damage ) ;
};
struct __base(vtable_for_CBeam, 0) __data_var_refs vtable_for_CLaser
{
  int (*Save)(class CLaser* p, CSave & save);
  int (*Restore)(class CLaser* p, CRestore & restore);
};
class __base(CBeam, 0) CLaser __packed
{
  struct vtable_for_CLaser* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	TurnOn( void );
	void	TurnOff( void );
	int		IsOn( void );
	void	FireAtPoint( TraceResult &point );
	void	EXPORT StrikeThink( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	CSprite	*m_pSprite;
	int		m_iszSpriteName;
	Vector  m_firePosition;
};
struct __base(vtable_for_CBeam, 0) __data_var_refs vtable_for_CLightning
{
  int (*Save)(class CLightning* p, CSave & save);
  int (*Restore)(class CLightning* p, CRestore & restore);
};
class __base(CBeam, 0) CLightning __packed
{
  struct vtable_for_CLightning* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Activate( void );
	void	EXPORT StrikeThink( void );
	void	EXPORT DamageThink( void );
	void	RandomArea( void );
	void	RandomPoint( Vector &vecSrc );
	void	Zap( const Vector &vecSrc, const Vector &vecDest );
	void	EXPORT StrikeUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT ToggleUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL ServerSide( void );
	static	TYPEDESCRIPTION m_SaveData[];
	void	BeamUpdateVars( void );
	int		m_active;
	int		m_iszStartEntity;
	int		m_iszEndEntity;
	float	m_life;
	int		m_boltWidth;
	int		m_noiseAmplitude;
	int		m_brightness;
	int		m_speed;
	float	m_restrike;
	int		m_spriteTexture;
	int		m_iszSpriteName;
	int		m_frameStart;
	float	m_radius;
};
struct __base(vtable_for_CLightning, 0) __data_var_refs vtable_for_CTripBeam
{
};
class __base(CLightning, 0) CTripBeam __packed
{
  struct vtable_for_CTripBeam* vtable;
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CGlow
{
  int (*Save)(class CGlow* p, CSave & save);
  int (*Restore)(class CGlow* p, CRestore & restore);
};
class __base(CPointEntity, 0) CGlow __packed
{
  struct vtable_for_CGlow* vtable;
public:
	void Spawn( void );
	void Think( void );
	void Animate( float frames );
	static	TYPEDESCRIPTION m_SaveData[];
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CShower
{
};
class __base(CBaseEntity, 0) CShower __packed
{
  struct vtable_for_CShower* vtable;
	void Spawn( void );
	void Think( void );
	void Touch( CBaseEntity *pOther );
	int ObjectCaps( void ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CRenderFxManager
{
};
class __base(CBaseEntity, 0) CRenderFxManager __packed
{
  struct vtable_for_CRenderFxManager* vtable;
public:
	void Spawn( void );
	void Use ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBaseDelay
{
  void  (*KeyValue)(class CBaseDelay* p, KeyValueData * pkvd);
  int (*Save)(class CBaseDelay* p, CSave & save);
  int (*Restore)(class CBaseDelay* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CBaseDelay __packed
{
  struct vtable_for_CBaseDelay* vtable;
public:
	float		m_flDelay;
	int			m_iszKillTarget;
	static	TYPEDESCRIPTION m_SaveData[];
	void SUB_UseTargets( CBaseEntity *pActivator, USE_TYPE useType, float value );
	void EXPORT DelayThink( void );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTestEffect
{
};
class __base(CBaseDelay, 0) CTestEffect __packed
{
  struct vtable_for_CTestEffect* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void EXPORT TestThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		m_iLoop;
	int		m_iBeam;
	CBeam	*m_pBeam[24];
	float	m_flBeamTime[24];
	float	m_flStartTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CAutoTrigger
{
  int (*Save)(class CAutoTrigger* p, CSave & save);
  int (*Restore)(class CAutoTrigger* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CAutoTrigger __packed
{
  struct vtable_for_CAutoTrigger* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Precache( void );
	void Think( void );
	int ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int			m_globalstate;
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerRelay
{
  int (*Save)(class CTriggerRelay* p, CSave & save);
  int (*Restore)(class CTriggerRelay* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CTriggerRelay __packed
{
  struct vtable_for_CTriggerRelay* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CBreakable
{
  int (*TakeDamage)(class CBreakable* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
  int (*ObjectCaps)(class CBreakable* p);
  int (*Save)(class CBreakable* p, CSave & save);
  int (*Restore)(class CBreakable* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CBreakable __packed
{
  struct vtable_for_CBreakable* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData* pkvd);
	void EXPORT BreakTouch( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void DamageSound( void );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType );
	BOOL IsBreakable( void );
	BOOL SparkWhenHit( void );
	int	 DamageDecal( int bitsDamageType );
	void EXPORT		Die( void );
	inline BOOL		Explodable( void ) ;
	inline int		ExplosionMagnitude( void ) ;
	inline void		ExplosionSetMagnitude( int magnitude ) ;
	static void MaterialSoundPrecache( Materials precacheMaterial );
	static void MaterialSoundRandom( edict_t *pEdict, Materials soundMaterial, float volume );
	static const char **MaterialSoundList( Materials precacheMaterial, int &soundCount );
	static const char *pSoundsWood[];
	static const char *pSoundsFlesh[];
	static const char *pSoundsGlass[];
	static const char *pSoundsMetal[];
	static const char *pSoundsConcrete[];
	static const char *pSpawnObjects[];
	static	TYPEDESCRIPTION m_SaveData[];
	Materials	m_Material;
	Explosions	m_Explosion;
	int			m_idShard;
	float		m_angle;
	int			m_iszGibModel;
	int			m_iszSpawnObject;
};
struct __base(vtable_for_CBreakable, 0) __data_var_refs vtable_for_CPushable
{
  int (*ObjectCaps)(class CPushable* p);
  int (*Save)(class CPushable* p, CSave & save);
  int (*Restore)(class CPushable* p, CRestore & restore);
  int (*TakeDamage)(class CPushable* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
};
class __base(CBreakable, 0) CPushable __packed
{
  struct vtable_for_CPushable* vtable;
public:
	void	Spawn ( void );
	void	Precache( void );
	void	Touch ( CBaseEntity *pOther );
	void	Move( CBaseEntity *pMover, int push );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT StopSound( void );
	inline float MaxSpeed( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	static char *m_soundNames[3];
	int		m_lastSound;
	float	m_maxSpeed;
	float	m_soundTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CEnvFunnel
{
};
class __base(CBaseDelay, 0) CEnvFunnel __packed
{
  struct vtable_for_CEnvFunnel* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		m_iSprite;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CEnvBeverage
{
};
class __base(CBaseDelay, 0) CEnvBeverage __packed
{
  struct vtable_for_CEnvBeverage* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CItemSoda
{
};
class __base(CBaseEntity, 0) CItemSoda __packed
{
  struct vtable_for_CItemSoda* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	EXPORT CanThink ( void );
	void	EXPORT CanTouch ( CBaseEntity *pOther );
};
typedef struct
{
	int			event;
	char		*options;
} MonsterEvent_t;
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CBaseAnimating
{
  int (*Save)(class CBaseAnimating* p, CSave & save);
  int (*Restore)(class CBaseAnimating* p, CRestore & restore);
  void (*HandleAnimEvent)(class CBaseAnimating* p, MonsterEvent_t * pEvent);
};
class __base(CBaseDelay, 0) CBaseAnimating __packed
{
  struct vtable_for_CBaseAnimating* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	float StudioFrameAdvance( float flInterval = 0.0 );
	int	 GetSequenceFlags( void );
	int  LookupActivity ( int activity );
	int  LookupActivityHeaviest ( int activity );
	int  LookupSequence ( const char *label );
	void ResetSequenceInfo ( );
	void DispatchAnimEvents ( float flFutureInterval = 0.1 );
	float SetBoneController ( int iController, float flValue );
	void InitBoneControllers ( void );
	float SetBlending ( int iBlender, float flValue );
	void GetBonePosition ( int iBone, Vector &origin, Vector &angles );
	void GetAutomovement( Vector &origin, Vector &angles, float flInterval = 0.1 );
	int  FindTransition( int iEndingSequence, int iGoalSequence, int *piDir );
	void GetAttachment ( int iAttachment, Vector &origin, Vector &angles );
	void SetBodygroup( int iGroup, int iValue );
	int GetBodygroup( int iGroup );
	int ExtractBbox( int sequence, float *mins, float *maxs );
	void SetSequenceBox( void );
	float				m_flFrameRate;
	float				m_flGroundSpeed;
	float				m_flLastEventCheck;
	BOOL				m_fSequenceFinished;
	BOOL				m_fSequenceLoops;
};
typedef enum
	{
	TS_AT_TOP,
	TS_AT_BOTTOM,
	TS_GOING_UP,
	TS_GOING_DOWN
	} TOGGLE_STATE;
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CBaseToggle
{
  int (*Save)(class CBaseToggle* p, CSave & save);
  int (*Restore)(class CBaseToggle* p, CRestore & restore);
  int (*GetToggleState)(class CBaseToggle* p);
  float (*GetDelay)(class CBaseToggle* p);
};
class __base(CBaseAnimating, 0) CBaseToggle __packed
{
  struct vtable_for_CBaseToggle* vtable;
public:
	void				KeyValue( KeyValueData *pkvd );
	TOGGLE_STATE		m_toggle_state;
	float				m_flActivateFinished;
	float				m_flMoveDistance;
	float				m_flWait;
	float				m_flLip;
	float				m_flTWidth;
	float				m_flTLength;
	Vector				m_vecPosition1;
	Vector				m_vecPosition2;
	Vector				m_vecAngle1;
	Vector				m_vecAngle2;
	int					m_cTriggersLeft;
	float				m_flHeight;
	EHANDLE				m_hActivator;
  // TODO: Binary ninja does not seem to recognize member function pointer definitions.
	//void (CBaseToggle::*m_pfnCallWhenMoveDone)(void);
	void (*m_pfnCallWhenMoveDone)(void);
	Vector				m_vecFinalDest;
	Vector				m_vecFinalAngle;
	int					m_bitsDamageInflict;
	static	TYPEDESCRIPTION m_SaveData[];
	void LinearMove( Vector	vecDest, float flSpeed );
	void EXPORT LinearMoveDone( void );
	void AngularMove( Vector vecDestAngle, float flSpeed );
	void EXPORT AngularMoveDone( void );
	BOOL IsLockedByMaster( void );
	static float		AxisValue( int flags, const Vector &angles );
	static void			AxisDir( entvars_t *pev );
	static float		AxisDelta( int flags, const Vector &angle1, const Vector &angle2 );
	string_t m_sMaster;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMultiManager
{
  int (*Save)(class CMultiManager* p, CSave & save);
  int (*Restore)(class CMultiManager* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMultiManager __packed
{
  struct vtable_for_CMultiManager* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn ( void );
	void EXPORT ManagerThink ( void );
	void EXPORT ManagerUse   ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
#if _DEBUG
	void EXPORT ManagerReport( void );
#endif
	BOOL		HasTarget( string_t targetname );
	int ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_cTargets;
	int		m_index;
	float	m_startTime;
	int		m_iTargetName	[ MAX_MULTI_TARGETS ];
	float	m_flTargetDelay [ MAX_MULTI_TARGETS ];
private:
	inline BOOL IsClone( void ) ;
	inline BOOL ShouldClone( void );
	CMultiManager *Clone( void );
};
typedef struct locksounds
{
	string_t	sLockedSound;
	string_t	sLockedSentence;
	string_t	sUnlockedSound;
	string_t	sUnlockedSentence;
	int		iLockedSentence;
	int		iUnlockedSentence;
	float	flwaitSound;
	float	flwaitSentence;
	BYTE	bEOFLocked;
	BYTE	bEOFUnlocked;
} locksound_t;
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseButton
{
  void (*Precache)(class CBaseButton* p);
  void (*KeyValue)(class CBaseButton* p, KeyValueData * pkvd);
  int (*TakeDamage)(class CBaseButton* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
  int (*Save)(class CBaseButton* p, CSave & save);
  int (*Restore)(class CBaseButton* p, CRestore & restore);
  int (*ObjectCaps)(class CBaseButton* p);
};
class __base(CBaseToggle, 0) CBaseButton __packed
{
  struct vtable_for_CBaseButton* vtable;
public:
	void Spawn( void );
	void RotSpawn( void );
	void ButtonActivate( );
	void SparkSoundCache( void );
	void EXPORT ButtonShot( void );
	void EXPORT ButtonTouch( CBaseEntity *pOther );
	void EXPORT ButtonSpark ( void );
	void EXPORT TriggerAndWait( void );
	void EXPORT ButtonReturn( void );
	void EXPORT ButtonBackHome( void );
	void EXPORT ButtonUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	enum BUTTON_CODE { BUTTON_NOTHING, BUTTON_ACTIVATE, BUTTON_RETURN };
	BUTTON_CODE	ButtonResponseToTouch( void );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL	m_fStayPushed;
	BOOL	m_fRotating;
	string_t m_strChangeTarget;
	locksound_t m_ls;
	BYTE	m_bLockedSound;
	BYTE	m_bLockedSentence;
	BYTE	m_bUnlockedSound;
	BYTE	m_bUnlockedSentence;
	int		m_sounds;
};
typedef enum {
	ACT_RESET = 0,
	ACT_IDLE = 1,
	ACT_GUARD,
	ACT_WALK,
	ACT_RUN,
	ACT_FLY,
	ACT_SWIM,
	ACT_HOP,
	ACT_LEAP,
	ACT_FALL,
	ACT_LAND,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_TWITCH,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_ARM,
	ACT_DISARM,
	ACT_EAT,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_SLEEP,
	ACT_INSPECT_FLOOR,
	ACT_INSPECT_WALL,
	ACT_IDLE_ANGRY,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_FLY_LEFT,
	ACT_FLY_RIGHT,
	ACT_DETECT_SCENT,
	ACT_SNIFF,
	ACT_BITE,
	ACT_THREAT_DISPLAY,
	ACT_FEAR_DISPLAY,
	ACT_EXCITED,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
} Activity;
typedef enum
{
	MONSTERSTATE_NONE = 0,
	MONSTERSTATE_IDLE,
	MONSTERSTATE_COMBAT,
	MONSTERSTATE_ALERT,
	MONSTERSTATE_HUNT,
	MONSTERSTATE_PRONE,
	MONSTERSTATE_SCRIPT,
	MONSTERSTATE_PLAYDEAD,
	MONSTERSTATE_DEAD
} MONSTERSTATE;
typedef struct {
	int	type;
	char *name;
} activity_map_t;
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseMonster
{
  float (*ChangeYaw)(class CBaseMonster* p, int speed);
  BOOL(*HasHumanGibs)(class CBaseMonster* p);
  BOOL(*HasAlienGibs)(class CBaseMonster* p);
  void (*FadeMonster)(class CBaseMonster* p);
  void (*GibMonster)(class CBaseMonster* p);
  Activity(*GetDeathActivity) (class CBaseMonster* p);
  void (*BecomeDead)(class CBaseMonster* p);
  BOOL(*ShouldFadeOnDeath)(class CBaseMonster* p);
  int (*IRelationship) (class CBaseMonster* p, CBaseEntity * pTarget);
  int (*TakeHealth)(class CBaseMonster* p, float flHealth, int bitsDamageType);
  int (*TakeDamage)(class CBaseMonster* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
  void (*Killed)(class CBaseMonster* p, entvars_t * pevAttacker, int iGib);
  void (*PainSound) (class CBaseMonster* p);
  void (*ReportAIState)(class CBaseMonster* p);
  void (*MonsterInitDead)(class CBaseMonster* p);
  void (*Look) (class CBaseMonster* p, int iDistance);
  CBaseEntity* (*BestVisibleEnemy) (class CBaseMonster* p);
  BOOL(*FInViewCone) (class CBaseMonster* p, CBaseEntity * pEntity);
  BOOL(*FInViewCone2) (class CBaseMonster* p, Vector * pOrigin); // Was originally named FInViewCone
  BOOL(*IsAlive)(class CBaseMonster* p);
};
class __base(CBaseToggle, 0) CBaseMonster __packed
{
  struct vtable_for_CBaseMonster* vtable;
public:
	Activity			m_Activity;
	Activity			m_IdealActivity;
	int					m_LastHitGroup;
	int					m_bitsDamageType;
	BYTE				m_rgbTimeBasedDamage[CDMG_TIMEBASED];
	MONSTERSTATE		m_MonsterState;
	MONSTERSTATE		m_IdealMonsterState;
	int					m_afConditions;
	int					m_afMemory;
	float				m_flNextAttack;
	EHANDLE				m_hEnemy;
	EHANDLE				m_hTargetEnt;
	float				m_flFieldOfView;
	int					m_bloodColor;
	Vector				m_HackedGunPos;
	Vector				m_vecEnemyLKP;
	void KeyValue( KeyValueData *pkvd );
	void MakeIdealYaw( Vector vecTarget );
	Activity GetSmallFlinchActivity( void );
	BOOL		 ShouldGibMonster( int iGib );
	void		 CallGibMonster( void );
	BOOL FCheckAITrigger( void );
	int			DeadTakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType );
	float DamageForce( float damage );
	void RadiusDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType );
	void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int iClassIgnore, int bitsDamageType );
	inline void	SetConditions( int iConditions ) ;
	inline void	ClearConditions( int iConditions ) ;
	inline BOOL HasConditions( int iConditions ) ;
	inline BOOL HasAllConditions( int iConditions ) ;
	inline void	Remember( int iMemory ) ;
	inline void	Forget( int iMemory ) ;
	inline BOOL HasMemory( int iMemory ) ;
	inline BOOL HasAllMemories( int iMemory ) ;
	inline void StopAnimation( void ) ;
	void EXPORT CorpseFallThink( void );
	CBaseEntity *CheckTraceHullAttack( float flDist, int iDamage, int iDmgType );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, int bitsDamageType);
	void MakeDamageBloodDecal ( int cCount, float flNoise, TraceResult *ptr, const Vector &vecDir );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBasePlayerAmmo
{
  void (*Spawn)(class CBasePlayerAmmo* p);
  BOOL(*AddAmmo)(class CBasePlayerAmmo* p, CBaseEntity * pOther);
};
class __base(CBaseEntity, 0) CBasePlayerAmmo __packed
{
  struct vtable_for_CBasePlayerAmmo* vtable;
public:
	void EXPORT DefaultTouch( CBaseEntity *pOther );
	CBaseEntity* Respawn( void );
	void EXPORT Materialize( void );
};
typedef	enum
{
	BULLET_NONE = 0,
	BULLET_PLAYER_9MM,
	BULLET_PLAYER_MP5,
	BULLET_PLAYER_357,
	BULLET_PLAYER_BUCKSHOT,
	BULLET_PLAYER_CROWBAR,
	BULLET_MONSTER_9MM,
	BULLET_MONSTER_MP5,
	BULLET_MONSTER_12MM,
} Bullet;
typedef struct
{
	int		iSlot;
	int		iPosition;
	const char	*pszAmmo1;
	int		iMaxAmmo1;
	const char	*pszAmmo2;
	int		iMaxAmmo2;
	const char	*pszName;
	int		iMaxClip;
	int		iId;
	int		iFlags;
	int		iWeight;
} ItemInfo;
typedef struct
{
	const char *pszName;
	int iId;
} AmmoInfo;
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CBasePlayerItem
{
  void (*SetObjectCollisionBox)(class CBasePlayerItem* p);
  int (*Save)(class CBasePlayerItem* p, CSave & save);
  int (*Restore)(class CBasePlayerItem* p, CRestore & restore);
  int (*AddToPlayer)(class CBasePlayerItem* p, CBasePlayer * pPlayer);
  int (*AddDuplicate)(class CBasePlayerItem* p, CBasePlayerItem * pItem);
  int (*GetItemInfo)(class CBasePlayerItem* p0, ItemInfo * p);
  BOOL(*CanDeploy)(class CBasePlayerItem* p);
  BOOL(*Deploy)(class CBasePlayerItem* p );
  BOOL(*CanHolster)(class CBasePlayerItem* p);
  void (*Holster)(class CBasePlayerItem* p );
  void (*UpdateItemInfo)(class CBasePlayerItem* p);
  void (*ItemPreFrame)(class CBasePlayerItem* p);
  void (*ItemPostFrame)(class CBasePlayerItem* p);
  void (*Drop)(class CBasePlayerItem* p);
  void (*Kill)(class CBasePlayerItem* p);
  void (*AttachToPlayer) (class CBasePlayerItem* p, CBasePlayer * pPlayer);
  int (*PrimaryAmmoIndex)(class CBasePlayerItem* p );
  int (*SecondaryAmmoIndex)(class CBasePlayerItem* p );
  int (*UpdateClientData)(class CBasePlayerItem* p, CBasePlayer * pPlayer);
  int (*iItemSlot)(class CBasePlayerItem* p);
};
class __base(CBaseAnimating, 0) CBasePlayerItem __packed
{
  struct vtable_for_CBasePlayerItem* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT DestroyItem( void );
	void EXPORT DefaultTouch( CBaseEntity *pOther );
	void EXPORT FallThink ( void );
	void EXPORT Materialize( void );
	void EXPORT AttemptToMaterialize( void );
	CBaseEntity* Respawn ( void );
	void FallInit( void );
	void CheckRespawn( void );
	static ItemInfo ItemInfoArray[ MAX_WEAPONS ];
	static AmmoInfo AmmoInfoArray[ MAX_AMMO_SLOTS ];
	CBasePlayer	*m_pPlayer;
	CBasePlayerItem *m_pNext;
	int		m_iId;
	int			iItemPosition( void ) ;
	const char	*pszAmmo1( void )	;
	int			iMaxAmmo1( void )	;
	const char	*pszAmmo2( void )	;
	int			iMaxAmmo2( void )	;
	const char	*pszName( void )	;
	int			iMaxClip( void )	;
	int			iWeight( void )		;
	int			iFlags( void )		;
	// int		m_iIdPrimary;
	// int		m_iIdSecondary;
};
typedef struct
{
	CBaseEntity		*pEntity;
	float			amount;
	int				type;
} MULTIDAMAGE;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CWeaponBox
{
};
class __base(CBaseEntity, 0) CWeaponBox __packed
{
  struct vtable_for_CWeaponBox* vtable;
	void Precache( void );
	void Spawn( void );
	void Touch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	BOOL IsEmpty( void );
	int  GiveAmmo( int iCount, char *szName, int iMax, int *pIndex = NULL );
	void SetObjectCollisionBox( void );
public:
	void EXPORT Kill ( void );
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL HasWeapon( CBasePlayerItem *pCheckItem );
	BOOL PackWeapon( CBasePlayerItem *pWeapon );
	BOOL PackAmmo( int iszName, int iCount );
	CBasePlayerItem	*m_rgpPlayerItems[MAX_ITEM_TYPES];
	int m_rgiszAmmo[MAX_AMMO_SLOTS];
	int	m_rgAmmo[MAX_AMMO_SLOTS];
	int m_cAmmoTypes;
};
struct __base(vtable_for_CBasePlayerItem, 0) __data_var_refs vtable_for_CBasePlayerWeapon
{
  int (*Save)(class CBasePlayerWeapon* p, CSave & save);
  int (*Restore)(class CBasePlayerWeapon* p, CRestore & restore);
  int (*AddToPlayer)(class CBasePlayerWeapon* p, CBasePlayer * pPlayer);
  int (*AddDuplicate)(class CBasePlayerWeapon* p, CBasePlayerItem * pItem);
  int (*ExtractAmmo)(class CBasePlayerWeapon* p, CBasePlayerWeapon * pWeapon);
  int (*ExtractClipAmmo)(class CBasePlayerWeapon* p, CBasePlayerWeapon * pWeapon);
  int (*AddWeapon)(class CBasePlayerWeapon* p);
  void (*UpdateItemInfo)(class CBasePlayerWeapon* p);
  BOOL(*PlayEmptySound)(class CBasePlayerWeapon* p);
  void (*ResetEmptySound)(class CBasePlayerWeapon* p);
  void (*SendWeaponAnim)(class CBasePlayerWeapon* p, int iAnim);
  BOOL(*CanDeploy)(class CBasePlayerWeapon* p);
  BOOL(*IsUseable)(class CBasePlayerWeapon* p);
  void (*ItemPostFrame)(class CBasePlayerWeapon* p);
  void (*PrimaryAttack)(class CBasePlayerWeapon* p);
  void (*SecondaryAttack)(class CBasePlayerWeapon* p);
  void (*Reload)(class CBasePlayerWeapon* p);
  void (*WeaponIdle)(class CBasePlayerWeapon* p);
  int (*UpdateClientData)(class CBasePlayerWeapon* p, CBasePlayer * pPlayer);
  void (*RetireWeapon)(class CBasePlayerWeapon* p);
  BOOL(*ShouldWeaponIdle)(class CBasePlayerWeapon* p);
  void (*Holster)(class CBasePlayerWeapon* p);
};
class __base(CBasePlayerItem, 0) CBasePlayerWeapon __packed
{
  struct vtable_for_CBasePlayerWeapon* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL AddPrimaryAmmo( int iCount, char *szName, int iMaxClip, int iMaxCarry );
	BOOL AddSecondaryAmmo( int iCount, char *szName, int iMaxCarry );
	int m_iPlayEmptySound;
	int m_fFireOnEmpty;
	BOOL DefaultDeploy( char *szViewModel, char *szWeaponModel, int iAnim, char *szAnimExt );
	int DefaultReload( int iClipSize, int iAnim, float fDelay );
	int	PrimaryAmmoIndex();
	int	SecondaryAmmoIndex();
	float	m_flNextPrimaryAttack;
	float	m_flNextSecondaryAttack;
	float	m_flTimeWeaponIdle;
	int		m_iPrimaryAmmoType;
	int		m_iSecondaryAmmoType;
	int		m_iClip;
	int		m_iClientClip;
	int		m_iClientWeaponState;
	int		m_fInReload;
	int		m_iDefaultAmmo;
};
typedef enum
{
	PLAYER_IDLE,
	PLAYER_WALK,
	PLAYER_JUMP,
	PLAYER_SUPERJUMP,
	PLAYER_DIE,
	PLAYER_ATTACK1,
} PLAYER_ANIM;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBasePlayer
{
  void (*Spawn)(class CBasePlayer* p);
  void (*Jump)(class CBasePlayer* p);
  void (*Duck)(class CBasePlayer* p);
  void (*PreThink)(class CBasePlayer* p);
  void (*PostThink)(class CBasePlayer* p);
  Vector(*GetGunPosition)(class CBasePlayer* p);
  int (*TakeHealth)(class CBasePlayer* p, float flHealth, int bitsDamageType);
  void (*TraceAttack)(class CBasePlayer* p, entvars_t * pevAttacker, float flDamage, Vector vecDir, TraceResult * ptr, int bitsDamageType);
  int (*TakeDamage)(class CBasePlayer* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
  void  (*Killed)(class CBasePlayer* p, entvars_t * pevAttacker, int iGib);
  Vector(*BodyTarget)(class CBasePlayer* p, const Vector & posSrc);
  void (*StartSneaking)(class CBasePlayer* p);
  void (*StopSneaking)(class CBasePlayer* p);
  BOOL(*IsSneaking)(class CBasePlayer* p);
  BOOL(*IsAlive)(class CBasePlayer* p);
  BOOL(*ShouldFadeOnDeath)(class CBasePlayer* p);
  BOOL(*IsPlayer)(class CBasePlayer* p);
  BOOL(*IsNetClient)(class CBasePlayer* p);
  const char* (* TeamID)(class CBasePlayer* p);
  int (*Save)(class CBasePlayer* p, CSave & save);
  int (*Restore)(class CBasePlayer* p, CRestore & restore);
  void (*UpdateClientData)(class CBasePlayer* p);
  int (*ObjectCaps)(class CBasePlayer* p);
  void  (*Precache)(class CBasePlayer* p);
  void (*ImpulseCommands)(class CBasePlayer* p);
};
class __base(CBaseMonster, 0) CBasePlayer __packed
{
  struct vtable_for_CBasePlayer* vtable;
public:
	int					m_iPlayerSound;
	int					m_iTargetVolume;
	int					m_iWeaponVolume;
	int					m_iExtraSoundTypes;
	int					m_iWeaponFlash;
	float				m_flStopExtraSoundTime;
	float				m_flFlashLightTime;
	int					m_iFlashBattery;
	int					m_afButtonLast;
	int					m_afButtonPressed;
	int					m_afButtonReleased;
	edict_t			   *m_pentSndLast;
	float				m_flSndRoomtype;
	float				m_flSndRange;
	float				m_flFallVelocity;
	int					m_rgItems[MAX_ITEMS];
	int					m_fKnownItem;
	int					m_fNewAmmo;
	unsigned int		m_afPhysicsFlags;
	float				m_fNextSuicideTime;
	float				m_flTimeStepSound;
	float				m_flTimeWeaponIdle;
	float				m_flSwimTime;
	float				m_flDuckTime;
	float				m_flWallJumpTime;
	float				m_flSuitUpdate;
	int					m_rgSuitPlayList[CSUITPLAYLIST];
	int					m_iSuitPlayNext;
	int					m_rgiSuitNoRepeat[CSUITNOREPEAT];
	float				m_rgflSuitNoRepeatTime[CSUITNOREPEAT];
	int					m_lastDamageAmount;
	float				m_tbdPrev;
	float				m_flgeigerRange;
	float				m_flgeigerDelay;
	int					m_igeigerRangePrev;
	int					m_iStepLeft;
	char				m_szTextureName[CBTEXTURENAMEMAX];
	char				m_chTextureType;
	int					m_idrowndmg;
	int					m_idrownrestored;
	int					m_bitsHUDDamage;
	BOOL				m_fInitHUD;
	BOOL				m_fGameHUDInitialized;
	int					m_iTrain;
	BOOL				m_fWeapon;
	EHANDLE				m_pTank;
	float				m_fDeadTime;
	BOOL			m_fNoPlayerSound;
	BOOL			m_fLongJump;
	float       m_tSneaking;
	int			m_iUpdateTime;
	int			m_iClientHealth;
	int			m_iClientBattery;
	int			m_iHideHUD;
	int			m_iClientHideHUD;
	int			m_iFOV;
	int			m_iClientFOV;
	CBasePlayerItem	*m_rgpPlayerItems[MAX_ITEM_TYPES];
	CBasePlayerItem *m_pActiveItem;
	CBasePlayerItem *m_pClientActiveItem;
	CBasePlayerItem *m_pLastItem;
	int	m_rgAmmo[MAX_AMMO_SLOTS];
	int	m_rgAmmoLast[MAX_AMMO_SLOTS];
	Vector				m_vecAutoAim;
	BOOL				m_fOnTarget;
	int					m_iDeaths;
	float				m_iRespawnFrames;
	int m_lastx, m_lasty;
	int m_nCustomSprayFrames;
	float	m_flNextDecalTime;
	char m_szTeamName[TEAM_NAME_LENGTH];
	void Pain( void );
	void RenewItems(void);
	void PackDeadPlayerItems( void );
	void RemoveAllItems( BOOL removeSuit );
	BOOL SwitchWeapon( CBasePlayerItem *pWeapon );
	static	TYPEDESCRIPTION m_playerSaveData[];
	BOOL			IsOnLadder( void );
	BOOL			FlashlightIsOn( void );
	void			FlashlightTurnOn( void );
	void			FlashlightTurnOff( void );
	void UpdatePlayerSound ( void );
	void DeathSound ( void );
	int Classify ( void );
	void SetAnimation( PLAYER_ANIM playerAnim );
	void SetWeaponAnimType( const char *szExtention );
	char m_szAnimExtention[32];
	void CheatImpulseCommands( int iImpulse );
	void StartDeathCam( void );
	void StartObserver( Vector vecPosition, Vector vecViewAngle );
	void AddPoints( int score, BOOL bAllowNegativeScore );
	void AddPointsToTeam( int score, BOOL bAllowNegativeScore );
	BOOL AddPlayerItem( CBasePlayerItem *pItem );
	BOOL RemovePlayerItem( CBasePlayerItem *pItem );
	void DropPlayerItem ( char *pszItemName );
	BOOL HasPlayerItem( CBasePlayerItem *pCheckItem );
	BOOL HasNamedPlayerItem( const char *pszItemName );
	BOOL HasWeapons( void );
	void SelectPrevItem( int iItem );
	void SelectNextItem( int iItem );
	void SelectLastItem(void);
	void SelectItem(const char *pstr);
	void ItemPreFrame( void );
	void ItemPostFrame( void );
	void GiveNamedItem( const char *szName );
	void EnableControl(BOOL fControl);
	int  GiveAmmo( int iAmount, char *szName, int iMax );
	void SendAmmoUpdate(void);
	void WaterMove( void );
	void CheckWaterJump( void );
	void EXPORT PlayerDeathThink( void );
	void PlayerUse( void );
	void CheckSuitUpdate();
	void SetSuitUpdate(char *name, int fgroup, int iNoRepeat);
	void UpdateGeigerCounter( void );
	void CheckTimeBasedDamage( void );
	void UpdateStepSound( void );
	void PlayStepSound(int step, float fvol);
	BOOL FBecomeProne ( void );
	void BarnacleVictimBitten ( entvars_t *pevBarnacle );
	void BarnacleVictimReleased ( void );
	static int GetAmmoIndex(const char *psz);
	int AmmoInventory( int iAmmoIndex );
	int Illumination( void );
	void ResetAutoaim( void );
	Vector GetAutoaimVector( float flDelta  );
	Vector AutoaimDeflection( Vector &vecSrc, float flDist, float flDelta  );
	void ForceClientDllUpdate( void );
	void DeathMessage( entvars_t *pevKiller );
	void SetCustomDecalFrames( int nFrames );
	int GetCustomDecalFrames( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CItem
{
  BOOL(*MyTouch)(class CItem* p, CBasePlayer * pPlayer);
};
class __base(CBaseEntity, 0) CItem __packed
{
  struct vtable_for_CItem* vtable;
public:
	void	Spawn( void );
	CBaseEntity*	Respawn( void );
	void	EXPORT ItemTouch( CBaseEntity *pOther );
	void	EXPORT Materialize( void );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CHealthKit
{
  int (*Save)(class CHealthKit* p, CSave & save);
  int (*Restore)(class CHealthKit* p, CRestore & restore);
};
class __base(CItem, 0) CHealthKit __packed
{
  struct vtable_for_CHealthKit* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
/*
	static	TYPEDESCRIPTION m_SaveData[];
*/
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemSuit
{
};
class __base(CItem, 0) CItemSuit __packed
{
  struct vtable_for_CItemSuit* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemBattery
{
};
class __base(CItem, 0) CItemBattery __packed
{
  struct vtable_for_CItemBattery* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemAntidote
{
};
class __base(CItem, 0) CItemAntidote __packed
{
  struct vtable_for_CItemAntidote* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemSecurity
{
};
class __base(CItem, 0) CItemSecurity __packed
{
  struct vtable_for_CItemSecurity* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemLongJump
{
};
class __base(CItem, 0) CItemLongJump __packed
{
  struct vtable_for_CItemLongJump* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct skilldata_t
{
	int iSkillLevel;
	float	agruntHealth;
	float agruntDmgPunch;
	float apacheHealth;
	float barneyHealth;
	float bigmommaHealthFactor;
	float bigmommaDmgSlash;
	float bigmommaDmgBlast;
	float bigmommaRadiusBlast;
	float bullsquidHealth;
	float bullsquidDmgBite;
	float bullsquidDmgWhip;
	float bullsquidDmgSpit;
	float gargantuaHealth;
	float gargantuaDmgSlash;
	float gargantuaDmgFire;
	float gargantuaDmgStomp;
	float hassassinHealth;
	float headcrabHealth;
	float headcrabDmgBite;
	float hgruntHealth;
	float hgruntDmgKick;
	float hgruntShotgunPellets;
	float hgruntGrenadeSpeed;
	float houndeyeHealth;
	float houndeyeDmgBlast;
	float slaveHealth;
	float slaveDmgClaw;
	float slaveDmgClawrake;
	float slaveDmgZap;
	float ichthyosaurHealth;
	float ichthyosaurDmgShake;
	float leechHealth;
	float leechDmgBite;
	float controllerHealth;
	float controllerDmgZap;
	float controllerSpeedBall;
	float controllerDmgBall;
	float nihilanthHealth;
	float nihilanthZap;
	float scientistHealth;
	float snarkHealth;
	float snarkDmgBite;
	float snarkDmgPop;
	float zombieHealth;
	float zombieDmgOneSlash;
	float zombieDmgBothSlash;
	float turretHealth;
	float miniturretHealth;
	float sentryHealth;
	float plrDmgCrowbar;
	float plrDmg9MM;
	float plrDmg357;
	float plrDmgMP5;
	float plrDmgM203Grenade;
	float plrDmgBuckshot;
	float plrDmgCrossbowClient;
	float plrDmgCrossbowMonster;
	float plrDmgRPG;
	float plrDmgGauss;
	float plrDmgEgonNarrow;
	float plrDmgEgonWide;
	float plrDmgHornet;
	float plrDmgHandGrenade;
	float plrDmgSatchel;
	float plrDmgTripmine;
	float monDmg9MM;
	float monDmgMP5;
	float monDmg12MM;
	float monDmgHornet;
	float suitchargerCapacity;
	float batteryCapacity;
	float healthchargerCapacity;
	float healthkitCapacity;
	float scientistHeal;
	float monHead;
	float monChest;
	float monStomach;
	float monLeg;
	float monArm;
	float plrHead;
	float plrChest;
	float plrStomach;
	float plrLeg;
	float plrArm;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBaseSpectator
{
};
class __base(CBaseEntity , 0) CBaseSpectator __packed
{
  struct vtable_for_CBaseSpectator* vtable;
public:
	void Spawn();
	void SpectatorConnect(void);
	void SpectatorDisconnect(void);
	void SpectatorThink(void);
private:
	void SpectatorImpulseCommand(void);
};
struct __data_var_refs vtable_for_CGameRules
{
  void (*RefreshSkillData)(class CGameRules* p);
  void (*Think)(class CGameRules* p) = 0;
  BOOL(*IsAllowedToSpawn)(class CGameRules* p, CBaseEntity* pEntity) = 0;
  BOOL(*FAllowFlashlight)(class CGameRules* p) = 0;
  BOOL(*FShouldSwitchWeapon)(class CGameRules* p, CBasePlayer* pPlayer, CBasePlayerItem* pWeapon) = 0;
  BOOL(*GetNextBestWeapon)(class CGameRules* p, CBasePlayer* pPlayer, CBasePlayerItem* pCurrentWeapon) = 0;
  BOOL(*IsMultiplayer)(class CGameRules* p) = 0;
  BOOL(*IsDeathmatch)(class CGameRules* p) = 0;
  BOOL(*IsTeamplay)(class CGameRules* p);
  BOOL(*IsCoOp)(class CGameRules* p) = 0;
  const char* (*GetGameDescription)(class CGameRules* p);
  BOOL(*ClientConnected)(class CGameRules* p, edict_t* pEntity, const char* pszName, const char* pszAddress, char szRejectReason[128]) = 0;
  void (*InitHUD)(class CGameRules* p, CBasePlayer* pl) = 0;
  void (*ClientDisconnected)(class CGameRules* p, edict_t* pClient) = 0;
  void (*UpdateGameMode)(class CGameRules* p, CBasePlayer* pPlayer);
  float (*FlPlayerFallDamage)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  BOOL(*FPlayerCanTakeDamage)(class CGameRules* p, CBasePlayer* pPlayer, CBaseEntity* pAttacker);
  BOOL(*ShouldAutoAim)(class CGameRules* p, CBasePlayer* pPlayer, edict_t* target);
  void (*PlayerSpawn)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  void (*PlayerThink)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  BOOL(*FPlayerCanRespawn)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  float (*FlPlayerSpawnTime)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  edict_t* (*GetPlayerSpawnSpot)(class CGameRules* p, CBasePlayer* pPlayer);
  BOOL(*AllowAutoTargetCrosshair)(class CGameRules* p);
  BOOL(*ClientCommand)(class CGameRules* p, CBasePlayer* pPlayer, const char* pcmd);
  void (*ClientUserInfoChanged)(class CGameRules* p, CBasePlayer* pPlayer, char* infobuffer);
  int (*IPointsForKill)(class CGameRules* p, CBasePlayer* pAttacker, CBasePlayer* pKilled) = 0;
  void (*PlayerKilled)(class CGameRules* p, CBasePlayer* pVictim, entvars_t* pKiller, entvars_t* pInflictor) = 0;
  void (*DeathNotice)(class CGameRules* p, CBasePlayer* pVictim, entvars_t* pKiller, entvars_t* pInflictor) = 0;
  BOOL(*CanHavePlayerItem)(class CGameRules* p, CBasePlayer* pPlayer, CBasePlayerItem* pWeapon);
  void (*PlayerGotWeapon)(class CGameRules* p, CBasePlayer* pPlayer, CBasePlayerItem* pWeapon) = 0;
  int (*WeaponShouldRespawn)(class CGameRules* p, CBasePlayerItem* pWeapon) = 0;
  float (*FlWeaponRespawnTime)(class CGameRules* p, CBasePlayerItem* pWeapon) = 0;
  float (*FlWeaponTryRespawn)(class CGameRules* p, CBasePlayerItem* pWeapon) = 0;
  Vector(*VecWeaponRespawnSpot)(class CGameRules* p, CBasePlayerItem* pWeapon) = 0;
  BOOL(*CanHaveItem)(class CGameRules* p, CBasePlayer* pPlayer, CItem* pItem) = 0;
  void (*PlayerGotItem)(class CGameRules* p, CBasePlayer* pPlayer, CItem* pItem) = 0;
  int (*ItemShouldRespawn)(class CGameRules* p, CItem* pItem) = 0;
  float (*FlItemRespawnTime)(class CGameRules* p, CItem* pItem) = 0;
  Vector(*VecItemRespawnSpot)(class CGameRules* p, CItem* pItem) = 0;
  BOOL(*CanHaveAmmo)(class CGameRules* p, CBasePlayer* pPlayer, const char* pszAmmoName, int iMaxCarry);
  void (*PlayerGotAmmo)(class CGameRules* p, CBasePlayer* pPlayer, char* szName, int iCount) = 0;
  int (*AmmoShouldRespawn)(class CGameRules* p, CBasePlayerAmmo* pAmmo) = 0;
  float (*FlAmmoRespawnTime)(class CGameRules* p, CBasePlayerAmmo* pAmmo) = 0;
  Vector(*VecAmmoRespawnSpot)(class CGameRules* p, CBasePlayerAmmo* pAmmo) = 0;
  float (*FlHealthChargerRechargeTime)(class CGameRules* p) = 0;
  float (*FlHEVChargerRechargeTime)(class CGameRules* p);
  int (*DeadPlayerWeapons)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  int (*DeadPlayerAmmo)(class CGameRules* p, CBasePlayer* pPlayer) = 0;
  const char* (* GetTeamID)(class CGameRules* p, CBaseEntity* pEntity) = 0;
  int (*PlayerRelationship)(class CGameRules* p, CBaseEntity* pPlayer, CBaseEntity* pTarget) = 0;
  int (*GetTeamIndex)(class CGameRules* p, const char* pTeamName);
  const char* GetIndexedTeamName(int teamIndex);
  BOOL(*IsValidTeam)(class CGameRules* p, const char* pTeamName);
  void (*ChangePlayerTeam)(class CGameRules* p, CBasePlayer* pPlayer, const char* pTeamName, BOOL bKill, BOOL bGib);
  const char* (* SetDefaultPlayerTeam)(class CGameRules* p, CBasePlayer* pPlayer);
  BOOL(*PlayTextureSounds)(class CGameRules* p);
  BOOL(*PlayFootstepSounds)(class CGameRules* p, CBasePlayer* pl, float fvol);
  BOOL(*FAllowMonsters)(class CGameRules* p) = 0;
  void (*EndMultiplayerGame)(class CGameRules* p);
};
class CGameRules
{
  struct vtable_for_CGameRules* vtable;
public:
};
struct __base(vtable_for_CGameRules, 0) __data_var_refs vtable_for_CHalfLifeRules
{
  void (*Think)(class CHalfLifeRules* p);
  BOOL(*IsAllowedToSpawn)(class CHalfLifeRules* p, CBaseEntity * pEntity);
  BOOL(*FAllowFlashlight)(class CHalfLifeRules* p);
  BOOL(*FShouldSwitchWeapon)(class CHalfLifeRules* p, CBasePlayer * pPlayer, CBasePlayerItem * pWeapon);
  BOOL(*GetNextBestWeapon)(class CHalfLifeRules* p, CBasePlayer * pPlayer, CBasePlayerItem * pCurrentWeapon);
  BOOL(*IsMultiplayer)(class CHalfLifeRules* p);
  BOOL(*IsDeathmatch)(class CHalfLifeRules* p);
  BOOL(*IsCoOp)(class CHalfLifeRules* p);
  BOOL(*ClientConnected)(class CHalfLifeRules* p, edict_t * pEntity, const char* pszName, const char* pszAddress, char szRejectReason[128]);
  void (*InitHUD)(class CHalfLifeRules* p, CBasePlayer * pl);
  void (*ClientDisconnected)(class CHalfLifeRules* p, edict_t * pClient);
  float (*FlPlayerFallDamage)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  void (*PlayerSpawn)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  void (*PlayerThink)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  BOOL(*FPlayerCanRespawn)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  float (*FlPlayerSpawnTime)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  BOOL(*AllowAutoTargetCrosshair)(class CHalfLifeRules* p);
  int (*IPointsForKill)(class CHalfLifeRules* p, CBasePlayer * pAttacker, CBasePlayer * pKilled);
  void (*PlayerKilled)(class CHalfLifeRules* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pInflictor);
  void (*DeathNotice)(class CHalfLifeRules* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pInflictor);
  void (*PlayerGotWeapon)(class CHalfLifeRules* p, CBasePlayer * pPlayer, CBasePlayerItem * pWeapon);
  int (*WeaponShouldRespawn)(class CHalfLifeRules* p, CBasePlayerItem * pWeapon);
  float (*FlWeaponRespawnTime)(class CHalfLifeRules* p, CBasePlayerItem * pWeapon);
  float (*FlWeaponTryRespawn)(class CHalfLifeRules* p, CBasePlayerItem * pWeapon);
  Vector(*VecWeaponRespawnSpot)(class CHalfLifeRules* p, CBasePlayerItem * pWeapon);
  BOOL(*CanHaveItem)(class CHalfLifeRules* p, CBasePlayer * pPlayer, CItem * pItem);
  void (*PlayerGotItem)(class CHalfLifeRules* p, CBasePlayer * pPlayer, CItem * pItem);
  int (*ItemShouldRespawn)(class CHalfLifeRules* p, CItem * pItem);
  float (*FlItemRespawnTime)(class CHalfLifeRules* p, CItem * pItem);
  Vector(*VecItemRespawnSpot)(class CHalfLifeRules* p, CItem * pItem);
  void (*PlayerGotAmmo)(class CHalfLifeRules* p, CBasePlayer * pPlayer, char* szName, int iCount);
  int (*AmmoShouldRespawn)(class CHalfLifeRules* p, CBasePlayerAmmo * pAmmo);
  float (*FlAmmoRespawnTime)(class CHalfLifeRules* p, CBasePlayerAmmo * pAmmo);
  Vector(*VecAmmoRespawnSpot)(class CHalfLifeRules* p, CBasePlayerAmmo * pAmmo);
  float (*FlHealthChargerRechargeTime)(class CHalfLifeRules* p);
  int (*DeadPlayerWeapons)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  int (*DeadPlayerAmmo)(class CHalfLifeRules* p, CBasePlayer * pPlayer);
  BOOL(*FAllowMonsters)(class CHalfLifeRules* p);
  const char* (*GetTeamID)(class CHalfLifeRules* p, CBaseEntity * pEntity);
  int (*PlayerRelationship)(class CHalfLifeRules* p, CBaseEntity * pPlayer, CBaseEntity * pTarget);
};
class __base(CGameRules, 0) CHalfLifeRules __packed
{
  struct vtable_for_CHalfLifeRules* vtable;
public:
	CHalfLifeRules ( void );
};
struct __base(vtable_for_CGameRules, 0) __data_var_refs vtable_for_CHalfLifeMultiplay
{
  void (*Think)(class CHalfLifeMultiplay* p);
  void (*RefreshSkillData)(class CHalfLifeMultiplay* p);
  BOOL(*IsAllowedToSpawn)(class CHalfLifeMultiplay* p, CBaseEntity * pEntity);
  BOOL(*FAllowFlashlight)(class CHalfLifeMultiplay* p);
  BOOL(*FShouldSwitchWeapon)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CBasePlayerItem * pWeapon);
  BOOL(*GetNextBestWeapon)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CBasePlayerItem * pCurrentWeapon);
  BOOL(*IsMultiplayer)(class CHalfLifeMultiplay* p);
  BOOL(*IsDeathmatch)(class CHalfLifeMultiplay* p);
  BOOL(*IsCoOp)(class CHalfLifeMultiplay* p);
  BOOL(*ClientConnected)(class CHalfLifeMultiplay* p, edict_t * pEntity, const char* pszName, const char* pszAddress, char szRejectReason[128]);
  void (*InitHUD)(class CHalfLifeMultiplay* p, CBasePlayer * pl);
  void (*ClientDisconnected)(class CHalfLifeMultiplay* p, edict_t * pClient);
  void (*UpdateGameMode)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  float (*FlPlayerFallDamage)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  BOOL(*FPlayerCanTakeDamage)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CBaseEntity * pAttacker);
  void (*PlayerSpawn)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  void (*PlayerThink)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  BOOL(*FPlayerCanRespawn)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  float (*FlPlayerSpawnTime)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  edict_t* (* GetPlayerSpawnSpot)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  BOOL(*AllowAutoTargetCrosshair)(class CHalfLifeMultiplay* p);
  int (*IPointsForKill)(class CHalfLifeMultiplay* p, CBasePlayer * pAttacker, CBasePlayer * pKilled);
  void (*PlayerKilled)(class CHalfLifeMultiplay* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pInflictor);
  void (*DeathNotice)(class CHalfLifeMultiplay* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pInflictor);
  void (*PlayerGotWeapon)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CBasePlayerItem * pWeapon);
  BOOL(*CanHavePlayerItem)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CBasePlayerItem * pWeapon);
  int (*WeaponShouldRespawn)(class CHalfLifeMultiplay* p, CBasePlayerItem * pWeapon);
  float (*FlWeaponRespawnTime)(class CHalfLifeMultiplay* p, CBasePlayerItem * pWeapon);
  float (*FlWeaponTryRespawn)(class CHalfLifeMultiplay* p, CBasePlayerItem * pWeapon);
  Vector(*VecWeaponRespawnSpot)(class CHalfLifeMultiplay* p, CBasePlayerItem * pWeapon);
  BOOL(*CanHaveItem)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CItem * pItem);
  void (*PlayerGotItem)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, CItem * pItem);
  int (*ItemShouldRespawn)(class CHalfLifeMultiplay* p, CItem * pItem);
  float (*FlItemRespawnTime)(class CHalfLifeMultiplay* p, CItem * pItem);
  Vector(*VecItemRespawnSpot)(class CHalfLifeMultiplay* p, CItem * pItem);
  void (*PlayerGotAmmo)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer, char* szName, int iCount);
  int (*AmmoShouldRespawn)(class CHalfLifeMultiplay* p, CBasePlayerAmmo * pAmmo);
  float (*FlAmmoRespawnTime)(class CHalfLifeMultiplay* p, CBasePlayerAmmo * pAmmo);
  Vector(*VecAmmoRespawnSpot)(class CHalfLifeMultiplay* p, CBasePlayerAmmo * pAmmo);
  float (*FlHealthChargerRechargeTime)(class CHalfLifeMultiplay* p);
  float (*FlHEVChargerRechargeTime)(class CHalfLifeMultiplay* p);
  int (*DeadPlayerWeapons)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  int (*DeadPlayerAmmo)(class CHalfLifeMultiplay* p, CBasePlayer * pPlayer);
  const char* (*GetTeamID)(class CHalfLifeMultiplay* p, CBaseEntity * pEntity);
  int (*PlayerRelationship)(class CHalfLifeMultiplay* p, CBaseEntity * pPlayer, CBaseEntity * pTarget);
  BOOL(*PlayTextureSounds)(class CHalfLifeMultiplay* p);
  BOOL(*PlayFootstepSounds)(class CHalfLifeMultiplay* p, CBasePlayer * pl, float fvol);
  BOOL(*FAllowMonsters)(class CHalfLifeMultiplay* p);
  void (*EndMultiplayerGame)(class CHalfLifeMultiplay* p);
  void (*ChangeLevel)(class CHalfLifeMultiplay* p);
  void (*GoToIntermission)(class CHalfLifeMultiplay* p);
};
class __base(CGameRules, 0) CHalfLifeMultiplay __packed
{
  struct vtable_for_CHalfLifeMultiplay* vtable;
public:
	CHalfLifeMultiplay();
protected:
	float m_flIntermissionEndTime;
	BOOL m_iEndIntermissionButtonHit;
	void SendMOTDToClient( edict_t *client );
};
struct __base(vtable_for_CHalfLifeMultiplay, 0) __data_var_refs vtable_for_CHalfLifeTeamplay
{
  BOOL(*ClientCommand)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer, const char* pcmd);
  void (*ClientUserInfoChanged)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer, char* infobuffer);
  BOOL(*IsTeamplay)(class CHalfLifeTeamplay* p);
  BOOL(*FPlayerCanTakeDamage)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer, CBaseEntity * pAttacker);
  int (*PlayerRelationship)(class CHalfLifeTeamplay* p, CBaseEntity * pPlayer, CBaseEntity * pTarget);
  const char* (*GetTeamID)(class CHalfLifeTeamplay* p, CBaseEntity * pEntity);
  BOOL(*ShouldAutoAim)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer, edict_t * target);
  int (*IPointsForKill)(class CHalfLifeTeamplay* p, CBasePlayer * pAttacker, CBasePlayer * pKilled);
  void (*InitHUD)(class CHalfLifeTeamplay* p, CBasePlayer * pl);
  void (*DeathNotice)(class CHalfLifeTeamplay* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pevInflictor);
  const char* (*GetGameDescription)(class CHalfLifeTeamplay* p);
  void (*UpdateGameMode)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer);
  void (*PlayerKilled)(class CHalfLifeTeamplay* p, CBasePlayer * pVictim, entvars_t * pKiller, entvars_t * pInflictor);
  void (*Think) (class CHalfLifeTeamplay* p);
  int (*GetTeamIndex)(class CHalfLifeTeamplay* p, const char* pTeamName);
  const char* (*GetIndexedTeamName)(class CHalfLifeTeamplay* p, int teamIndex);
  BOOL(*IsValidTeam)(class CHalfLifeTeamplay* p, const char* pTeamName);
  void (*ChangePlayerTeam)(class CHalfLifeTeamplay* p, CBasePlayer * pPlayer, const char* pTeamName, BOOL bKill, BOOL bGib);
};
class __base(CHalfLifeMultiplay, 0) CHalfLifeTeamplay __packed
{
  struct vtable_for_CHalfLifeTeamplay* vtable;
public:
	CHalfLifeTeamplay();
	const char *SetDefaultPlayerTeam( CBasePlayer *pPlayer );
private:
	void RecountTeams( void );
	const char *TeamWithFewestPlayers( void );
	BOOL m_DisableDeathMessages;
	BOOL m_DisableDeathPenalty;
	BOOL m_teamLimit;
	char m_szTeamList[TEAMPLAY_TEAMLISTLENGTH];
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CRuleEntity
{
  int (*Save)(class CRuleEntity* p, CSave & save);
  int (*Restore)(class CRuleEntity* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CRuleEntity __packed
{
  struct vtable_for_CRuleEntity* vtable;
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	void	SetMaster( int iszMaster ) ;
protected:
	BOOL	CanFireForActivator( CBaseEntity *pActivator );
private:
	string_t	m_iszMaster;
};
struct __base(vtable_for_CRuleEntity, 0) __data_var_refs vtable_for_CRulePointEntity
{
};
class __base(CRuleEntity, 0) CRulePointEntity __packed
{
  struct vtable_for_CRulePointEntity* vtable;
public:
	void		Spawn( void );
};
struct __base(vtable_for_CRuleEntity, 0) __data_var_refs vtable_for_CRuleBrushEntity
{
};
class __base(CRuleEntity, 0) CRuleBrushEntity __packed
{
  struct vtable_for_CRuleBrushEntity* vtable;
public:
	void		Spawn( void );
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameScore
{
};
class __base(CRulePointEntity, 0) CGameScore __packed
{
  struct vtable_for_CGameScore* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	int		Points( void ) ;
	inline	BOOL	AllowNegativeScore( void ) ;
	inline	BOOL	AwardToTeam( void ) ;
	inline	void	SetPoints( int points ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameEnd
{
};
class __base(CRulePointEntity, 0) CGameEnd __packed
{
  struct vtable_for_CGameEnd* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
};
typedef struct hudtextparms_s
{
	float		x;
	float		y;
	int			effect;
	byte		r1, g1, b1, a1;
	byte		r2, g2, b2, a2;
	float		fadeinTime;
	float		fadeoutTime;
	float		holdTime;
	float		fxTime;
	int			channel;
} hudtextparms_t;
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameText
{
  int (*Save)(class CGameText* p, CSave & save);
  int (*Restore)(class CGameText* p, CRestore & restore);
};
class __base(CRulePointEntity, 0) CGameText __packed
{
  struct vtable_for_CGameText* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	inline	BOOL	MessageToAll( void ) ;
	inline	void	MessageSet( const char *pMessage ) ;
	inline	const char *MessageGet( void )	;
private:
	hudtextparms_t	m_textParms;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameTeamMaster
{
};
class __base(CRulePointEntity, 0) CGameTeamMaster __packed
{
  struct vtable_for_CGameTeamMaster* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int			ObjectCaps( void ) ;
	BOOL		IsTriggered( CBaseEntity *pActivator );
	const char	*TeamID( void );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL AnyTeam( void ) ;
private:
	BOOL		TeamMatch( CBaseEntity *pActivator );
	int			m_teamIndex;
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameTeamSet
{
};
class __base(CRulePointEntity, 0) CGameTeamSet __packed
{
  struct vtable_for_CGameTeamSet* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ShouldClearTeam( void ) ;
private:
};
struct __base(vtable_for_CRuleBrushEntity, 0) __data_var_refs vtable_for_CGamePlayerZone
{
  int (*Save)(class CGamePlayerZone* p, CSave & save);
  int (*Restore)(class CGamePlayerZone* p, CRestore & restore);
};
class __base(CRuleBrushEntity, 0) CGamePlayerZone __packed
{
  struct vtable_for_CGamePlayerZone* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	string_t	m_iszInTarget;
	string_t	m_iszOutTarget;
	string_t	m_iszInCount;
	string_t	m_iszOutCount;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerHurt
{
};
class __base(CRulePointEntity, 0) CGamePlayerHurt __packed
{
  struct vtable_for_CGamePlayerHurt* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameCounter
{
};
class __base(CRulePointEntity, 0) CGameCounter __packed
{
  struct vtable_for_CGameCounter* vtable;
public:
	void		Spawn( void );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ResetOnFire( void ) ;
	inline void CountUp( void ) ;
	inline void CountDown( void ) ;
	inline void ResetCount( void ) ;
	inline int  CountValue( void ) ;
	inline int	LimitValue( void ) ;
	inline BOOL HitLimit( void ) ;
private:
	inline void SetCountValue( int value ) ;
	inline void SetInitialValue( int value ) ;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameCounterSet
{
};
class __base(CRulePointEntity, 0) CGameCounterSet __packed
{
  struct vtable_for_CGameCounterSet* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerEquip
{
};
class __base(CRulePointEntity, 0) CGamePlayerEquip __packed
{
  struct vtable_for_CGamePlayerEquip* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Touch( CBaseEntity *pOther );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL	UseOnly( void ) ;
private:
	void		EquipPlayer( CBaseEntity *pPlayer );
	string_t	m_weaponNames[MAX_EQUIP];
	int			m_weaponCount[MAX_EQUIP];
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerTeam
{
};
class __base(CRulePointEntity, 0) CGamePlayerTeam __packed
{
  struct vtable_for_CGamePlayerTeam* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ShouldKillPlayer( void ) ;
	inline BOOL ShouldGibPlayer( void ) ;
	const char *TargetTeamName( const char *pszTargetName );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CStripWeapons
{
};
class __base(CPointEntity, 0) CStripWeapons __packed
{
  struct vtable_for_CStripWeapons* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CRevertSaved
{
  int (*Save)(class CRevertSaved* p, CSave & save);
  int (*Restore)(class CRevertSaved* p, CRestore & restore);
};
class __base(CPointEntity, 0) CRevertSaved __packed
{
  struct vtable_for_CRevertSaved* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT MessageThink( void );
	void	EXPORT LoadThink( void );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	inline	float	Duration( void ) ;
	inline	float	HoldTime( void ) ;
	inline	float	MessageTime( void ) ;
	inline	float	LoadTime( void ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetHoldTime( float hold ) ;
	inline	void	SetMessageTime( float time ) ;
	inline	void	SetLoadTime( float time ) ;
private:
	float	m_messageTime;
	float	m_loadTime;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CInfoIntermission
{
};
class __base(CPointEntity, 0) CInfoIntermission __packed
{
  struct vtable_for_CInfoIntermission* vtable;
	void Spawn( void );
	void Think( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CGib
{
  int (*ObjectCaps)(class CGib* p);
};
class __base(CBaseEntity, 0) CGib __packed
{
  struct vtable_for_CGib* vtable;
public:
	void Spawn( const char *szGibModel );
	void EXPORT BounceGibTouch ( CBaseEntity *pOther );
	void EXPORT StickyGibTouch ( CBaseEntity *pOther );
	void EXPORT WaitTillLand( void );
	void		LimitVelocity( void );
	static	void SpawnHeadGib( entvars_t *pevVictim );
	static	void SpawnRandomGibs( entvars_t *pevVictim, int cGibs, int human );
	static  void SpawnStickyGibs( entvars_t *pevVictim, Vector vecOrigin, int cGibs );
	int		m_bloodColor;
	int		m_cBloodDecals;
	int		m_material;
	float	m_lifeTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CGibShooter
{
  CGib* (*CreateGib)(class CGibShooter* p);
  int (*Save)(class CGibShooter* p, CSave & save);
  int (*Restore)(class CGibShooter* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CGibShooter __packed
{
  struct vtable_for_CGibShooter* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void EXPORT ShootThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int	m_iGibs;
	int m_iGibCapacity;
	int m_iGibMaterial;
	int m_iGibModelIndex;
	float m_flGibVelocity;
	float m_flVariance;
	float m_flGibLife;
};
struct __base(vtable_for_CGibShooter, 0) __data_var_refs vtable_for_CEnvShooter
{
};
class __base(CGibShooter, 0) CEnvShooter __packed
{
  struct vtable_for_CEnvShooter* vtable;
	void		Precache( void );
	void		KeyValue( KeyValueData *pkvd );
	CGib		*CreateGib( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CPathTrack
{
  int (*Save)(class CPathTrack* p, CSave & save);
  int (*Restore)(class CPathTrack* p, CRestore & restore);
};
class __base(CPointEntity, 0) CPathTrack __packed
{
  struct vtable_for_CPathTrack* vtable;
public:
	void		Spawn( void );
	void		Activate( void );
	void		KeyValue( KeyValueData* pkvd);
	void		SetPrevious( CPathTrack *pprevious );
	void		Link( void );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	CPathTrack	*ValidPath( CPathTrack *ppath, int testFlag );
	void		Project( CPathTrack *pstart, CPathTrack *pend, Vector *origin, float dist );
	static CPathTrack *Instance( edict_t *pent );
	CPathTrack	*LookAhead( Vector *origin, float dist, int move );
	CPathTrack	*Nearest( Vector origin );
	CPathTrack	*GetNext( void );
	CPathTrack	*GetPrevious( void );
	static	TYPEDESCRIPTION m_SaveData[];
#if PATH_SPARKLE_DEBUG
	void EXPORT Sparkle(void);
#endif
	float		m_length;
	string_t	m_altName;
	CPathTrack	*m_pnext;
	CPathTrack	*m_pprevious;
	CPathTrack	*m_paltpath;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTrackTrain
{
  int (*Save)(class CFuncTrackTrain* p, CSave & save);
  int (*Restore)(class CFuncTrackTrain* p, CRestore & restore);
  int (*ObjectCaps)(class CFuncTrackTrain* p);
  void  (*OverrideReset)(class CFuncTrackTrain* p);
};
class __base(CBaseEntity, 0) CFuncTrackTrain __packed
{
  struct vtable_for_CFuncTrackTrain* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Blocked( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void KeyValue( KeyValueData* pkvd );
	void EXPORT Next( void );
	void EXPORT Find( void );
	void EXPORT NearestPath( void );
	void EXPORT DeadEnd( void );
	void		NextThink( float thinkTime, BOOL alwaysThink );
	void SetTrack( CPathTrack *track ) ;
	void SetControls( entvars_t *pevControls );
	BOOL OnControls( entvars_t *pev );
	void StopSound ( void );
	void UpdateSound ( void );
	static CFuncTrackTrain *Instance( edict_t *pent );
	static	TYPEDESCRIPTION m_SaveData[];
	CPathTrack	*m_ppath;
	float		m_length;
	float		m_height;
	float		m_speed;
	float		m_dir;
	float		m_startSpeed;
	Vector		m_controlMins;
	Vector		m_controlMaxs;
	int			m_soundPlaying;
	int			m_sounds;
	float		m_flVolume;
	float		m_flBank;
	float		m_oldSpeed;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CPathCorner
{
  int (*Save)(class CPathCorner* p, CSave & save);
  int (*Restore)(class CPathCorner* p, CRestore & restore);
};
class __base(CPointEntity, 0) CPathCorner __packed
{
  struct vtable_for_CPathCorner* vtable;
public:
	void Spawn( );
	void KeyValue( KeyValueData* pkvd );
	float GetDelay( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	float	m_flWait;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBasePlatTrain
{
  int (*ObjectCaps)(class CBasePlatTrain* p);
  BOOL(*IsTogglePlat)(class CBasePlatTrain* p);
  int (*Save)(class CBasePlatTrain* p, CSave & save);
  int (*Restore)(class CBasePlatTrain* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CBasePlatTrain __packed
{
  struct vtable_for_CBasePlatTrain* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	BYTE	m_bMoveSnd;
	BYTE	m_bStopSnd;
	float	m_volume;
};
struct __base(vtable_for_CBasePlatTrain, 0) __data_var_refs vtable_for_CFuncPlat
{
  void (*Blocked)(class CFuncPlat* p, CBaseEntity * pOther);
  void (*GoUp)(class CFuncPlat* p);
  void (*GoDown)(class CFuncPlat* p);
  void (*HitTop)(class CFuncPlat* p);
  void (*HitBottom)(class CFuncPlat* p);
};
class __base(CBasePlatTrain, 0) CFuncPlat __packed
{
  struct vtable_for_CFuncPlat* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Setup( void );
	void EXPORT PlatUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT CallGoDown( void ) ;
	void	EXPORT CallHitTop( void  ) ;
	void	EXPORT CallHitBottom( void ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPlatTrigger
{
  int (*ObjectCaps)(class CPlatTrigger* p);
};
class __base(CBaseEntity, 0) CPlatTrigger __packed
{
  struct vtable_for_CPlatTrigger* vtable;
public:
	void SpawnInsideTrigger( CFuncPlat *pPlatform );
	void Touch( CBaseEntity *pOther );
	CFuncPlat *m_pPlatform;
};
struct __base(vtable_for_CFuncPlat, 0) __data_var_refs vtable_for_CFuncPlatRot
{
  void  (*GoUp)(class CFuncPlatRot* p);
  void  (*GoDown)(class CFuncPlatRot* p);
  void  (*HitTop)(class CFuncPlatRot* p);
  void  (*HitBottom)(class CFuncPlatRot* p);
  int (*Save)(class CFuncPlatRot* p, CSave & save);
  int (*Restore)(class CFuncPlatRot* p, CRestore & restore);
};
class __base(CFuncPlat, 0) CFuncPlatRot __packed
{
  struct vtable_for_CFuncPlatRot* vtable;
public:
	void Spawn( void );
	void SetupRotation( void );
	void			RotMove( Vector &destAngle, float time );
	static	TYPEDESCRIPTION m_SaveData[];
	Vector	m_end, m_start;
};
struct __base(vtable_for_CBasePlatTrain, 0) __data_var_refs vtable_for_CFuncTrain
{
  int (*Save)(class CFuncTrain* p, CSave & save);
  int (*Restore)(class CFuncTrain* p, CRestore & restore);
};
class __base(CBasePlatTrain, 0) CFuncTrain __packed
{
  struct vtable_for_CFuncTrain* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Activate( void );
	void OverrideReset( void );
	void Blocked( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT Wait( void );
	void EXPORT Next( void );
	static	TYPEDESCRIPTION m_SaveData[];
	entvars_t	*m_pevCurrentTarget;
	int			m_sounds;
	BOOL		m_activated;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTrainControls
{
  int (*ObjectCaps)(class CFuncTrainControls* p);
};
class __base(CBaseEntity, 0) CFuncTrainControls __packed
{
  struct vtable_for_CFuncTrainControls* vtable;
public:
	void Spawn( void );
	void EXPORT Find( void );
};
struct __base(vtable_for_CFuncPlatRot, 0) __data_var_refs vtable_for_CFuncTrackChange
{
  void EXPORT (*GoUp)(class CFuncTrackChange* p);
  void EXPORT (*GoDown)(class CFuncTrackChange* p);
  void (*HitBottom)(class CFuncTrackChange* p);
  void (*HitTop)(class CFuncTrackChange* p);
  void (*UpdateAutoTargets)(class CFuncTrackChange* p, int toggleState);
  BOOL (*IsTogglePlat)(class CFuncTrackChange* p);
  int (*Save)(class CFuncTrackChange* p, CSave & save);
  int (*Restore)(class CFuncTrackChange* p, CRestore & restore);
  void (*OverrideReset)(class CFuncTrackChange* p);
};
class __base(CFuncPlatRot, 0) CFuncTrackChange __packed
{
  struct vtable_for_CFuncTrackChange* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void			KeyValue( KeyValueData* pkvd );
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void			EXPORT Find( void );
	TRAIN_CODE		EvaluateTrain( CPathTrack *pcurrent );
	void			UpdateTrain( Vector &dest );
	void			Touch( CBaseEntity *pOther );
	void			DisableUse( void ) ;
	void			EnableUse( void ) ;
	int				UseEnabled( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	CPathTrack		*m_trackTop;
	CPathTrack		*m_trackBottom;
	CFuncTrackTrain	*m_train;
	int				m_trackTopName;
	int				m_trackBottomName;
	int				m_trainName;
	TRAIN_CODE		m_code;
	int				m_targetState;
	int				m_use;
};
struct __base(vtable_for_CFuncTrackChange, 0) __data_var_refs vtable_for_CFuncTrackAuto
{
  void  (*UpdateAutoTargets)(class CFuncTrackAuto* p, int toggleState);
};
class __base(CFuncTrackChange, 0) CFuncTrackAuto __packed
{
  struct vtable_for_CFuncTrackAuto* vtable;
public:
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncWall
{
  int (*ObjectCaps)(class CFuncWall* p);
};
class __base(CBaseEntity, 0) CFuncWall __packed
{
  struct vtable_for_CFuncWall* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncWallToggle
{
};
class __base(CFuncWall, 0) CFuncWallToggle __packed
{
  struct vtable_for_CFuncWallToggle* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	TurnOff( void );
	void	TurnOn( void );
	BOOL	IsOn( void );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncConveyor
{
};
class __base(CFuncWall, 0) CFuncConveyor __packed
{
  struct vtable_for_CFuncConveyor* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	UpdateSpeed( float speed );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CFuncIllusionary
{
  int (*ObjectCaps)(class CFuncIllusionary* p);
};
class __base(CBaseToggle , 0) CFuncIllusionary __packed
{
  struct vtable_for_CFuncIllusionary* vtable;
public:
	void Spawn( void );
	void EXPORT SloshTouch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncMonsterClip
{
};
class __base(CFuncWall, 0) CFuncMonsterClip __packed
{
  struct vtable_for_CFuncMonsterClip* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncRotating
{
  int (*ObjectCaps)(class CFuncRotating* p);
  int (*Save)(class CFuncRotating* p, CSave & save);
  int (*Restore)(class CFuncRotating* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncRotating __packed
{
  struct vtable_for_CFuncRotating* vtable;
public:
	void Spawn( void  );
	void Precache( void  );
	void EXPORT SpinUp ( void );
	void EXPORT SpinDown ( void );
	void KeyValue( KeyValueData* pkvd);
	void EXPORT HurtTouch ( CBaseEntity *pOther );
	void EXPORT RotatingUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT Rotate( void );
	void RampPitchVol (int fUp );
	void Blocked( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flFanFriction;
	float m_flAttenuation;
	float m_flVolume;
	float m_pitch;
	int	  m_sounds;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPendulum
{
  int (*ObjectCaps)(class CPendulum* p);
  int (*Save)(class CPendulum* p, CSave & save);
  int (*Restore)(class CPendulum* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CPendulum __packed
{
  struct vtable_for_CPendulum* vtable;
public:
	void	Spawn ( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT Swing( void );
	void	EXPORT PendulumUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT Stop( void );
	void	Touch( CBaseEntity *pOther );
	void	EXPORT RopeTouch ( CBaseEntity *pOther );
	void	Blocked( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float	m_accel;
	float	m_distance;
	float	m_time;
	float	m_damp;
	float	m_maxSpeed;
	float	m_dampSpeed;
	vec3_t	m_center;
	vec3_t	m_start;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CEnvGlobal
{
  int (*Save)(class CEnvGlobal* p, CSave & save);
  int (*Restore)(class CEnvGlobal* p, CRestore & restore);
};
class __base(CPointEntity, 0) CEnvGlobal __packed
{
  struct vtable_for_CEnvGlobal* vtable;
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	string_t	m_globalstate;
	int			m_triggermode;
	int			m_initialstate;
};
struct __base(vtable_for_CBaseButton, 0) __data_var_refs vtable_for_CRotButton
{
};
class __base(CBaseButton, 0) CRotButton __packed
{
  struct vtable_for_CRotButton* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMomentaryRotButton
{
  int (*ObjectCaps)(class CMomentaryRotButton* p);
  int (*Save)(class CMomentaryRotButton* p, CSave & save);
  int (*Restore)(class CMomentaryRotButton* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMomentaryRotButton __packed
{
  struct vtable_for_CMomentaryRotButton* vtable;
public:
	void	Spawn ( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT Off( void );
	void	EXPORT Return( void );
	void	UpdateSelf( float value );
	void	UpdateSelfReturn( float value );
	void	UpdateAllButtons( float value, int start );
	void	PlaySound( void );
	void	UpdateTarget( float value );
	static CMomentaryRotButton *Instance( edict_t *pent ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_lastUsed;
	int		m_direction;
	float	m_returnSpeed;
	vec3_t	m_start;
	vec3_t	m_end;
	int		m_sounds;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseDoor
{
  void (*KeyValue)(class CBaseDoor* p, KeyValueData * pkvd);
  void (*Use)(class CBaseDoor* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
  void (*Blocked)(class CBaseDoor* p, CBaseEntity * pOther);
  int (*ObjectCaps)(class CBaseDoor* p);
  int (*Save)(class CBaseDoor* p, CSave & save);
  int (*Restore)(class CBaseDoor* p, CRestore & restore);
  void (*SetToggleState)(class CBaseDoor* p, int state);
};
class __base(CBaseToggle, 0) CBaseDoor __packed
{
  struct vtable_for_CBaseDoor* vtable;
public:
	void Spawn( void );
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT DoorTouch( CBaseEntity *pOther );
	int DoorActivate( );
	void EXPORT DoorGoUp( void );
	void EXPORT DoorGoDown( void );
	void EXPORT DoorHitTop( void );
	void EXPORT DoorHitBottom( void );
	BYTE	m_bHealthValue;
	BYTE	m_bMoveSnd;
	BYTE	m_bStopSnd;
	locksound_t m_ls;
	BYTE	m_bLockedSound;
	BYTE	m_bLockedSentence;
	BYTE	m_bUnlockedSound;
	BYTE	m_bUnlockedSentence;
};
struct __base(vtable_for_CBaseDoor, 0) __data_var_refs vtable_for_CRotDoor
{
  void (*SetToggleState)(class CRotDoor* p, int state);
};
class __base(CBaseDoor, 0) CRotDoor __packed
{
  struct vtable_for_CRotDoor* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMomentaryDoor
{
  int (*ObjectCaps)(class CMomentaryDoor* p);
  int (*Save)(class CMomentaryDoor* p, CSave & save);
  int (*Restore)(class CMomentaryDoor* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMomentaryDoor __packed
{
  struct vtable_for_CMomentaryDoor* vtable;
public:
	void	Spawn( void );
	void Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	BYTE	m_bMoveSnd;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CWallHealth
{
  int (*ObjectCaps)(class CWallHealth* p);
  int (*Save)(class CWallHealth* p, CSave & save);
  int (*Restore)(class CWallHealth* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CWallHealth __packed
{
  struct vtable_for_CWallHealth* vtable;
public:
	void Spawn( );
	void Precache( void );
	void EXPORT Off(void);
	void EXPORT Recharge(void);
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flNextCharge;
	int		m_iReactivate ;
	int		m_iJuice;
	int		m_iOn;
	float   m_flSoundTime;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CRecharge
{
  int (*ObjectCaps)(class CRecharge* p);
  int (*Save)(class CRecharge* p, CSave & save);
  int (*Restore)(class CRecharge* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CRecharge __packed
{
  struct vtable_for_CRecharge* vtable;
public:
	void Spawn( );
	void Precache( void );
	void EXPORT Off(void);
	void EXPORT Recharge(void);
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flNextCharge;
	int		m_iReactivate ;
	int		m_iJuice;
	int		m_iOn;
	float   m_flSoundTime;
};
enum TANKBULLET
{
	TANK_BULLET_NONE = 0,
	TANK_BULLET_9MM = 1,
	TANK_BULLET_MP5 = 2,
	TANK_BULLET_12MM = 3,
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTank
{
  void (*Fire)(class CFuncTank* p, const Vector & barrelEnd, const Vector & forward, entvars_t * pevAttacker);
  Vector(*UpdateTargetPosition)(class CFuncTank* p, CBaseEntity * pTarget);
  int (*ObjectCaps)(class CFuncTank* p);
  int (*Save)(class CFuncTank* p, CSave & save);
  int (*Restore)(class CFuncTank* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncTank __packed
{
  struct vtable_for_CFuncTank* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	Think( void );
	void	TrackTarget( void );
	void	StartRotSound( void );
	void	StopRotSound( void );
	inline BOOL IsActive( void ) ;
	inline void TankActivate( void ) ;
	inline void TankDeactivate( void ) ;
	inline BOOL CanFire( void ) ;
	BOOL		InRange( float range );
	edict_t		*FindTarget( edict_t *pPlayer );
	void		TankTrace( const Vector &vecStart, const Vector &vecForward, const Vector &vecSpread, TraceResult &tr );
	Vector		BarrelPosition( void );
	void		AdjustAnglesForBarrel( Vector &angles, float distance );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL OnControls( entvars_t *pevTest );
	BOOL StartControl( CBasePlayer* pController );
	void StopControl( void );
	void ControllerPostFrame( void );
protected:
	CBasePlayer* m_pController;
	float		m_flNextAttack;
	Vector		m_vecControllerUsePos;
	float		m_yawCenter;
	float		m_yawRate;
	float		m_yawRange;
	float		m_yawTolerance;
	float		m_pitchCenter;
	float		m_pitchRate;
	float		m_pitchRange;
	float		m_pitchTolerance;
	float		m_fireLast;
	float		m_fireRate;
	float		m_lastSightTime;
	float		m_persist;
	float		m_minRange;
	float		m_maxRange;
	Vector		m_barrelPos;
	float		m_spriteScale;
	int			m_iszSpriteSmoke;
	int			m_iszSpriteFlash;
	TANKBULLET	m_bulletType;
	int			m_iBulletDamage;
	Vector		m_sightOrigin;
	int			m_spread;
	int			m_iszMaster;
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankGun
{
};
class __base(CFuncTank, 0) CFuncTankGun __packed
{
  struct vtable_for_CFuncTankGun* vtable;
public:
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankLaser
{
  int (*Save)(class CFuncTankLaser* p, CSave & save);
  int (*Restore)(class CFuncTankLaser* p, CRestore & restore);
};
class __base(CFuncTank, 0) CFuncTankLaser __packed
{
  struct vtable_for_CFuncTankLaser* vtable;
public:
	void	Activate( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
	void	Think( void );
	CLaser *GetLaser( void );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	CLaser	*m_pLaser;
	float	m_laserTime;
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankRocket
{
};
class __base(CFuncTank, 0) CFuncTankRocket __packed
{
  struct vtable_for_CFuncTankRocket* vtable;
public:
	void Precache( void );
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankMortar
{
};
class __base(CFuncTank, 0) CFuncTankMortar __packed
{
  struct vtable_for_CFuncTankMortar* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTankControls
{
  int (*ObjectCaps)(class CFuncTankControls* p);
  int (*Save)(class CFuncTankControls* p, CSave & save);
  int (*Restore)(class CFuncTankControls* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncTankControls __packed
{
  struct vtable_for_CFuncTankControls* vtable;
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void Think( void );
	static TYPEDESCRIPTION m_SaveData[];
	CFuncTank *m_pTank;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CFuncMortarField
{
  int (*ObjectCaps)(class CFuncMortarField* p);
  int (*Save)(class CFuncMortarField* p, CSave & save);
  int (*Restore)(class CFuncMortarField* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CFuncMortarField __packed
{
  struct vtable_for_CFuncMortarField* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT FieldUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int m_iszXController;
	int m_iszYController;
	float m_flSpread;
	float m_flDelay;
	int m_iCount;
	int m_fControl;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CCycler
{
  int (*ObjectCaps)(class CCycler* p);
  BOOL(*IsAlive)(class CCycler* p);
  int (*Save)(class CCycler* p, CSave & save);
  int (*Restore)(class CCycler* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CCycler __packed
{
  struct vtable_for_CCycler* vtable;
public:
	void GenericCyclerSpawn(char *szModel, Vector vecMin, Vector vecMax);
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, int bitsDamageType );
	void Spawn( void );
	void Think( void );
	void Use ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int			m_animate;
};
struct __base(vtable_for_CCycler, 0) __data_var_refs vtable_for_CGenericCycler
{
};
class __base(CCycler, 0) CGenericCycler __packed
{
  struct vtable_for_CGenericCycler* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CCycler, 0) __data_var_refs vtable_for_CCyclerProbe
{
};
class __base(CCycler, 0) CCyclerProbe __packed
{
  struct vtable_for_CCyclerProbe* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCyclerSprite
{
  int (*ObjectCaps)(class CCyclerSprite* p);
  int (*TakeDamage)(class CCyclerSprite* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, int bitsDamageType);
  int (*Save)(class CCyclerSprite* p, CSave & save);
  int (*Restore)(class CCyclerSprite* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CCyclerSprite __packed
{
  struct vtable_for_CCyclerSprite* vtable;
public:
	void Spawn( void );
	void Think( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	Animate( float frames );
	static	TYPEDESCRIPTION m_SaveData[];
	inline int		ShouldAnimate( void ) ;
	int			m_animate;
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CWeaponCycler
{
};
class __base(CBasePlayerWeapon, 0) CWeaponCycler __packed
{
  struct vtable_for_CWeaponCycler* vtable;
public:
	void Spawn( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p) ;
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( void );
	int m_iszModel;
	int m_iModel;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CWreckage
{
};
class __base(CBaseMonster, 0) CWreckage __packed
{
  struct vtable_for_CWreckage* vtable;
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void Think( void );
	int m_flStartTime;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGunTarget
{
  int (*ObjectCaps)(class CGunTarget* p);
  int (*Save)(class CGunTarget* p, CSave & save);
  int (*Restore)(class CGunTarget* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CGunTarget __packed
{
  struct vtable_for_CGunTarget* vtable;
public:
	void			Spawn( void );
	void			Activate( void );
	void EXPORT		Next( void );
	void EXPORT		Start( void );
	void EXPORT		Wait( void );
	void			Stop( void );
	int				BloodColor( void ) ;
	int				Classify( void ) ;
	int				TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType );
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	Vector			BodyTarget( const Vector &posSrc ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	BOOL			m_on;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CTalkMonster
{
};
class __base(CBaseMonster, 0) CTalkMonster __packed
{
  struct vtable_for_CTalkMonster* vtable;
public:
	static float g_talkWaitTime;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CEnvSpark
{
  int (*Save)(class CEnvSpark* p, CSave & save);
  int (*Restore)(class CEnvSpark* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CEnvSpark __packed
{
  struct vtable_for_CEnvSpark* vtable;
public:
	void	Spawn(void);
	void	Precache(void);
	void	EXPORT SparkThink(void);
	void	EXPORT SparkStart(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT SparkStop(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue(KeyValueData *pkvd);
	static	TYPEDESCRIPTION m_SaveData[];
	float	m_flDelay;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CEnvExplosion
{
  int (*Save)(class CEnvExplosion* p, CSave & save);
  int (*Restore)(class CEnvExplosion* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CEnvExplosion __packed
{
  struct vtable_for_CEnvExplosion* vtable;
public:
	void Spawn( );
	void EXPORT Smoke ( void );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int m_iMagnitude;
	int m_spriteScale;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CButtonTarget
{
};
class __base(CBaseEntity, 0) CButtonTarget __packed
{
  struct vtable_for_CButtonTarget* vtable;
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, int bitsDamageType );
	int	ObjectCaps( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCrossbowBolt
{
};
class __base(CBaseEntity, 0) CCrossbowBolt __packed
{
  struct vtable_for_CCrossbowBolt* vtable;
	void Spawn( void );
	void Precache( void );
	int  Classify ( void );
	void EXPORT BubbleThink( void );
	void EXPORT BoltTouch( CBaseEntity *pOther );
	void EXPORT ExplodeThink( void );
	int m_iTrail;
public:
	static CCrossbowBolt *BoltCreate( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGrenade
{
  void (*BounceSound)(class CGrenade* p);
  int (*BloodColor)(class CGrenade* p);
  void (*Killed)(class CGrenade* p, entvars_t * pevAttacker, int iGib);
};
class __base(CBaseMonster, 0) CGrenade __packed
{
  struct vtable_for_CGrenade* vtable;
public:
	void Spawn( void );
	typedef enum { SATCHEL_DETONATE = 0, SATCHEL_RELEASE } SATCHELCODE;
	static CGrenade *ShootTimed( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time );
	static CGrenade *ShootContact( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity );
	static CGrenade *ShootSatchelCharge( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity );
	static void UseSatchelCharges( entvars_t *pevOwner, SATCHELCODE code );
	void Explode( Vector vecSrc, Vector vecAim );
	void Explode( TraceResult *pTrace, int bitsDamageType );
	void EXPORT Smoke( void );
	void EXPORT BounceTouch( CBaseEntity *pOther );
	void EXPORT SlideTouch( CBaseEntity *pOther );
	void EXPORT ExplodeTouch( CBaseEntity *pOther );
	void EXPORT DangerSoundThink( void );
	void EXPORT PreDetonate( void );
	void EXPORT Detonate( void );
	void EXPORT DetonateUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT TumbleThink( void );
	BOOL m_fRegisteredSound;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CAirtank
{
  int (*Save)(class CAirtank* p, CSave & save);
  int (*Restore)(class CAirtank* p, CRestore & restore);
};
class __base(CGrenade, 0) CAirtank __packed
{
  struct vtable_for_CAirtank* vtable;
	void Spawn( void );
	void Precache( void );
	void EXPORT TankThink( void );
	void EXPORT TankTouch( CBaseEntity *pOther );
	int	 BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, int iGib );
	static	TYPEDESCRIPTION m_SaveData[];
	int	 m_state;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CMortar
{
};
class __base(CGrenade, 0) CMortar __packed
{
  struct vtable_for_CMortar* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void EXPORT MortarExplode( void );
	int m_spriteTexture;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CRpgRocket
{
};
class __base(CGrenade, 0) CRpgRocket __packed
{
  struct vtable_for_CRpgRocket* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void EXPORT FollowThink( void );
	void EXPORT IgniteThink( void );
	void EXPORT RocketTouch( CBaseEntity *pOther );
	static CRpgRocket *CreateRpgRocket( Vector vecOrigin, Vector vecAngles, CBaseEntity *pOwner, CRpg *pLauncher );
	int m_iTrail;
	float m_flIgniteTime;
	CRpg *m_pLauncher;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CSatchelCharge
{
};
class __base(CGrenade, 0) CSatchelCharge __packed
{
  struct vtable_for_CSatchelCharge* vtable;
	void Spawn( void );
	void Precache( void );
	void BounceSound( void );
	void EXPORT SatchelSlide( CBaseEntity *pOther );
	void EXPORT SatchelThink( void );
public:
	void Deactivate( void );
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CSqueakGrenade
{
  int (*Save)(class CSqueakGrenade* p, CSave & save);
  int (*Restore)(class CSqueakGrenade* p, CRestore & restore);
};
class __base(CGrenade, 0) CSqueakGrenade __packed
{
  struct vtable_for_CSqueakGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	int  Classify( void );
	void EXPORT SuperBounceTouch( CBaseEntity *pOther );
	void EXPORT HuntThink( void );
	int  BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, int iGib );
	void GibMonster( void );
	static	TYPEDESCRIPTION m_SaveData[];
	static float m_flNextBounceSoundTime;
	float m_flDie;
	Vector m_vecTarget;
	float m_flNextHunt;
	float m_flNextHit;
	Vector m_posPrev;
	EHANDLE m_hOwner;
	int  m_iMyClass;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CTripmineGrenade
{
  int (*Save)(class CTripmineGrenade* p, CSave & save);
  int (*Restore)(class CTripmineGrenade* p, CRestore & restore);
};
class __base(CGrenade, 0) CTripmineGrenade __packed
{
  struct vtable_for_CTripmineGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType );
	void EXPORT WarningThink( void );
	void EXPORT PowerupThink( void );
	void EXPORT BeamBreakThink( void );
	void EXPORT DelayDeathThink( void );
	void Killed( entvars_t *pevAttacker, int iGib );
	void MakeBeam( void );
	void KillBeam( void );
	float		m_flPowerUp;
	Vector		m_vecDir;
	Vector		m_vecEnd;
	float		m_flBeamLength;
	EHANDLE		m_hOwner;
	CBeam		*m_pBeam;
	Vector		m_posOwner;
	Vector		m_angleOwner;
	edict_t		*m_pRealOwner;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CHornet
{
  int (*Save)(class CHornet* p, CSave & save);
  int (*Restore)(class CHornet* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CHornet __packed
{
  struct vtable_for_CHornet* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int	 Classify ( void );
	int  IRelationship ( CBaseEntity *pTarget );
	static	TYPEDESCRIPTION m_SaveData[];
	void IgniteTrail( void );
	void EXPORT StartTrack ( void );
	void EXPORT StartDart ( void );
	void EXPORT TrackTarget ( void );
	void EXPORT TrackTouch ( CBaseEntity *pOther );
	void EXPORT DartTouch( CBaseEntity *pOther );
	void EXPORT DieTouch ( CBaseEntity *pOther );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType );
	float			m_flStopAttack;
	int				m_iHornetType;
	float			m_flFlySpeed;
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CCrossbowAmmo
{
};
class __base(CBasePlayerAmmo, 0) CCrossbowAmmo __packed
{
  struct vtable_for_CCrossbowAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CEgonAmmo
{
};
class __base(CBasePlayerAmmo, 0) CEgonAmmo __packed
{
  struct vtable_for_CEgonAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CGaussAmmo
{
};
class __base(CBasePlayerAmmo, 0) CGaussAmmo __packed
{
  struct vtable_for_CGaussAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CGlockAmmo
{
};
class __base(CBasePlayerAmmo, 0) CGlockAmmo __packed
{
  struct vtable_for_CGlockAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5AmmoClip
{
};
class __base(CBasePlayerAmmo, 0) CMP5AmmoClip __packed
{
  struct vtable_for_CMP5AmmoClip* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5Chainammo
{
};
class __base(CBasePlayerAmmo, 0) CMP5Chainammo __packed
{
  struct vtable_for_CMP5Chainammo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5AmmoGrenade
{
};
class __base(CBasePlayerAmmo, 0) CMP5AmmoGrenade __packed
{
  struct vtable_for_CMP5AmmoGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CPythonAmmo
{
};
class __base(CBasePlayerAmmo, 0) CPythonAmmo __packed
{
  struct vtable_for_CPythonAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CRpgAmmo
{
};
class __base(CBasePlayerAmmo, 0) CRpgAmmo __packed
{
  struct vtable_for_CRpgAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CShotgunAmmo
{
};
class __base(CBasePlayerAmmo, 0) CShotgunAmmo __packed
{
  struct vtable_for_CShotgunAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CCrossbow
{
};
class __base(CBasePlayerWeapon, 0) CCrossbow __packed
{
  struct vtable_for_CCrossbow* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( ) ;
	int GetItemInfo(ItemInfo *p);
	void FireBolt( void );
	void FireSniperBolt( void );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( );
	void Holster( );
	void Reload( void );
	void WeaponIdle( void );
	int m_fInZoom;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CCrowbar
{
};
class __base(CBasePlayerWeapon, 0) CCrowbar __packed
{
  struct vtable_for_CCrowbar* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	void EXPORT SwingAgain( void );
	void EXPORT Smack( void );
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	int Swing( int fFirst );
	BOOL Deploy( void );
	void Holster( void );
	int m_iSwing;
	TraceResult m_trHit;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CEgon
{
};
class __base(CBasePlayerWeapon, 0) CEgon __packed
{
  struct vtable_for_CEgon* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	void Holster( void );
	void CreateEffect( void );
	void UpdateEffect( const Vector &startPoint, const Vector &endPoint, float timeBlend );
	void DestroyEffect( void );
	void EndAttack( void );
	void Attack( void );
	void PrimaryAttack( void );
	void WeaponIdle( void );
	static int g_fireAnims1[];
	static int g_fireAnims2[];
	float m_flAmmoUseTime;
	float GetPulseInterval( void );
	float GetDischargeInterval( void );
	void Fire( const Vector &vecOrigSrc, const Vector &vecDir );
	BOOL HasAmmo( void );
	void UseAmmo( int count );
	enum EGON_FIRESTATE { FIRE_OFF, FIRE_CHARGE };
	enum EGON_FIREMODE { FIRE_NARROW, FIRE_WIDE};
private:
	float				m_shootTime;
	CBeam				*m_pBeam;
	CBeam				*m_pNoise;
	CSprite				*m_pSprite;
	EGON_FIRESTATE		m_fireState;
	EGON_FIREMODE		m_fireMode;
	float				m_shakeTime;
	BOOL				m_deployed;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CGauss
{
};
class __base(CBasePlayerWeapon, 0) CGauss __packed
{
  struct vtable_for_CGauss* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	void Holster( void );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void WeaponIdle( void );
	int m_fInAttack;
	float m_flStartCharge;
	float m_flPlayAftershock;
	void StartFire( void );
	void Fire( Vector vecOrigSrc, Vector vecDirShooting, float flDamage );
	float GetFullChargeTime( void );
	int m_iBalls;
	int m_iGlow;
	int m_iBeam;
	int m_iSoundState;
	float m_flNextAmmoBurn;
	BOOL m_fPrimaryFire;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CGlock
{
};
class __base(CBasePlayerWeapon, 0) CGlock __packed
{
  struct vtable_for_CGlock* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void GlockFire( float flSpread, float flCycleTime, BOOL fUseAutoAim );
	BOOL Deploy( void );
	void Reload( void );
	void WeaponIdle( void );
	int m_iShell;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CHandGrenade
{
};
class __base(CBasePlayerWeapon, 0) CHandGrenade __packed
{
  struct vtable_for_CHandGrenade* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	BOOL Deploy( void );
	BOOL CanHolster( void );
	void Holster( void );
	void WeaponIdle( void );
	float m_flStartThrow;
	float m_flReleaseThrow;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CHgun
{
};
class __base(CBasePlayerWeapon, 0) CHgun __packed
{
  struct vtable_for_CHgun* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	BOOL IsUseable( void );
	void Holster( void );
	void Reload( void );
	void WeaponIdle( void );
	float m_flNextAnimTime;
	float m_flRechargeTime;
	int m_iFirePhase;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CMP5
{
};
class __base(CBasePlayerWeapon, 0) CMP5 __packed
{
  struct vtable_for_CMP5* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int SecondaryAmmoIndex( void );
	BOOL Deploy( void );
	void Reload( void );
	void WeaponIdle( void );
	float m_flNextAnimTime;
	int m_iShell;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CPython
{
};
class __base(CBasePlayerWeapon, 0) CPython __packed
{
  struct vtable_for_CPython* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( void );
	void Reload( void );
	void WeaponIdle( void );
	float m_flSoundDelay;
	BOOL m_fInZoom;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CLaserSpot
{
};
class __base(CBaseEntity, 0) CLaserSpot __packed
{
  struct vtable_for_CLaserSpot* vtable;
	void Spawn( void );
	void Precache( void );
	int	ObjectCaps( void ) ;
public:
	void Suspend( float flSuspendTime );
	void EXPORT Revive( void );
	static CLaserSpot *CreateSpot( void );
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CRpg
{
};
class __base(CBasePlayerWeapon, 0) CRpg __packed
{
  struct vtable_for_CRpg* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void Reload( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	BOOL CanHolster( void );
	void Holster( void );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void WeaponIdle( void );
	void UpdateSpot( void );
	BOOL ShouldWeaponIdle( void ) ;
	CLaserSpot *m_pSpot;
	int m_fSpotActive;
	int m_cActiveRockets;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CSatchel
{
};
class __base(CBasePlayerWeapon, 0) CSatchel __packed
{
  struct vtable_for_CSatchel* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int AddDuplicate( CBasePlayerItem *pOriginal );
	BOOL CanDeploy( void );
	BOOL Deploy( void );
	BOOL IsUseable( void );
	void Holster( void );
	void WeaponIdle( void );
	void Throw( void );
	int m_chargeReady;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CShotgun
{
};
class __base(CBasePlayerWeapon, 0) CShotgun __packed
{
  struct vtable_for_CShotgun* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( );
	void Reload( void );
	void WeaponIdle( void );
	int m_fInReload;
	float m_flNextReload;
	int m_iShell;
	float m_flPumpTime;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CSqueak
{
};
class __base(CBasePlayerWeapon, 0) CSqueak __packed
{
  struct vtable_for_CSqueak* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( void );
	void WeaponIdle( void );
	int m_fJustThrown;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CTripmine
{
};
class __base(CBasePlayerWeapon, 0) CTripmine __packed
{
  struct vtable_for_CTripmine* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void SetObjectCollisionBox( void );
	void PrimaryAttack( void );
	BOOL Deploy( void );
	void Holster( void );
	void WeaponIdle( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CDeadHEV
{
};
class __base(CBaseMonster, 0) CDeadHEV __packed
{
  struct vtable_for_CDeadHEV* vtable;
public:
	void Spawn( void );
	int	Classify ( void ) ;
	void KeyValue( KeyValueData *pkvd );
	int	m_iPose;
	static char *m_szPoses[4];
};
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CActAnimating
{
  int (*ObjectCaps)(class CActAnimating* p);
  int (*Save)(class CActAnimating* p, CSave & save);
  int (*Restore)(class CActAnimating* p, CRestore & restore);
};
class __base(CBaseAnimating, 0) CActAnimating __packed
{
  struct vtable_for_CActAnimating* vtable;
public:
	void			SetActivity( Activity act );
	inline Activity	GetActivity( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	Activity	m_Activity;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenPLight
{
  int (*Save)(class CXenPLight* p, CSave & save);
  int (*Restore)(class CXenPLight* p, CRestore & restore);
};
class __base(CActAnimating, 0) CXenPLight __packed
{
  struct vtable_for_CXenPLight* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	void		LightOn( void );
	void		LightOff( void );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	CSprite		*m_pGlow;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenHair
{
};
class __base(CActAnimating, 0) CXenHair __packed
{
  struct vtable_for_CXenHair* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Think( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CXenTreeTrigger
{
};
class __base(CBaseEntity, 0) CXenTreeTrigger __packed
{
  struct vtable_for_CXenTreeTrigger* vtable;
public:
	void		Touch( CBaseEntity *pOther );
	static CXenTreeTrigger *TriggerCreate( edict_t *pOwner, const Vector &position );
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenTree
{
  int (*Save)(class CXenTree* p, CSave & save);
  int (*Restore)(class CXenTree* p, CRestore & restore);
};
class __base(CActAnimating, 0) CXenTree __packed
{
  struct vtable_for_CXenTree* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	int			TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType ) ;
	void		HandleAnimEvent( MonsterEvent_t *pEvent );
	void		Attack( void );
	int			Classify( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	static const char *pAttackHitSounds[];
	static const char *pAttackMissSounds[];
private:
	CXenTreeTrigger	*m_pTrigger;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenSpore
{
};
class __base(CActAnimating, 0) CXenSpore __packed
{
  struct vtable_for_CXenSpore* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	int			TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, int bitsDamageType ) ;
	void		Attack( void ) ;
	static const char *pModelNames[];
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeSmall
{
};
class __base(CXenSpore, 0) CXenSporeSmall __packed
{
  struct vtable_for_CXenSporeSmall* vtable;
	void		Spawn( void );
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeMed
{
};
class __base(CXenSpore, 0) CXenSporeMed __packed
{
  struct vtable_for_CXenSporeMed* vtable;
	void		Spawn( void );
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeLarge
{
};
class __base(CXenSpore, 0) CXenSporeLarge __packed
{
  struct vtable_for_CXenSporeLarge* vtable;
	void		Spawn( void );
	static const Vector m_hullSizes[];
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CXenHull
{
};
class __base(CPointEntity, 0) CXenHull __packed
{
  struct vtable_for_CXenHull* vtable;
public:
	static CXenHull	*CreateHull( CBaseEntity *source, const Vector &mins, const Vector &maxs, const Vector &offset );
	int			Classify( void ) ;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseTrigger
{
  int (*ObjectCaps)(class CBaseTrigger* p);
};
class __base(CBaseToggle, 0) CBaseTrigger __packed
{
  struct vtable_for_CBaseTrigger* vtable;
public:
	void EXPORT TeleportTouch ( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT MultiTouch( CBaseEntity *pOther );
	void EXPORT HurtTouch ( CBaseEntity *pOther );
	void EXPORT CDAudioTouch ( CBaseEntity *pOther );
	void ActivateMultiTrigger( CBaseEntity *pActivator );
	void EXPORT MultiWaitOver( void );
	void EXPORT CounterUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void InitTrigger( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerHurt
{
};
class __base(CBaseTrigger, 0) CTriggerHurt __packed
{
  struct vtable_for_CTriggerHurt* vtable;
public:
	void Spawn( void );
	void EXPORT RadiationThink( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerMonsterJump
{
};
class __base(CBaseTrigger, 0) CTriggerMonsterJump __packed
{
  struct vtable_for_CTriggerMonsterJump* vtable;
public:
	void Spawn( void );
	void Touch( CBaseEntity *pOther );
	void Think( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerCDAudio
{
  void (*Use)(class CTriggerCDAudio* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
};
class __base(CBaseTrigger, 0) CTriggerCDAudio __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void Spawn( void );
	void PlayTrack( void );
	void Touch ( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerMultiple
{
};
class __base(CBaseTrigger, 0) CTriggerMultiple __packed
{
  struct vtable_for_CTriggerMultiple* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CTriggerMultiple, 0) __data_var_refs vtable_for_CTriggerOnce
{
};
class __base(CTriggerMultiple, 0) CTriggerOnce __packed
{
  struct vtable_for_CTriggerOnce* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerCounter
{
};
class __base(CBaseTrigger, 0) CTriggerCounter __packed
{
  struct vtable_for_CTriggerCounter* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CTriggerVolume
{
};
class __base(CPointEntity, 0) CTriggerVolume __packed
{
  struct vtable_for_CTriggerVolume* vtable;
public:
	void		Spawn( void );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CFireAndDie
{
};
class __base(CBaseDelay, 0) CFireAndDie __packed
{
  struct vtable_for_CFireAndDie* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Think( void );
	int ObjectCaps( void ) ;
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CChangeLevel
{
  int (*Save)(class CChangeLevel* p, CSave & save);
  int (*Restore)(class CChangeLevel* p, CRestore & restore);
};
class __base(CBaseTrigger, 0) CChangeLevel __packed
{
  struct vtable_for_CChangeLevel* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT UseChangeLevel ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT TriggerChangeLevel( void );
	void EXPORT ExecuteChangeLevel( void );
	void EXPORT TouchChangeLevel( CBaseEntity *pOther );
	void ChangeLevelNow( CBaseEntity *pActivator );
	static edict_t *FindLandmark( const char *pLandmarkName );
	static int ChangeList( LEVELLIST *pLevelList, int maxList );
	static int AddTransitionToList( LEVELLIST *pLevelList, int listCount, const char *pMapName, const char *pLandmarkName, edict_t *pentLandmark );
	static int InTransitionVolume( CBaseEntity *pEntity, char *pVolumeName );
	static	TYPEDESCRIPTION m_SaveData[];
	char m_szMapName[cchMapNameMost];
	char m_szLandmarkName[cchMapNameMost];
	int		m_changeTarget;
	float	m_changeTargetDelay;
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CLadder
{
};
class __base(CBaseTrigger, 0) CLadder __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Precache( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerPush
{
};
class __base(CBaseTrigger, 0) CTriggerPush __packed
{
  struct vtable_for_CTriggerPush* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void Touch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerTeleport
{
};
class __base(CBaseTrigger, 0) CTriggerTeleport __packed
{
  struct vtable_for_CTriggerTeleport* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerSave
{
};
class __base(CBaseTrigger, 0) CTriggerSave __packed
{
  struct vtable_for_CTriggerSave* vtable;
public:
	void Spawn( void );
	void EXPORT SaveTouch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerEndSection
{
};
class __base(CBaseTrigger, 0) CTriggerEndSection __packed
{
  struct vtable_for_CTriggerEndSection* vtable;
public:
	void Spawn( void );
	void EXPORT EndSectionTouch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT EndSectionUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerGravity
{
};
class __base(CBaseTrigger, 0) CTriggerGravity __packed
{
  struct vtable_for_CTriggerGravity* vtable;
public:
	void Spawn( void );
	void EXPORT GravityTouch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerChangeTarget
{
  int (*Save)(class CTriggerChangeTarget* p, CSave & save);
  int (*Restore)(class CTriggerChangeTarget* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CTriggerChangeTarget __packed
{
  struct vtable_for_CTriggerChangeTarget* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int		m_iszNewTarget;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerCamera
{
  int (*Save)(class CTriggerCamera* p, CSave & save);
  int (*Restore)(class CTriggerCamera* p, CRestore & restore);
  int (*ObjectCaps)(class CTriggerCamera* p);
};
class __base(CBaseDelay, 0) CTriggerCamera __packed
{
  struct vtable_for_CTriggerCamera* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT FollowTarget( void );
	void Move(void);
	static	TYPEDESCRIPTION m_SaveData[];
	EHANDLE m_hPlayer;
	EHANDLE m_hTarget;
	CBaseEntity *m_pentPath;
	int	  m_sPath;
	float m_flWait;
	float m_flReturnTime;
	float m_flStopTime;
	float m_moveDistance;
	float m_targetSpeed;
	float m_initialSpeed;
	float m_acceleration;
	float m_deceleration;
	int	  m_state;
};
