#include <stdio.h>
#define NULL 0
#define EXPORT	_declspec( dllexport )
#define	MAX_ENT_LEAFS	48
#define MAX_LEVEL_CONNECTIONS	16
#define CDMG_TIMEBASED		8
#define MAX_WEAPONS		32
#define MAX_AMMO_SLOTS  32
#define MAX_ITEM_TYPES			6
#define MAX_ITEMS				5
#define CSUITPLAYLIST	4
#define CSUITNOREPEAT		32
#define CBTEXTURENAMEMAX	13
#define TEAM_NAME_LENGTH	16
#define MS_MAX_TARGETS 32
#define MAX_TEAMNAME_LENGTH	16
#define MAX_TEAMS			32
#define TEAMPLAY_TEAMLISTLENGTH		MAX_TEAMS*MAX_TEAMNAME_LENGTH
#define	MAX_WORLD_SOUNDS	64
#define MAX_EQUIP		32
#define CBSENTENCENAME_MAX 16
#define CSENTENCE_LRU_MAX	32
#define cchMapNameMost 32
#define MAX_MULTI_TARGETS	16
#define MAX_WEAPON_NAME 128
#define MAX_WEAPON_SLOTS		5
#define MAX_WEAPON_POSITIONS		MAX_WEAPON_SLOTS
#define	MAX_AMMO_TYPES	32
#define MAX_HISTORY 12
#define NUM_DMG_TYPES		12
#define MAX_SPRITE_NAME_LENGTH	24
#define	ROUTE_SIZE			8
#define MAX_OLD_ENEMIES		4
#define HISTORY_MAX		64
#define MAX_NODE_HULLS		4
#define CACHE_SIZE 128
#define NUM_RANGES 256
#define MAX_STACK_NODES	    100
#define	MAX_SQUAD_MEMBERS	5
#define TLK_CFRIENDS		3
#define		ISLAVE_MAX_BEAMS	8
#define N_SPHERES	20
#define MAX_CARRY	24
#define MAX_MOTD_CHUNK	  60
#define MAX_MOTD_LENGTH   (MAX_MOTD_CHUNK * 4)
typedef unsigned char byte;
typedef unsigned char BYTE;
typedef unsigned long ULONG;
typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;
typedef int BOOL;
typedef int qboolean;
typedef int AMMO;
typedef int HSPRITE;
typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];
typedef int	string_t;
typedef int EOFFSET;
typedef enum { USE_OFF = 0, USE_ON = 1, USE_SET = 2, USE_TOGGLE = 3 } USE_TYPE;
typedef enum { expRandom, expDirected} Explosions;
typedef enum { matGlass = 0, matWood, matMetal, matFlesh, matCinderBlock, matCeilingTile, matComputer, matUnbreakableGlass, matRocks, matNone, matLastMaterial } Materials;
typedef enum { GLOBAL_OFF = 0, GLOBAL_ON = 1, GLOBAL_DEAD = 2 } GLOBALESTATE;
typedef enum { TRAIN_SAFE, TRAIN_BLOCKING, TRAIN_FOLLOWING } TRAIN_CODE;
typedef enum { ignore_monsters=1, dont_ignore_monsters=0, missile=2 } IGNORE_MONSTERS;
typedef enum { ignore_glass=1, dont_ignore_glass=0 } IGNORE_GLASS;
enum hull_t : int32_t { point_hull=0, human_hull=1, large_hull=2, head_hull=3 };
enum dmg_t : int32_t
{
  DMG_GENERIC = 0,
  DMG_CRUSH = (1 << 0),
  DMG_BULLET = (1 << 1),
  DMG_SLASH = (1 << 2),
  DMG_BURN = (1 << 3),
  DMG_FREEZE = (1 << 4),
  DMG_FALL = (1 << 5),
  DMG_BLAST = (1 << 6),
  DMG_CLUB = (1 << 7),
  DMG_SHOCK = (1 << 8),
  DMG_SONIC = (1 << 9),
  DMG_ENERGYBEAM = (1 << 10),
  DMG_NEVERGIB = (1 << 12),
  DMG_ALWAYSGIB = (1 << 13),
  DMG_DROWN = (1 << 14),
  DMG_PARALYZE = (1 << 15),
  DMG_NERVEGAS = (1 << 16),
  DMG_POISON = (1 << 17),
  DMG_RADIATION = (1 << 18),
  DMG_DROWNRECOVER = (1 << 19),
  DMG_ACID = (1 << 20),
  DMG_SLOWBURN = (1 << 21),
  DMG_SLOWFREEZE = (1 << 22),
  DMG_MORTAR = (1 << 23),
  DMG_IGNITE = (1 << 24),
  DMG_RADIUS_MAX = (1 << 25),
  DMG_RADIUS_QUAKE = (1 << 26),
  DMG_IGNOREARMOR = (1 << 27),
  DMG_AIMED = (1 << 28),
  DMG_WALLPIERCING = (1 << 29),
  DMG_CALTROP = (1<<30),
  DMG_HALLUC = (1<<31)
};
enum hudflags_t : int32_t
{
  HUD_ACTIVE = 1,
  HUD_INTERMISSION = 2
};
enum fbeam_t : uint32_t
{
  FBEAM_STARTENTITY = 0x00000001,
  FBEAM_ENDENTITY = 0x00000002,
  FBEAM_FADEIN = 0x00000004,
  FBEAM_FADEOUT = 0x00000008,
  FBEAM_SINENOISE = 0x00000010,
  FBEAM_SOLID = 0x00000020,
  FBEAM_SHADEIN = 0x00000040,
  FBEAM_SHADEOUT = 0x00000080,
  FBEAM_STARTVISIBLE = 0x10000000,
  FBEAM_ENDVISIBLE = 0x20000000,
  FBEAM_ISACTIVE = 0x40000000,
  FBEAM_FOREVER = 0x80000000
};
enum flags_t : int32_t
{
  FL_FLY = (1<<0),
  FL_SWIM = (1<<1),
  FL_CONVEYOR = (1<<2),
  FL_CLIENT = (1<<3),
  FL_INWATER = (1<<4),
  FL_MONSTER = (1<<5),
  FL_GODMODE = (1<<6),
  FL_NOTARGET = (1<<7),
  FL_SKIPLOCALHOST = (1<<8),
  FL_ONGROUND = (1<<9),
  FL_PARTIALGROUND = (1<<10),
  FL_WATERJUMP = (1<<11),
  FL_FROZEN = (1<<12),
  FL_FAKECLIENT = (1<<13),
  FL_DUCKING = (1<<14),
  FL_FLOAT = (1<<15),
  FL_GRAPHED = (1<<16),
  FL_IMMUNE_WATER = (1<<17),
  FL_IMMUNE_SLIME = (1<<18),
  FL_IMMUNE_LAVA = (1<<19),
  FL_ALWAYSTHINK = (1<<21),
  FL_BASEVELOCITY = (1<<22),
  FL_MONSTERCLIP = (1<<23),
  FL_ONTRAIN = (1<<24),
  FL_WORLDBRUSH = (1<<25),
  FL_SPECTATOR = (1<<26),
  FL_CUSTOMENTITY = (1<<29),
  FL_KILLME = (1<<30),
  FL_DORMANT = (1<<31)
};
enum walkmove_t : int32_t
{
  WALKMOVE_NORMAL = 0,
  WALKMOVE_WORLDONLY = 1,
  WALKMOVE_CHECKONLY = 2
};
enum movetype_t : int32_t
{
  MOVETYPE_NONE = 0,
  MOVETYPE_WALK = 3,
  MOVETYPE_STEP = 4,
  MOVETYPE_FLY = 5,
  MOVETYPE_TOSS = 6,
  MOVETYPE_PUSH = 7,
  MOVETYPE_NOCLIP = 8,
  MOVETYPE_FLYMISSILE = 9,
  MOVETYPE_BOUNCE = 10,
  MOVETYPE_BOUNCEMISSILE = 11,
  MOVETYPE_FOLLOW = 12,
  MOVETYPE_PUSHSTEP = 13
};
enum solid_t : int32_t
{
  SOLID_NOT = 0,
  SOLID_TRIGGER = 1,
  SOLID_BBOX = 2,
  SOLID_SLIDEBOX = 3,
  SOLID_BSP = 4
};
enum deadflag_t : int32_t
{
  DEAD_NO = 0,
  DEAD_DYING = 1,
  DEAD_DEAD = 2,
  DEAD_RESPAWNABLE = 3,
  DEAD_DISCARDBODY = 4
};
enum damage_t : int32_t
{
  DAMAGE_NO = 0,
  DAMAGE_YES = 1,
  DAMAGE_AIM = 2
};
enum effects_t : int32_t
{
  EF_BRIGHTFIELD = 1,
  EF_MUZZLEFLASH = 2,
  EF_BRIGHTLIGHT = 4,
  EF_DIMLIGHT = 8,
  EF_INVLIGHT = 16,
  EF_NOINTERP = 32,
  EF_LIGHT = 64,
  EF_NODRAW = 128
};
enum eflags_t : int32_t
{
  EFLAG_SLERP = 1
};
enum te_t : int32_t
{
  TE_BEAMPOINTS = 0,
  TE_BEAMENTPOINT = 1,
  TE_GUNSHOT = 2,
  TE_EXPLOSION = 3,
  TE_TAREXPLOSION = 4,
  TE_SMOKE = 5,
  TE_TRACER = 6,
  TE_LIGHTNING = 7,
  TE_BEAMENTS = 8,
  TE_SPARKS = 9,
  TE_LAVASPLASH = 10,
  TE_TELEPORT = 11,
  TE_EXPLOSION2 = 12,
  TE_BSPDECAL = 13,
  TE_IMPLOSION = 14,
  TE_SPRITETRAIL = 15,
  TE_BEAM = 16,
  TE_SPRITE = 17,
  TE_BEAMSPRITE = 18,
  TE_BEAMTORUS = 19,
  TE_BEAMDISK = 20,
  TE_BEAMCYLINDER = 21,
  TE_BEAMFOLLOW = 22,
  TE_GLOWSPRITE = 23,
  TE_BEAMRING = 24,
  TE_STREAK_SPLASH = 25,
  TE_BEAMHOSE = 26,
  TE_DLIGHT = 27,
  TE_ELIGHT = 28,
  TE_TEXTMESSAGE = 29,
  TE_KILLBEAM = 99,
  TE_LARGEFUNNEL = 100,
  TE_BLOODSTREAM = 101,
  TE_SHOWLINE = 102,
  TE_BLOOD = 103,
  TE_DECAL = 104,
  TE_FIZZ = 105,
  TE_MODEL = 106,
  TE_EXPLODEMODEL = 107,
  TE_BREAKMODEL = 108,
  TE_GUNSHOTDECAL = 109,
  TE_SPRITE_SPRAY = 110,
  TE_ARMOR_RICOCHET = 111,
  TE_PLAYERDECAL = 112,
  TE_BUBBLES = 113,
  TE_BUBBLETRAIL = 114,
  TE_BLOODSPRITE = 115,
  TE_WORLDDECAL = 116,
  TE_WORLDDECALHIGH = 117,
  TE_DECALHIGH = 118,
  TE_PROJECTILE = 119,
  TE_SPRAY = 120,
  TE_PLAYERSPRITES = 121,
  TE_PARTICLEBURST = 122,
  TE_FIREFIELD = 123,
  TE_PLAYERATTACHMENT = 124,
  TE_KILLPLAYERATTACHMENTS = 125,
  TE_MULTIGUNSHOT = 126,
  TE_USERTRACER = 127
};
enum teexpflag_t : int32_t
{
  TE_EXPLFLAG_NONE = 0,
  TE_EXPLFLAG_NOADDITIVE = 1,
  TE_EXPLFLAG_NODLIGHTS = 2,
  TE_EXPLFLAG_NOSOUND = 4,
  TE_EXPLFLAG_NOPARTICLES = 8
};
enum tefireflag_t : int32_t
{
  TEFIRE_FLAG_ALLFLOAT = 1,
  TEFIRE_FLAG_SOMEFLOAT = 2,
  TEFIRE_FLAG_LOOP = 4,
  TEFIRE_FLAG_ALPHA = 8,
  TEFIRE_FLAG_PLANAR = 16
};
enum msg_t : int32_t
{
  MSG_BROADCAST = 0,
  MSG_ONE = 1,
  MSG_ALL = 2,
  MSG_INIT = 3,
  MSG_PVS = 4,
  MSG_PAS = 5,
  MSG_PVS_R = 6,
  MSG_PAS_R = 7,
  MSG_ONE_UNRELIABLE = 8
};
enum contents_t : int32_t
{
  CONTENTS_EMPTY = -1,
  CONTENTS_SOLID = -2,
  CONTENTS_WATER = -3,
  CONTENTS_SLIME = -4,
  CONTENTS_LAVA = -5,
  CONTENTS_SKY = -6,
  CONTENTS_ORIGIN = -7,
  CONTENTS_CLIP = -8,
  CONTENTS_CURRENT_0 = -9,
  CONTENTS_CURRENT_90 = -10,
  CONTENTS_CURRENT_180 = -11,
  CONTENTS_CURRENT_270 = -12,
  CONTENTS_CURRENT_UP = -13,
  CONTENTS_CURRENT_DOWN = -14,
  CONTENTS_TRANSLUCENT = -15,
  CONTENTS_LADDER = -16
};
enum channel_t : int32_t
{
  CHAN_AUTO = 0,
  CHAN_WEAPON = 1,
  CHAN_VOICE = 2,
  CHAN_ITEM = 3,
  CHAN_BODY = 4,
  CHAN_STREAM = 5,
  CHAN_STATIC = 6
};
enum tebounce_t : int32_t
{
  TE_BOUNCE_NULL = 0,
  TE_BOUNCE_SHELL = 1,
  TE_BOUNCE_SHOTSHELL = 2
};
enum fcvar_t : int32_t
{
  FCVAR_ARCHIVE = (1<<0),
  FCVAR_USERINFO = (1<<1),
  FCVAR_SERVER = (1<<2),
  FCVAR_EXTDLL = (1<<3),
  FCVAR_CLIENTDLL = (1<<4),
  FCVAR_PROTECTED = (1<<5),
  FCVAR_SPONLY = (1<<6),
  FCVAR_PRINTABLEONLY = (1<<7),
  FCVAR_UNLOGGED = (1<<8)
};
enum fev_t : int32_t
{
  FEV_NOTHOST = (1<<0),
  FEV_RELIABLE = (1<<1),
  FEV_GLOBAL = (1<<2),
  FEV_UPDATE = (1<<3),
  FEV_HOSTONLY = (1<<4),
  FEV_SERVER = (1<<5),
  FEV_CLIENT = (1<<6)
};
enum inbutton_t : int32_t
{
  IN_ATTACK = (1 << 0),
  IN_JUMP = (1 << 1),
  IN_DUCK = (1 << 2),
  IN_FORWARD = (1 << 3),
  IN_BACK = (1 << 4),
  IN_USE = (1 << 5),
  IN_CANCEL = (1 << 6),
  IN_LEFT = (1 << 7),
  IN_RIGHT = (1 << 8),
  IN_MOVELEFT = (1 << 9),
  IN_MOVERIGHT = (1 << 10),
  IN_ATTACK2 = (1 << 11),
  IN_RUN = (1 << 12),
  IN_RELOAD = (1 << 13),
  IN_ALT1 = (1 << 14),
  IN_SCORE = (1 << 15)
};
enum ftent_t : int32_t
{
  FTENT_NONE = 0x00000000,
  FTENT_SINEWAVE = 0x00000001,
  FTENT_GRAVITY = 0x00000002,
  FTENT_ROTATE = 0x00000004,
  FTENT_SLOWGRAVITY = 0x00000008,
  FTENT_SMOKETRAIL = 0x00000010,
  FTENT_COLLIDEWORLD = 0x00000020,
  FTENT_FLICKER = 0x00000040,
  FTENT_FADEOUT = 0x00000080,
  FTENT_SPRANIMATE = 0x00000100,
  FTENT_HITSOUND = 0x00000200,
  FTENT_SPIRAL = 0x00000400,
  FTENT_SPRCYCLE = 0x00000800,
  FTENT_COLLIDEALL = 0x00001000,
  FTENT_PERSIST = 0x00002000,
  FTENT_COLLIDEKILL = 0x00004000,
  FTENT_PLYRATTACHMENT = 0x00008000,
  FTENT_SPRANIMATELOOP = 0x00010000,
  FTENT_SPARKSHOWER = 0x00020000,
  FTENT_NOMODEL = 0x00040000,
  FTENT_CLIENTCUSTOM = 0x00080000
};
enum fcap_t : uint32_t
{
  FCAP_CUSTOMSAVE = 0x00000001,
  FCAP_ACROSS_TRANSITION = 0x00000002,
  FCAP_MUST_SPAWN = 0x00000004,
  FCAP_DONT_SAVE = 0x80000000,
  FCAP_IMPULSE_USE = 0x00000008,
  FCAP_CONTINUOUS_USE = 0x00000010,
  FCAP_ONOFF_USE = 0x00000020,
  FCAP_DIRECTIONAL_USE = 0x00000040,
  FCAP_MASTER = 0x00000080,
  FCAP_FORCE_TRANSITION = 0x00000080
};
enum bloodcolor_t : int32_t
{
  DONT_BLEED = -1,
  BLOOD_COLOR_RED = (BYTE)247,
  BLOOD_COLOR_YELLOW = (BYTE)195,
  BLOOD_COLOR_GREEN = bloodcolor_t::BLOOD_COLOR_YELLOW
};
enum class_t : int32_t
{
  CLASS_NONE = 0,
  CLASS_MACHINE = 1,
  CLASS_PLAYER = 2,
  CLASS_HUMAN_PASSIVE = 3,
  CLASS_HUMAN_MILITARY = 4,
  CLASS_ALIEN_MILITARY = 5,
  CLASS_ALIEN_PASSIVE = 6,
  CLASS_ALIEN_MONSTER = 7,
  CLASS_ALIEN_PREY = 8,
  CLASS_ALIEN_PREDATOR = 9,
  CLASS_INSECT = 10,
  CLASS_PLAYER_ALLY = 11,
  CLASS_PLAYER_BIOWEAPON = 12,
  CLASS_ALIEN_BIOWEAPON = 13,
  CLASS_BARNACLE = 99
};
enum bitscap_t : int32_t
{
  bits_CAP_DUCK = ( 1 << 0 ),
  bits_CAP_JUMP = ( 1 << 1 ),
  bits_CAP_STRAFE = ( 1 << 2 ),
  bits_CAP_SQUAD = ( 1 << 3 ),
  bits_CAP_SWIM = ( 1 << 4 ),
  bits_CAP_CLIMB = ( 1 << 5 ),
  bits_CAP_USE = ( 1 << 6 ),
  bits_CAP_HEAR = ( 1 << 7 ),
  bits_CAP_AUTO_DOORS = ( 1 << 8 ),
  bits_CAP_OPEN_DOORS = ( 1 << 9 ),
  bits_CAP_TURN_HEAD = ( 1 << 10),
  bits_CAP_RANGE_ATTACK1 = ( 1 << 11),
  bits_CAP_RANGE_ATTACK2 = ( 1 << 12),
  bits_CAP_MELEE_ATTACK1 = ( 1 << 13),
  bits_CAP_MELEE_ATTACK2 = ( 1 << 14),
  bits_CAP_FLY = ( 1 << 15)
};
enum gib_t : int32_t
{
  GIB_NORMAL = 0,
  GIB_NEVER = 1,
  GIB_ALWAYS = 2
};
enum hidehud_t : int32_t
{
  HIDEHUD_WEAPONS = ( 1<<0 ),
  HIDEHUD_FLASHLIGHT = ( 1<<1 ),
  HIDEHUD_ALL = ( 1<<2 ),
  HIDEHUD_HEALTH = ( 1<<3 )
};
enum hudprint_t : int32_t
{
  HUD_PRINTNOTIFY = 1,
  HUD_PRINTCONSOLE = 2,
  HUD_PRINTTALK = 3,
  HUD_PRINTCENTER = 4
};
enum localmove_t : int32_t
{
  LOCALMOVE_INVALID = 0,
  LOCALMOVE_INVALID_DONT_TRIANGULATE = 1,
  LOCALMOVE_VALID = 2
};
enum hitgroup_t : int32_t
{
  HITGROUP_GENERIC = 0,
  HITGROUP_HEAD = 1,
  HITGROUP_CHEST = 2,
  HITGROUP_STOMACH = 3,
  HITGROUP_LEFTARM = 4,
  HITGROUP_RIGHTARM = 5,
  HITGROUP_LEFTLEG = 6,
  HITGROUP_RIGHTLEG = 7
};
enum disposition_t : int32_t
{
  R_AL = -2,
  R_FR = -1,
  R_NO = 0,
  R_DL = 1,
  R_HT = 2,
  R_NM = 3
};
enum bitsmemory_t : int32_t
{
  MEMORY_CLEAR = 0,
  bits_MEMORY_PROVOKED = ( 1 << 0 ),
  bits_MEMORY_INCOVER = ( 1 << 1 ),
  bits_MEMORY_SUSPICIOUS = ( 1 << 2 ),
  bits_MEMORY_PATH_FINISHED = ( 1 << 3 ),
  bits_MEMORY_ON_PATH = ( 1 << 4 ),
  bits_MEMORY_MOVE_FAILED = ( 1 << 5 ),
  bits_MEMORY_FLINCHED = ( 1 << 6 ),
  bits_MEMORY_KILLED = ( 1 << 7 ),
  bits_MEMORY_CUSTOM4 = ( 1 << 28 ),
  bits_MEMORY_CUSTOM3 = ( 1 << 29 ),
  bits_MEMORY_CUSTOM2 = ( 1 << 30 ),
  bits_MEMORY_CUSTOM1 = ( 1 << 31 )
};
enum taskstatus_t : int32_t
{
  TASKSTATUS_NEW = 0,
  TASKSTATUS_RUNNING = 1,
  TASKSTATUS_RUNNING_MOVEMENT = 2,
  TASKSTATUS_RUNNING_TASK = 3,
  TASKSTATUS_COMPLETE = 4
};
enum bitsmf_t : int32_t
{
  bits_MF_TO_TARGETENT = ( 1 << 0 ),
  bits_MF_TO_ENEMY = ( 1 << 1 ),
  bits_MF_TO_COVER = ( 1 << 2 ),
  bits_MF_TO_DETOUR = ( 1 << 3 ),
  bits_MF_TO_PATHCORNER = ( 1 << 4 ),
  bits_MF_TO_NODE = ( 1 << 5 ),
  bits_MF_TO_LOCATION = ( 1 << 6 ),
  bits_MF_IS_GOAL = ( 1 << 7 ),
  bits_MF_DONT_SIMPLIFY = ( 1 << 8 )
};
enum movegoal_t : int32_t
{
  MOVEGOAL_NONE = (0),
  MOVEGOAL_TARGETENT = (bitsmf_t::bits_MF_TO_TARGETENT),
  MOVEGOAL_ENEMY = (bitsmf_t::bits_MF_TO_ENEMY),
  MOVEGOAL_PATHCORNER = (bitsmf_t::bits_MF_TO_PATHCORNER),
  MOVEGOAL_LOCATION = (bitsmf_t::bits_MF_TO_LOCATION),
  MOVEGOAL_NODE = (bitsmf_t::bits_MF_TO_NODE),
};
enum bitscond_t : int32_t
{
  bits_COND_NO_AMMO_LOADED = ( 1 << 0 ),
  bits_COND_SEE_HATE = ( 1 << 1 ),
  bits_COND_SEE_FEAR = ( 1 << 2 ),
  bits_COND_SEE_DISLIKE = ( 1 << 3 ),
  bits_COND_SEE_ENEMY = ( 1 << 4 ),
  bits_COND_ENEMY_OCCLUDED = ( 1 << 5 ),
  bits_COND_SMELL_FOOD = ( 1 << 6 ),
  bits_COND_ENEMY_TOOFAR = ( 1 << 7 ),
  bits_COND_LIGHT_DAMAGE = ( 1 << 8 ),
  bits_COND_HEAVY_DAMAGE = ( 1 << 9 ),
  bits_COND_CAN_RANGE_ATTACK1 = ( 1 << 10),
  bits_COND_CAN_MELEE_ATTACK1 = ( 1 << 11),
  bits_COND_CAN_RANGE_ATTACK2 = ( 1 << 12),
  bits_COND_CAN_MELEE_ATTACK2 = ( 1 << 13),
  bits_COND_PROVOKED = ( 1 << 15),
  bits_COND_NEW_ENEMY = ( 1 << 16),
  bits_COND_HEAR_SOUND = ( 1 << 17),
  bits_COND_SMELL = ( 1 << 18),
  bits_COND_ENEMY_FACING_ME = ( 1 << 19),
  bits_COND_ENEMY_DEAD = ( 1 << 20),
  bits_COND_SEE_CLIENT = ( 1 << 21),
  bits_COND_SEE_NEMESIS = ( 1 << 22),
  bits_COND_SPECIAL1 = ( 1 << 28),
  bits_COND_SPECIAL2 = ( 1 << 29),
  bits_COND_TASK_FAILED = ( 1 << 30),
  bits_COND_SCHEDULE_DONE = ( 1 << 31)
};
enum aitrigger_t : int32_t
{
	AITRIGGER_NONE = 0,
	AITRIGGER_SEEPLAYER_ANGRY_AT_PLAYER,
	AITRIGGER_TAKEDAMAGE,
	AITRIGGER_HALFHEALTH,
	AITRIGGER_DEATH,
	AITRIGGER_SQUADMEMBERDIE,
	AITRIGGER_SQUADLEADERDIE,
	AITRIGGER_HEARWORLD,
	AITRIGGER_HEARPLAYER,
	AITRIGGER_HEARCOMBAT,
	AITRIGGER_SEEPLAYER_UNCONDITIONAL,
	AITRIGGER_SEEPLAYER_NOT_IN_COMBAT,
};
enum skill_t : int32_t
{
  SKILL_EASY = 1,
  SKILL_MEDIUM = 2,
  SKILL_HARD = 3
};
enum bitssound_t : int32_t
{
  bits_SOUND_NONE =  0,
  bits_SOUND_COMBAT = ( 1 << 0 ),
  bits_SOUND_WORLD = ( 1 << 1 ),
  bits_SOUND_PLAYER = ( 1 << 2 ),
  bits_SOUND_CARCASS = ( 1 << 3 ),
  bits_SOUND_MEAT = ( 1 << 4 ),
  bits_SOUND_DANGER = ( 1 << 5 ),
  bits_SOUND_GARBAGE = ( 1 << 6 )
};
enum weapontype_t : int32_t
{
  WEAPON_NONE = 0,
  WEAPON_CROWBAR = 1,
  WEAPON_GLOCK = 2,
  WEAPON_PYTHON = 3,
  WEAPON_MP5 = 4,
  WEAPON_CHAINGUN = 5,
  WEAPON_CROSSBOW = 6,
  WEAPON_SHOTGUN = 7,
  WEAPON_RPG = 8,
  WEAPON_GAUSS = 9,
  WEAPON_EGON = 10,
  WEAPON_HORNETGUN = 11,
  WEAPON_HANDGRENADE = 12,
  WEAPON_TRIPMINE = 13,
  WEAPON_SATCHEL = 14,
  WEAPON_SNARK = 15,
  WEAPON_SUIT = 31
};
enum beamf_t : int32_t
{
  BEAM_FSINE = 0x10,
  BEAM_FSOLID = 0x20,
  BEAM_FSHADEIN = 0x40,
  BEAM_FSHADEOUT = 0x80
};
enum ffade_t : int32_t
{
  FFADE_IN = 0x0000,
  FFADE_OUT = 0x0001,
  FFADE_MODULATE = 0x0002,
  FFADE_STAYOUT = 0x0004
};
enum Bullet : int32_t
{
	BULLET_NONE = 0,
	BULLET_PLAYER_9MM,
	BULLET_PLAYER_MP5,
	BULLET_PLAYER_357,
	BULLET_PLAYER_BUCKSHOT,
	BULLET_PLAYER_CROWBAR,
	BULLET_MONSTER_9MM,
	BULLET_MONSTER_MP5,
	BULLET_MONSTER_12MM,
};
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);
typedef unsigned long CRC32_t;
typedef struct edict_s edict_t;
typedef struct globalentity_s globalentity_t;
typedef void *cache_user_t;
typedef struct entity_state_s entity_state_t;
typedef struct efx_api_s efx_api_t;
typedef void ( *net_api_response_func_t ) ( struct net_response_s *response );
typedef struct tempent_s	TEMPENTITY;
typedef struct beam_s BEAM;
typedef struct cl_entity_s cl_entity_t;
class CBaseEntity;
class CBaseMonster;
class CSquadMonster; // Undefined in SDK 1.0
class CBasePlayerAmmo;
class CBasePlayerItem;
class CBasePlayerWeapon;
class CBasePlayer;
class CRpg;
class CCineMonster;
// TODO: Binary ninja does not seem to recognize member function pointer definitions.
/*
typedef void (CBaseEntity::*BASEPTR)(void);
typedef void (CBaseEntity::*ENTITYFUNCPTR)(CBaseEntity *pOther );
typedef void (CBaseEntity::*USEPTR)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
*/
typedef void (*BASEPTR)(void);
typedef void (*ENTITYFUNCPTR)(CBaseEntity *pOther );
typedef void (*USEPTR)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;
typedef struct
{
	byte r, g, b;
} color24;
typedef struct
{
	unsigned r, g, b, a;
} colorVec;
class UTIL_GroupTrace __packed
{
public:
	UTIL_GroupTrace( int groupmask, int op );
	~UTIL_GroupTrace( void );
private:
	int m_oldgroupmask, m_oldgroupop;
};
class Vector2D __packed
{
public:
	inline Vector2D(void)									;
	inline Vector2D(float X, float Y)						;
	inline Vector2D operator+(const Vector2D& v)	const	;
	inline Vector2D operator-(const Vector2D& v)	const	;
	inline Vector2D operator*(float fl)				const	;
	inline Vector2D operator/(float fl)				const	;
	inline float Length(void)						const	;
	inline Vector2D Normalize ( void ) const;
	vec_t	x, y;
};
class Vector __packed
{
public:
	inline Vector(void)								;
	inline Vector(float X, float Y, float Z)		;
	inline Vector(double X, double Y, double Z);
	inline Vector(int X, int Y, int Z);
	inline Vector(const Vector& v)					;
	inline Vector(float rgfl[3])					;
	inline Vector operator-(void) const;
	inline int operator==(const Vector& v) const;
	inline int operator!=(const Vector& v) const;
	inline Vector operator+(const Vector& v) const;
	inline Vector operator-(const Vector& v) const;
	inline Vector operator*(float fl) const;
	inline Vector operator/(float fl) const;
	inline void CopyToArray(float* rgfl) const;
	inline float Length(void) const;
	operator float *();
	operator const float *() const;
	inline Vector Normalize(void) const;
	inline Vector2D Make2D ( void ) const;
	inline float Length2D(void) const;
	vec_t x, y, z;
};
class CPlane __packed
{
public:
	CPlane ( void );
	void InitializePlane ( const Vector &vecNormal, const Vector &vecPoint );
	BOOL PointInFront ( const Vector &vecPoint );
	Vector	m_vecNormal;
	float	m_flDist;
	BOOL	m_fInitialized;
};
class CStack __packed
{
public:
			CStack( void );
	void	Push( int value );
	int		Pop( void );
	int		Top( void );
	int		Empty( void );
	int		Size( void );
	void    CopyToArray ( int *piArray );
private:
	int		m_stack[ MAX_STACK_NODES ];
	int		m_level;
};
class CQueue __packed
{
public:
	CQueue( void );
	inline int Full ( void );
	inline int Empty ( void );
	inline int Size ( void );
	void Insert( int, float );
	int Remove( float & );
private:
	int	m_cSize;
    struct tag_QUEUE_NODE
    {
        int   Id;
        float Priority;
    } m_queue[ MAX_STACK_NODES ];
	int m_head;
	int m_tail;
};
class CQueuePriority __packed
{
public:
	CQueuePriority( void );
	inline int Full ( void );
	inline int Empty ( void );
	inline int Size ( void );
	void Insert( int, float );
	int Remove( float &);
private:
	int	m_cSize;
    struct tag_HEAP_NODE
    {
        int   Id;
        float Priority;
    } m_heap[ MAX_STACK_NODES ];
	void Heap_SiftDown(int);
	void Heap_SiftUp(void);
};
typedef struct
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;
typedef struct rect_s
{
	int				left, right, top, bottom;
} wrect_t;
struct WEAPON
{
	char	szName[MAX_WEAPON_NAME];
	int		iAmmoType;
	int		iAmmo2Type;
	int		iMax1;
	int		iMax2;
	int		iSlot;
	int		iSlotPos;
	int		iFlags;
	int		iId;
	int		iClip;
	int		iCount;
	HSPRITE hActive;
	wrect_t rcActive;
	HSPRITE hInactive;
	wrect_t rcInactive;
	HSPRITE	hAmmo;
	wrect_t rcAmmo;
	HSPRITE hAmmo2;
	wrect_t rcAmmo2;
	HSPRITE hCrosshair;
	wrect_t rcCrosshair;
	HSPRITE hAutoaim;
	wrect_t rcAutoaim;
	HSPRITE hZoomedCrosshair;
	wrect_t rcZoomedCrosshair;
	HSPRITE hZoomedAutoaim;
	wrect_t rcZoomedAutoaim;
};
class WeaponsResource __packed
{
private:
	WEAPON		rgWeapons[MAX_WEAPONS];
	WEAPON*		rgSlots[MAX_WEAPON_SLOTS+1][MAX_WEAPON_POSITIONS+1];
	int			riAmmo[MAX_AMMO_TYPES];
public:
	void Init( void );
	void Reset( void );
	int			iOldWeaponBits;
	WEAPON *GetWeapon( int iId );
	void AddWeapon( WEAPON *wp );
	void PickupWeapon( WEAPON *wp );
	void DropWeapon( WEAPON *wp );
	void DropAllWeapons( void );
	WEAPON* GetWeaponSlot( int slot, int pos ) ;
	void LoadWeaponSprites( WEAPON* wp );
	void LoadAllWeaponSprites( void );
	WEAPON* GetFirstPos( int iSlot );
	void SelectSlot( int iSlot, int fAdvance, int iDirection );
	WEAPON* GetNextActivePos( int iSlot, int iSlotPos );
	int HasAmmo( WEAPON *p );
	AMMO GetAmmo( int iId ) ;
	void SetAmmo( int iId, int iCount ) ;
	int CountAmmo( int iId );
	HSPRITE* GetAmmoPicFromWeapon( int iAmmoId, wrect_t& rect );
};
class HistoryResource __packed
{
private:
	struct HIST_ITEM {
		int type;
		float DisplayTime;
		int iCount;
		int iId;
	};
	HIST_ITEM rgAmmoHistory[MAX_HISTORY];
public:
	void Init( void );
	void Reset( void );
	int iHistoryGap;
	int iCurrentHistorySlot;
	void AddToHistory( int iType, int iId, int iCount = 0 );
	void AddToHistory( int iType, const char *szName, int iCount = 0 );
	void CheckClearHistory( void );
	int DrawAmmoHistory( float flTime );
};
typedef struct {
	int x, y;
} POSITION;
typedef struct {
	unsigned char r,g,b,a;
} RGBA;
struct __data_var_refs vtable_for_CHudBase
{
	int (*Init)( class CHudBase* p ) ;
	int (*VidInit)( class CHudBase* p ) ;
	int (*Draw)(class CHudBase* p, float flTime) ;
	void (*Think)(class CHudBase* p) ;
	void (*Reset)(class CHudBase* p) ;
	void (*InitHUDData)( class CHudBase* p ) ;
};
class CHudBase __packed
{
  struct vtable_for_CHudBase* vtable;
public:
	POSITION  m_pos;
	int   m_type;
	hudflags_t	  m_iFlags;
};
struct HUDLIST {
	CHudBase	*p;
	HUDLIST		*pNext;
};
typedef struct
{
	float fExpire;
	float fBaseline;
	int	x, y;
} DAMAGE_IMAGE;
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudHealth
{
 	int (*Init)( class CHudHealth* p );
	int (*VidInit)( class CHudHealth* p );
	int (*Draw)(class CHudHealth* p, float fTime);
	void (*Reset)( class CHudHealth* p );
};
class __base(CHudBase, 0) CHudHealth __packed
{
  struct vtable_for_CHudHealth* vtable;
public:
	int MsgFunc_Health(const char *pszName,  int iSize, void *pbuf);
	int MsgFunc_Damage(const char *pszName,  int iSize, void *pbuf);
	int m_iHealth;
	int m_HUD_dmg_bio;
	int m_HUD_cross;
	float m_fAttackFront, m_fAttackRear, m_fAttackLeft, m_fAttackRight;
	void GetPainColor( int &r, int &g, int &b );
	float m_fFade;
private:
	HSPRITE m_hSprite;
	HSPRITE m_hDamage;
	DAMAGE_IMAGE m_dmg[NUM_DMG_TYPES];
	int	m_bitsDamage;
	int DrawPain(float fTime);
	int DrawDamage(float fTime);
	void CalcDamageDirection(vec3_t vecFrom);
	void UpdateTiles(float fTime, long bits);
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudAmmo
{
};
class __base(CHudBase, 0) CHudAmmo __packed
{
  struct vtable_for_CHudAmmo* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Think(void);
	void Reset(void);
	int DrawWList(float flTime);
	int MsgFunc_CurWeapon(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_WeaponList(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_AmmoX(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_AmmoPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_WeapPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_ItemPickup( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_HideWeapon( const char *pszName, int iSize, void *pbuf );
	void SlotInput( int iSlot );
	void _cdecl UserCmd_Slot1( void );
	void _cdecl UserCmd_Slot2( void );
	void _cdecl UserCmd_Slot3( void );
	void _cdecl UserCmd_Slot4( void );
	void _cdecl UserCmd_Slot5( void );
	void _cdecl UserCmd_Slot6( void );
	void _cdecl UserCmd_Slot7( void );
	void _cdecl UserCmd_Slot8( void );
	void _cdecl UserCmd_Slot9( void );
	void _cdecl UserCmd_Slot10( void );
	void _cdecl UserCmd_Close( void );
	void _cdecl UserCmd_NextWeapon( void );
	void _cdecl UserCmd_PrevWeapon( void );
private:
	float m_fFade;
	RGBA  m_rgba;
	WEAPON *m_pWeapon;
	int	m_HUD_bucket0;
	int m_HUD_selection;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudAmmoSecondary
{
};
class __base(CHudBase, 0) CHudAmmoSecondary __packed
{
  struct vtable_for_CHudAmmoSecondary* vtable;
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	int MsgFunc_SecAmmoVal( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_SecAmmoIcon( const char *pszName, int iSize, void *pbuf );
private:
	enum {
		MAX_SEC_AMMO_VALUES = 4
	};
	int m_HUD_ammoicon;
	int m_iAmmoAmounts[MAX_SEC_AMMO_VALUES];
	float m_fFade;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudGeiger
{
};
class __base(CHudBase, 0) CHudGeiger __packed
{
  struct vtable_for_CHudGeiger* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Geiger(const char *pszName, int iSize, void *pbuf);
private:
	int m_iGeigerRange;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudTrain
{
};
class __base(CHudBase, 0) CHudTrain __packed
{
  struct vtable_for_CHudTrain* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Train(const char *pszName, int iSize, void *pbuf);
private:
	HSPRITE m_hSprite;
	int m_iPos;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMOTD
{
};
class __base(CHudBase, 0) CHudMOTD __packed
{
  struct vtable_for_CHudMOTD* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	int MsgFunc_MOTD( const char *pszName, int iSize, void *pbuf );
protected:
	static int MOTD_DISPLAY_TIME;
	char m_szMOTD[ MAX_MOTD_LENGTH ];
	float m_flActiveRemaining;
	int m_iLines;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudStatusBar
{
};
class __base(CHudBase, 0) CHudStatusBar __packed
{
  struct vtable_for_CHudStatusBar* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw( float flTime );
	void Reset( void );
	void ParseStatusString( int line_num );
	int MsgFunc_StatusText( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_StatusValue( const char *pszName, int iSize, void *pbuf );
protected:
	enum {
		MAX_STATUSTEXT_LENGTH = 128,
		MAX_STATUSBAR_VALUES = 8,
		MAX_STATUSBAR_LINES = 2,
	};
	char m_szStatusText[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];
	char m_szStatusBar[MAX_STATUSBAR_LINES][MAX_STATUSTEXT_LENGTH];
	int m_iStatusValues[MAX_STATUSBAR_VALUES];
	int m_bReparseString;
};
typedef struct
{
	char *name;
	short ping;
	byte thisplayer;
	byte spectator;
	byte packetloss;
	char *model;
	short topcolor;
	short bottomcolor;
} hud_player_info_t;
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudScoreboard
{
};
class __base(CHudBase, 0) CHudScoreboard __packed
{
  struct vtable_for_CHudScoreboard* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int DrawPlayers( int xoffset, float listslot, int nameoffset = 0, char *team = NULL );
	void UserCmd_ShowScores( void );
	void UserCmd_HideScores( void );
	int MsgFunc_ScoreInfo( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_TeamInfo( const char *pszName, int iSize, void *pbuf );
	int MsgFunc_TeamScore( const char *pszName, int iSize, void *pbuf );
	void DeathMsg( int killer, int victim );
	int m_iNumTeams;
	int m_iLastKilledBy;
	int m_fLastKillTime;
	int m_iPlayerNum;
	int m_iShowscoresHeld;
	void GetAllPlayersInfo( void );
private:
	struct cvar_s *cl_showpacketloss;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudDeathNotice
{
};
class __base(CHudBase, 0) CHudDeathNotice __packed
{
  struct vtable_for_CHudDeathNotice* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int MsgFunc_DeathMsg( const char *pszName, int iSize, void *pbuf );
private:
	int m_HUD_d_skull;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMenu
{
};
class __base(CHudBase, 0) CHudMenu __packed
{
  struct vtable_for_CHudMenu* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	void Reset( void );
	int Draw( float flTime );
	int MsgFunc_ShowMenu( const char *pszName, int iSize, void *pbuf );
	void SelectMenuItem( int menu_item );
	int m_fMenuDisplayed;
	int m_bitsValidSlots;
	float m_flShutoffTime;
	int m_fWaitingForMore;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudSayText
{
};
class __base(CHudBase, 0) CHudSayText __packed
{
  struct vtable_for_CHudSayText* vtable;
public:
	int Init( void );
	void InitHUDData( void );
	int VidInit( void );
	int Draw( float flTime );
	int MsgFunc_SayText( const char *pszName, int iSize, void *pbuf );
	void SayTextPrint( const char *pszBuf, int iBufSize, int clientIndex = -1 );
	void EnsureTextFitsInOneLineAndWrapIfHaveTo( int line );
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudBattery
{
};
class __base(CHudBase, 0) CHudBattery __packed
{
  struct vtable_for_CHudBattery* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_Battery(const char *pszName,  int iSize, void *pbuf );
private:
	HSPRITE m_hSprite1;
	HSPRITE m_hSprite2;
	wrect_t *m_prc1;
	wrect_t *m_prc2;
	int	  m_iBat;
	float m_fFade;
	int	  m_iHeight;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudFlashlight
{
};
class __base(CHudBase, 0) CHudFlashlight __packed
{
  struct vtable_for_CHudFlashlight* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	void Reset( void );
	int MsgFunc_Flashlight(const char *pszName,  int iSize, void *pbuf );
	int MsgFunc_FlashBat(const char *pszName,  int iSize, void *pbuf );
private:
	HSPRITE m_hSprite1;
	HSPRITE m_hSprite2;
	HSPRITE m_hBeam;
	wrect_t *m_prc1;
	wrect_t *m_prc2;
	wrect_t *m_prcBeam;
	float m_flBat;
	int	  m_iBat;
	int	  m_fOn;
	float m_fFade;
	int	  m_iWidth;
};
typedef struct
{
	int		effect;
	byte	r1, g1, b1, a1;
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;
const int maxHUDMessages = 16;
struct message_parms_t
{
	client_textmessage_t	*pMessage;
	float	time;
	int x, y;
	int	totalWidth, totalHeight;
	int width;
	int lines;
	int lineLength;
	int length;
	int r, g, b;
	int text;
	int fadeBlend;
	float charTime;
	float fadeTime;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudTextMessage
{
};
class __base(CHudBase, 0) CHudTextMessage __packed
{
  struct vtable_for_CHudTextMessage* vtable;
public:
	int Init( void );
	static char *LocaliseTextString( const char *msg, char *dst_buffer, int buffer_size );
	static char *BufferedLocaliseTextString( const char *msg );
	char *LookupString( const char *msg_name, int *msg_dest = NULL );
	int MsgFunc_TextMsg(const char *pszName, int iSize, void *pbuf);
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudMessage
{
};
class __base(CHudBase, 0) CHudMessage __packed
{
  struct vtable_for_CHudMessage* vtable;
public:
	int Init( void );
	int VidInit( void );
	int Draw(float flTime);
	int MsgFunc_HudText(const char *pszName, int iSize, void *pbuf);
	int MsgFunc_GameTitle(const char *pszName, int iSize, void *pbuf);
	float FadeBlend( float fadein, float fadeout, float hold, float localTime );
	int	XPosition( float x, int width, int lineWidth );
	int YPosition( float y, int height );
	void MessageAdd( const char *pName, float time );
	void MessageDrawScan( client_textmessage_t *pMessage, float time );
	void MessageScanStart( void );
	void MessageScanNextChar( void );
	void Reset( void );
private:
	client_textmessage_t		*m_pMessages[maxHUDMessages];
	float						m_startTime[maxHUDMessages];
	message_parms_t				m_parms;
	float						m_gameTitleTime;
	client_textmessage_t		*m_pGameTitle;
	int m_HUD_title_life;
	int m_HUD_title_half;
};
struct __base(vtable_for_CHudBase, 0) __data_var_refs vtable_for_CHudStatusIcons
{
};
class __base(CHudBase, 0) CHudStatusIcons __packed
{
  struct vtable_for_CHudStatusIcons* vtable;
public:
	int Init( void );
	int VidInit( void );
	void Reset( void );
	int Draw(float flTime);
	int MsgFunc_StatusIcon(const char *pszName, int iSize, void *pbuf);
	enum {
		MAX_ICONSPRITENAME_LENGTH = MAX_SPRITE_NAME_LENGTH,
		MAX_ICONSPRITES = 4,
	};
	void EnableIcon( char *pszIconName, unsigned char red, unsigned char green, unsigned char blue );
	void DisableIcon( char *pszIconName );
private:
	typedef struct
	{
		char szSpriteName[MAX_ICONSPRITENAME_LENGTH];
		HSPRITE spr;
		wrect_t rc;
		unsigned char r, g, b;
	} icon_sprite_t;
	icon_sprite_t m_IconList[MAX_ICONSPRITES];
};
typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX
} netadrtype_t;
typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;
typedef struct net_adrlist_s
{
	struct net_adrlist_s	*next;
	netadr_t				remote_address;
} net_adrlist_t;
typedef struct net_response_s
{
	int			error;
	int			context;
	int			type;
	netadr_t	remote_address;
	double		ping;
	void		*response;
} net_response_t;
typedef struct net_status_s
{
	int			connected;
	netadr_t	local_address;
	netadr_t	remote_address;
	int			packet_loss;
	double		latency;
	double		connection_time;
	double		rate;
} net_status_t;
class CHudServers
{
public:
	typedef struct request_s
	{
		struct request_s	*next;
		netadr_t					remote_address;
		int							context;
	} request_t;
	typedef struct server_s
	{
		struct server_s	*next;
		netadr_t				remote_address;
		char					*info;
		int						ping;
	} server_t;
	CHudServers();
	~CHudServers();
	void	Think( double time );
	void	QueryThink( void );
	int		isQuerying( void );
	int		LoadMasterAddresses( int maxservers, int *count, netadr_t *padr );
	void	RequestList( void );
	void	RequestBroadcastList( int clearpending );
	void	ServerPing( int server );
	void	ServerRules( int server );
	void	ServerPlayers( int server );
	void	CancelRequest( void );
	int		CompareServers( server_t *p1, server_t *p2 );
	void	ClearServerList( server_t **ppList );
	void	ClearRequestList( request_t **ppList );
	void	AddServer( server_t **ppList, server_t *p );
	void	RemoveServerFromList( request_t **ppList, request_t *item );
	request_t *FindRequest( int context, request_t *pList );
	int		ServerListSize( void );
	char	*GetServerInfo( int server );
	int		GetServerCount( void );
	void	SortServers( const char *fieldname );
	void	ListResponse( struct net_response_s *response );
	void	ServerResponse( struct net_response_s *response );
	void	PingResponse( struct net_response_s *response );
	void	RulesResponse( struct net_response_s *response );
	void	PlayersResponse( struct net_response_s *response );
private:
	server_t *GetServer( int server );
	char				m_szToken[ 1024 ];
	int					m_nRequesting;
	int					m_nDone;
	double				m_dStarted;
	request_t	*m_pServerList;
	request_t	*m_pActiveList;
	server_t		*m_pServers;
	int					m_nServerCount;
	int					m_nActiveQueries;
	int					m_nQuerying;
	double				m_fElapsed;
	request_t			*m_pPingRequest;
	request_t			*m_pRulesRequest;
	request_t			*m_pPlayersRequest;
};
typedef struct client_data_s
{
	vec3_t origin;
	vec3_t viewangles;
	int		iWeaponBits;
	float	fov;
} client_data_t;
typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;
typedef struct cvar_s
{
	char	*name;
	char	*string;
	fcvar_t		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;
class CHud __packed
{
private:
	HUDLIST						*m_pHudList;
	HSPRITE						m_hsprLogo;
	int							m_iLogo;
	client_sprite_t				*m_pSpriteList;
	int							m_iSpriteCount;
	int							m_iSpriteCountAllRes;
	float						m_flMouseSensitivity;
	int							m_iConcussionEffect;
public:
	HSPRITE						m_hsprCursor;
	float m_flTime;
	float m_fOldTime;
	double m_flTimeDelta;
	Vector	m_vecOrigin;
	Vector	m_vecAngles;
	int		m_iKeyBits;
	hidehud_t		m_iHideHUDDisplay;
	int		m_iFOV;
	int		m_Teamplay;
	int		m_iRes;
	cvar_t  *m_pCvarStealMouse;
	int m_iFontHeight;
	int DrawHudNumber(int x, int y, int iFlags, int iNumber, int r, int g, int b );
	int DrawHudString(int x, int y, int iMaxX, char *szString, int r, int g, int b );
	int DrawHudStringReverse( int xpos, int ypos, int iMinX, char *szString, int r, int g, int b );
	int DrawHudNumberString( int xpos, int ypos, int iMinX, int iNumber, int r, int g, int b );
	int GetNumWidth(int iNumber, int iFlags);
private:
	HSPRITE *m_rghSprites;
	wrect_t *m_rgrcRects;
	char *m_rgszSpriteNames;
	struct cvar_s *default_fov;
public:
	HSPRITE GetSprite( int index );
	wrect_t& GetSpriteRect( int index );
	int GetSpriteIndex( const char *SpriteName );
	CHudAmmo	m_Ammo;
	CHudHealth	m_Health;
	CHudGeiger	m_Geiger;
	CHudBattery	m_Battery;
	CHudTrain	m_Train;
	CHudFlashlight m_Flash;
	CHudMessage m_Message;
	CHudStatusBar    m_StatusBar;
	CHudDeathNotice m_DeathNotice;
	CHudSayText m_SayText;
	CHudMenu	m_Menu;
	CHudAmmoSecondary	m_AmmoSecondary;
	CHudTextMessage m_TextMessage;
	CHudStatusIcons m_StatusIcons;
	void Init( void );
	void VidInit( void );
	void Think(void);
	int Redraw( float flTime, int intermission );
	int UpdateClientData( client_data_t *cdata, float time );
	CHud();
	~CHud();
	int _cdecl MsgFunc_Damage(const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_GameMode(const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_Logo(const char *pszName,  int iSize, void *pbuf);
	int _cdecl MsgFunc_ResetHUD(const char *pszName,  int iSize, void *pbuf);
	void _cdecl MsgFunc_InitHUD( const char *pszName, int iSize, void *pbuf );
	int _cdecl MsgFunc_SetFOV(const char *pszName,  int iSize, void *pbuf);
	int  _cdecl MsgFunc_Concuss( const char *pszName, int iSize, void *pbuf );
	SCREENINFO	m_scrinfo;
	weapontype_t	m_iWeaponBits;
	int	m_fPlayerDead;
	int m_iIntermission;
	int m_HUD_number_0;
	void AddHudElem(CHudBase *p);
	float GetSensitivity();
};
typedef struct
{
	int					id;
	int					version;
	char				name[64];
	int					length;
	vec3_t				eyeposition;
	vec3_t				min;
	vec3_t				max;
	vec3_t				bbmin;
	vec3_t				bbmax;
	int					flags;
	int					numbones;
	int					boneindex;
	int					numbonecontrollers;
	int					bonecontrollerindex;
	int					numhitboxes;
	int					hitboxindex;
	int					numseq;
	int					seqindex;
	int					numseqgroups;
	int					seqgroupindex;
	int					numtextures;
	int					textureindex;
	int					texturedataindex;
	int					numskinref;
	int					numskinfamilies;
	int					skinindex;
	int					numbodyparts;
	int					bodypartindex;
	int					numattachments;
	int					attachmentindex;
	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;
	int					numtransitions;
	int					transitionindex;
} studiohdr_t;
typedef struct
{
	int					id;
	int					version;
	char				name[64];
	int					length;
} studioseqhdr_t;
typedef struct
{
	char				name[32];
	int		 			parent;
	int					flags;
	int					bonecontroller[6];
	float				value[6];
	float				scale[6];
} mstudiobone_t;
typedef struct
{
	int					bone;
	int					type;
	float				start;
	float				end;
	int					rest;
	int					index;
} mstudiobonecontroller_t;
typedef struct
{
	int					bone;
	int					group;
	vec3_t				bbmin;
	vec3_t				bbmax;
} mstudiobbox_t;
typedef struct
{
	char				label[32];
	char				name[64];
	cache_user_t		cache;
	int					data;
} mstudioseqgroup_t;
typedef struct
{
	char				label[32];
	float				fps;
	int					flags;
	int					activity;
	int					actweight;
	int					numevents;
	int					eventindex;
	int					numframes;
	int					numpivots;
	int					pivotindex;
	int					motiontype;
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;
	vec3_t				bbmin;
	vec3_t				bbmax;
	int					numblends;
	int					animindex;
	int					blendtype[2];
	float				blendstart[2];
	float				blendend[2];
	int					blendparent;
	int					seqgroup;
	int					entrynode;
	int					exitnode;
	int					nodeflags;
	int					nextseq;
} mstudioseqdesc_t;
typedef struct
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
typedef struct
{
	vec3_t				org;
	int					start;
	int					end;
} mstudiopivot_t;
typedef struct
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;
	vec3_t				vectors[3];
} mstudioattachment_t;
typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;
typedef union
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex;
} mstudiobodyparts_t;
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;
typedef struct
{
	char				name[64];
	int					type;
	float				boundingradius;
	int					nummesh;
	int					meshindex;
	int					numverts;
	int					vertinfoindex;
	int					vertindex;
	int					numnorms;
	int					norminfoindex;
	int					normindex;
	int					numgroups;
	int					groupindex;
} mstudiomodel_t;
typedef struct
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;
	int					normindex;
} mstudiomesh_t;
typedef struct
{
	short				vertindex;
	short				normindex;
	short				s,t;
} mstudiotrivert_t;
typedef enum {
	pt_static,
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom
} ptype_t;
typedef struct particle_s
{
	vec3_t		org;
	short		color;
	short		packedColor;
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );
	void		(*callback)( struct particle_s *particle, float frametime );
	unsigned char context;
} particle_t;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};
typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;
typedef struct
{
	byte					mouthopen;
	byte					sndcount;
	int						sndavg;
} mouth_t;
typedef struct
{
	float					prevanimtime;
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;
	int						prevsequence;
	float					prevframe;
	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;
typedef struct
{
	float					animtime;
	vec3_t					origin;
	vec3_t					angles;
} position_history_t;
struct entity_state_s
{
	int			entityType;
	int			number;
	float		msg_time;
	int			messagenum;
	vec3_t		origin;
	vec3_t		angles;
	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;
	byte		eflags;
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;
	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;
	vec3_t		mins;
	vec3_t		maxs;
	int			aiment;
	int			owner;
	float		friction;
	float		gravity;
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;
	int         weaponmodel;
	int			gaitsequence;
	vec3_t		basevelocity;
	int			usehull;
	int			oldbuttons;
	int			onground;
	int			iStepLeft;
	float		flFallVelocity;
	float		fov;
	int			weaponanim;
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};
typedef struct
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;
	float	decay;
	float	minlight;
	int		key;
	qboolean	dark;
} dlight_t;
struct cl_entity_s
{
	int						index;
	qboolean				player;
	entity_state_t			baseline;
	entity_state_t			prevstate;
	entity_state_t			curstate;
	int						current_position;
	position_history_t		ph[ HISTORY_MAX ];
	mouth_t					mouth;
	latchedvars_t			latched;
	float					lastmove;
	vec3_t					origin;
	vec3_t					angles;
	vec3_t					attachment[4];
	int						trivial_accept;
	struct model_s			*model;
	struct efrag_s			*efrag;
	struct mnode_s			*topnode;
	float					syncbase;
	int						visframe;
	colorVec				cvFloorColor;
};
typedef enum
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;
typedef struct triangleapi_s
{
	int			version;
	void		( *RenderMode )( int mode );
	void		( *Begin )( int primitiveCode );
	void		( *End ) ( void );
	void		( *Color4f ) ( float r, float g, float b, float a );
	void		( *Color4ub ) ( unsigned char r, unsigned char g, unsigned char b, unsigned char a );
	void		( *TexCoord2f ) ( float u, float v );
	void		( *Vertex3fv ) ( float *worldPnt );
	void		( *Vertex3f ) ( float x, float y, float z );
	void		( *Brightness ) ( float brightness );
	void		( *CullFace ) ( TRICULLSTYLE style );
	int			( *SpriteTexture ) ( struct model_s *pSpriteModel, int frame );
	int			( *WorldToScreen ) ( float *world, float *screen );
} triangleapi_t;
typedef struct tempent_s
{
	ftent_t			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	TEMPENTITY	*next;
	int			priority;
	short		clientIndex;
	vec3_t		tentOffset;
	cl_entity_t	entity;
} TEMPENTITY;
struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
};
typedef struct event_api_s
{
	int		version;
	void	( *EV_PlaySound ) ( int ent, float *origin, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	void	( *EV_StopSound ) ( int ent, int channel, const char *sample );
	int		( *EV_FindModelIndex )( const char *pmodel );
	int		( *EV_IsLocal ) ( int playernum );
	int		( *EV_LocalPlayerDucking ) ( void );
	void	( *EV_LocalPlayerViewheight ) ( float * );
	void	( *EV_LocalPlayerBounds ) ( int hull, float *mins, float *maxs );
	int		( *EV_IndexFromTrace) ( struct pmtrace_s *pTrace );
	struct physent_s *( *EV_GetPhysent ) ( int idx );
	void	( *EV_SetUpPlayerPrediction ) ( int dopred, int bIncludeLocalClient );
	void	( *EV_PushPMStates ) ( void );
	void	( *EV_PopPMStates ) ( void );
	void	( *EV_SetSolidPlayers ) (int playernum);
	void	( *EV_SetTraceHull ) ( int hull );
	void	( *EV_PlayerTrace ) ( float *start, float *end, int traceFlags, int ignore_pe, struct pmtrace_s *tr );
	void	( *EV_WeaponAnimation ) ( int sequence, int body );
	unsigned short ( *EV_PrecacheEvent ) ( int type, const char* psz );
	void	( *EV_PlaybackEvent ) ( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	const char *( *EV_TraceTexture ) ( int ground, float *vstart, float *vend );
	void	( *EV_StopAllSounds ) ( int entnum, int entchannel );
	void    ( *EV_KillEvents ) ( int entnum, const char *eventname );
} event_api_t;
typedef struct demo_api_s
{
	int		( *IsRecording )	( void );
	int		( *IsPlayingback )	( void );
	int		( *IsTimeDemo )		( void );
	void	( *WriteBuffer )	( int size, unsigned char *buffer );
} demo_api_t;
typedef struct net_api_s
{
	void		( *InitNetworking )( void );
	void		( *Status ) ( struct net_status_s *status );
	void		( *SendRequest) ( int context, int request, int flags, double timeout, struct netadr_s *remote_address, net_api_response_func_t response );
	void		( *CancelRequest ) ( int context );
	void		( *CancelAllRequests ) ( void );
	char		*( *AdrToString ) ( struct netadr_s *a );
	int			( *CompareAdr ) ( struct netadr_s *a, struct netadr_s *b );
	int			( *StringToAdr ) ( char *s, struct netadr_s *a );
	const char *( *ValueForKey ) ( const char *s, const char *key );
	void		( *RemoveKey ) ( char *s, const char *key );
	void		( *SetValueForKey ) (char *s, const char *key, const char *value, int maxsize );
} net_api_t;
typedef struct engine_api_s
{
	int		version;
	int		rendertype;
	int		size;
	int		( *GetEngineState )				( void );
	void	( *Cbuf_AddText )				( char *text );
	void	( *Cbuf_InsertText )			( char *text );
	void	( *Cmd_AddCommand )				( char *cmd_name, void ( *funcname )( void ) );
	int		( *Cmd_Argc )					( void );
	char	*( *Cmd_Args )					( void );
	char	*( *Cmd_Argv )					( int arg );
	void	( *Con_Printf )					( char *, ... );
	void	( *Con_SafePrintf )				( char *, ... );
	void	( *Cvar_Set )					( char *var_name, char *value );
	void	( *Cvar_SetValue )				( char *var_name, float value );
	int		( *Cvar_VariableInt )			( char *var_name );
	char	*( *Cvar_VariableString )		( char *var_name );
	float	( *Cvar_VariableValue )			( char *var_name );
	void	( *ForceReloadProfile )			( void );
	int		( *GetGameInfo )				( struct GameInfo_s *pGI, char *pszChannel );
	void	( *GameSetBackground )			( int bBack );
	void	( *GameSetState )				( int iState );
	void	( *GameSetSubState )			( int iState );
	int		( *GetPauseState )				( void );
	int		( *Host_Frame )					( float time, int iState, int *stateInfo );
	void	( *Host_GetHostInfo )			( float *fps, int *nActive, int *nSpectators, int *nMaxPlayers, char *pszMap );
	void	( *Host_Shutdown )				( void );
	int		( *Game_Init )					( char *lpCmdLine, unsigned char *pMem, int iSize, struct exefuncs_s *pef, void *, int );
	void	( *IN_ActivateMouse )			( void );
	void	( *IN_ClearStates )				( void );
	void	( *IN_DeactivateMouse )			( void );
	void	( *IN_MouseEvent )				( int mstate );
	void	( *Keyboard_ReturnToGame )		( void );
	void	( *Key_ClearStates )			( void );
	void	( *Key_Event )					( int key, int down );
	int		( *LoadGame )					( const char *pszSlot );
	void	( *S_BlockSound )				( void );
	void	( *S_ClearBuffer )				( void );
	void	( *S_GetDSPointer )				( struct IDirectSound **lpDS, struct IDirectSoundBuffer **lpDSBuf );
	void 	*( *S_GetWAVPointer )			( void );
	void	( *S_UnblockSound )				( void );
	int		( *SaveGame )					( const char *pszSlot, const char *pszComment );
	void	( *SetAuth )					( void *pobj );
	void	( *SetMessagePumpDisableMode )	( int bMode );
	void	( *SetPauseState )				( int bPause );
	void	( *SetStartupMode )				( int bMode );
	void	( *SNDDMA_Shutdown )			( void );
	void	( *Snd_AcquireBuffer )			( void );
	void	( *Snd_ReleaseBuffer )			( void );
	void	( *StoreProfile )				( void );
	double	( *Sys_FloatTime )				( void );
	void	( *VID_UpdateWindowVars )		( void *prc, int x, int y );
	void	( *VID_UpdateVID )				( struct viddef_s *pvid );
	void	( *VGui_CallEngineSurfaceProc )	( void* hwnd, unsigned int msg, unsigned int wparam, long lparam );
	void    ( *EngineTakingFocus )			( void );
	void    ( *LauncherTakingFocus )		( void );
#ifdef _WIN32
  // NOTE: Don't use Windows definitions. This is because <windows.h> includes its own HSPRITE definition, which conflicts with typedef int HSPRITE.
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( void* hwndGame, void *pmaindc, void *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( void* hwnd, void* hdc, void* hglrc );
	void	( *QGL_D3DShared )				( void *d3dGShared );
	int		( __stdcall *glSwapBuffers )		( void* dc );
  /*
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( HWND hwndGame, HDC *pmaindc, HGLRC *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( HWND hwnd, HDC hdc, HGLRC hglrc );
	void	( *QGL_D3DShared )				( struct tagD3DGlobals *d3dGShared );
	int		( WINAPI *glSwapBuffers )		( HDC dc );
  */
#else
	void	( *GL_Init )					( void );
	void	( *GL_SetMode )					( void );
	void	( *GL_Shutdown )				( void );
	void	( *QGL_D3DShared )				( void );
	void	( *glSwapBuffers )				( void );
#endif
} engine_api_t;
typedef struct cl_enginefuncs_s
{
	HSPRITE						( *pfnSPR_Load )			( const char *szPicName );
	int							( *pfnSPR_Frames )			( HSPRITE hPic );
	int							( *pfnSPR_Height )			( HSPRITE hPic, int frame );
	int							( *pfnSPR_Width )			( HSPRITE hPic, int frame );
	void						( *pfnSPR_Set )				( HSPRITE hPic, int r, int g, int b );
	void						( *pfnSPR_Draw )			( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawHoles )		( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawAdditive )	( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_EnableScissor )	( int x, int y, int width, int height );
	void						( *pfnSPR_DisableScissor )	( void );
	client_sprite_t				*( *pfnSPR_GetList )			( char *psz, int *piCount );
	void						( *pfnFillRGBA )			( int x, int y, int width, int height, int r, int g, int b, int a );
	int							( *pfnGetScreenInfo ) 		( SCREENINFO *pscrinfo );
	void						( *pfnSetCrosshair )		( HSPRITE hspr, wrect_t rc, int r, int g, int b );
	struct cvar_s				*( *pfnRegisterVariable )	( char *szName, char *szValue, int flags );
	float						( *pfnGetCvarFloat )		( char *szName );
	char*						( *pfnGetCvarString )		( char *szName );
	int							( *pfnAddCommand )			( char *cmd_name, void (*function)(void) );
	int							( *pfnHookUserMsg )			( char *szMsgName, pfnUserMsgHook pfn );
	int							( *pfnServerCmd )			( char *szCmdString );
	int							( *pfnClientCmd )			( char *szCmdString );
	void						( *pfnGetPlayerInfo )		( int ent_num, hud_player_info_t *pinfo );
	void						( *pfnPlaySoundByName )		( char *szSound, float volume );
	void						( *pfnPlaySoundByIndex )	( int iSound, float volume );
	void						( *pfnAngleVectors )		( const float * vecAngles, float * forward, float * right, float * up );
	client_textmessage_t		*( *pfnTextMessageGet )		( const char *pName );
	int							( *pfnDrawCharacter )		( int x, int y, int number, int r, int g, int b );
	int							( *pfnDrawConsoleString )	( int x, int y, char *string );
	void						( *pfnDrawSetTextColor )	( float r, float g, float b );
	void						( *pfnDrawConsoleStringLen )(  const char *string, int *length, int *height );
	void						( *pfnConsolePrint )		( const char *string );
	void						( *pfnCenterPrint )			( const char *string );
	int							( *GetWindowCenterX )		( void );
	int							( *GetWindowCenterY )		( void );
	void						( *GetViewAngles )			( float * );
	void						( *SetViewAngles )			( float * );
	int							( *GetMaxClients )			( void );
	void						( *Cvar_SetValue )			( char *cvar, float value );
	int       					(*Cmd_Argc)					(void);
	char						*( *Cmd_Argv )				( int arg );
	void						( *Con_Printf )				( char *fmt, ... );
	void						( *Con_DPrintf )			( char *fmt, ... );
	void						( *Con_NPrintf )			( int pos, char *fmt, ... );
	void						( *Con_NXPrintf )			( struct con_nprint_s *info, char *fmt, ... );
	const char					*( *PhysInfo_ValueForKey )	( const char *key );
	const char					*( *ServerInfo_ValueForKey )( const char *key );
	float						( *GetClientMaxspeed )		( void );
	int							( *CheckParm )				( char *parm, char **ppnext );
	void						( *Key_Event )				( int key, int down );
	void						( *GetMousePosition )		( int *mx, int *my );
	int							( *IsNoClipping )			( void );
	struct cl_entity_s			*( *GetLocalPlayer )		( void );
	struct cl_entity_s			*( *GetViewModel )			( void );
	struct cl_entity_s			*( *GetEntityByIndex )		( int idx );
	float						( *GetClientTime )			( void );
	void						( *V_CalcShake )			( void );
	void						( *V_ApplyShake )			( float *origin, float *angles, float factor );
	int							( *PM_PointContents )		( float *point, int *truecontents );
	int							( *PM_WaterEntity )			( float *p );
	struct pmtrace_s			*( *PM_TraceLine )			( float *start, float *end, int flags, int usehull, int ignore_pe );
	struct model_s				*( *CL_LoadModel )			( const char *modelname, int *index );
	int							( *CL_CreateVisibleEntity )	( int type, struct cl_entity_s *ent );
	const struct model_s *		( *GetSpritePointer )		( HSPRITE hSprite );
	void						( *pfnPlaySoundByNameAtLocation )	( char *szSound, float volume, float *origin );
	unsigned short				( *pfnPrecacheEvent )		( int type, const char* psz );
	void						( *pfnPlaybackEvent )		( fev_t flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	void						( *pfnWeaponAnim )			( int iAnim, int body );
	float						( *pfnRandomFloat )			( float flLow, float flHigh );
	long						( *pfnRandomLong )			( long lLow, long lHigh );
	void						( *pfnHookEvent )			( char *name, void ( *pfnEvent )( struct event_args_s *args ) );
	int							(*Con_IsVisible)			();
	const char					*( *pfnGetGameDirectory )	( void );
	struct cvar_s				*( *pfnGetCvarPointer )		( const char *szName );
	const char					*( *Key_LookupBinding )		( const char *pBinding );
	const char					*( *pfnGetLevelName )		( void );
	void						( *pfnGetScreenFade )		( struct screenfade_s *fade );
	void						( *pfnSetScreenFade )		( struct screenfade_s *fade );
	void                        *( *VGui_GetPanel )         ( );
	void                         ( *VGui_ViewportPaintBackground ) (int extents[4]);
	byte*						(*COM_LoadFile)				( char *path, int usehunk, int *pLength );
	char*						(*COM_ParseFile)			( char *data, char *token );
	void						(*COM_FreeFile)				( void *buffer );
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
} cl_enginefunc_t;
typedef struct
{
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;
	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;
typedef struct
{
	string_t	classname;
	string_t	globalname;
	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;
	vec3_t		movedir;
	vec3_t		angles;
	vec3_t		avelocity;
	vec3_t		punchangle;
	vec3_t		v_angle;
	vec3_t		endpos;
	vec3_t		startpos;
	float		impacttime;
	float		starttime;
	int			fixangle;
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;
	int			modelindex;
	string_t	model;
	int			viewmodel;
	int			weaponmodel;
	vec3_t		absmin;
	vec3_t		absmax;
	vec3_t		mins;
	vec3_t		maxs;
	vec3_t		size;
	float		ltime;
	float		nextthink;
	movetype_t			movetype;
	solid_t			solid;
	int			skin;
	int			body;
	effects_t 		effects;
	float		gravity;
	float		friction;
	int			light_level;
	int			sequence;
	int			gaitsequence;
	float		frame;
	float		animtime;
	float		framerate;
	byte		controller[4];
	byte		blending[2];
	float		scale;
	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;
	float		health;
	float		frags;
	weapontype_t			weapons;
	float		takedamage;
	deadflag_t			deadflag;
	vec3_t		view_ofs;
	inbutton_t			button;
	int			impulse;
	edict_t		*chain;
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;
	edict_t		*owner;
	edict_t		*groundentity;
	int			spawnflags;
	flags_t			flags;
	int			colormap;
	int			team;
	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;
	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	edict_t		*pContainingEntity;
	int			playerclass;
	float		maxspeed;
	float		fov;
	int			weaponanim;
	int			pushmsec;
	int			bInDuck;
	int			flTimeStepSound;
	int			flSwimTime;
	int			flDuckTime;
	int			iStepLeft;
	float		flFallVelocity;
	int			gamestate;
	int			oldbuttons;
	int			groupinfo;
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
	edict_t		*euser1;
	edict_t		*euser2;
	edict_t		*euser3;
	edict_t		*euser4;
} entvars_t;
struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;
	int			headnode;
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];
	float		freetime;
	void*		pvPrivateData;
	entvars_t	v;
};
typedef struct
{
	unsigned short	amplitude;
	unsigned short 	duration;
	unsigned short	frequency;
} ScreenShake;
typedef struct
{
	unsigned short 	duration;
	unsigned short 	holdTime;
	short			fadeFlags;
	byte			r, g, b, a;
} ScreenFade;
typedef struct KeyValueData_s
{
	char	*szClassName;
	char	*szKeyName;
	char	*szValue;
	long	fHandled;
} KeyValueData;
typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
typedef struct
{
	int			id;
	edict_t	*pent;
	int			location;
	int			size;
	int			flags;
	string_t	classname;
} ENTITYTABLE;
typedef struct saverestore_s
{
	char		*pBaseData;
	char		*pCurrentData;
	int			size;
	int			bufferSize;
	int			tokenSize;
	int			tokenCount;
	char		**pTokens;
	int			currentIndex;
	int			tableCount;
	int			connectionCount;
	ENTITYTABLE	*pTable;
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];
	int			fUseLandmark;
	char		szLandmarkName[20];
	vec3_t		vecLandmarkOffset;
	float		time;
	char		szCurrentMapName[32];
} SAVERESTOREDATA;
typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,
	FIELD_STRING,
	FIELD_ENTITY,
	FIELD_CLASSPTR,
	FIELD_EHANDLE,
	FIELD_EVARS,
	FIELD_EDICT,
	FIELD_VECTOR,
	FIELD_POSITION_VECTOR,
	FIELD_POINTER,
	FIELD_INTEGER,
	FIELD_FUNCTION,
	FIELD_BOOLEAN,
	FIELD_SHORT,
	FIELD_CHARACTER,
	FIELD_TIME,
	FIELD_MODELNAME,
	FIELD_SOUNDNAME,
	FIELD_TYPECOUNT,
} FIELDTYPE;
typedef struct
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;
class CSaveRestoreBuffer __packed
{
public:
	CSaveRestoreBuffer( void );
	CSaveRestoreBuffer( SAVERESTOREDATA *pdata );
	~CSaveRestoreBuffer( void );
	int			EntityIndex( entvars_t *pevLookup );
	int			EntityIndex( edict_t *pentLookup );
	int			EntityIndex( EOFFSET eoLookup );
	int			EntityIndex( CBaseEntity *pEntity );
	int			EntityFlags( int entityIndex, int flags ) ;
	int			EntityFlagsSet( int entityIndex, int flags );
	edict_t		*EntityFromIndex( int entityIndex );
	unsigned short	TokenHash( const char *pszToken );
protected:
	SAVERESTOREDATA		*m_pdata;
	void		BufferRewind( int size );
	unsigned int	HashString( const char *pszToken );
};
class __base(CSaveRestoreBuffer, 0) CSave __packed
{
public:
	CSave( SAVERESTOREDATA *pdata );
	void	WriteShort( const char *pname, const short *value, int count );
	void	WriteInt( const char *pname, const int *value, int count );
	void	WriteFloat( const char *pname, const float *value, int count );
	void	WriteTime( const char *pname, const float *value, int count );
	void	WriteData( const char *pname, int size, const char *pdata );
	void	WriteString( const char *pname, const char *pstring );
	void	WriteString( const char *pname, const int *stringId, int count );
	void	WriteVector( const char *pname, const Vector &value );
	void	WriteVector( const char *pname, const float *value, int count );
	void	WritePositionVector( const char *pname, const Vector &value );
	void	WritePositionVector( const char *pname, const float *value, int count );
	void	WriteFunction( const char *pname, const int *value, int count );
	int		WriteEntVars( const char *pname, entvars_t *pev );
	int		WriteFields( const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount );
private:
	int		DataEmpty( const char *pdata, int size );
	void	BufferField( const char *pname, int size, const char *pdata );
	void	BufferString( char *pdata, int len );
	void	BufferData( const char *pdata, int size );
	void	BufferHeader( const char *pname, int size );
};
typedef struct
{
	unsigned short		size;
	unsigned short		token;
	char				*pData;
} HEADER;
class __base(CSaveRestoreBuffer, 0) CRestore __packed
{
public:
	CRestore( SAVERESTOREDATA *pdata );
	int		ReadEntVars( const char *pname, entvars_t *pev );
	int		ReadFields( const char *pname, void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount );
	int		ReadField( void *pBaseData, TYPEDESCRIPTION *pFields, int fieldCount, int startField, int size, char *pName, void *pData );
	int		ReadInt( void );
	short	ReadShort( void );
	int		ReadNamedInt( const char *pName );
	char	*ReadNamedString( const char *pName );
	int		Empty( void ) ;
	inline	void SetGlobalMode( int global ) ;
	void	PrecacheMode( BOOL mode ) ;
private:
	char	*BufferPointer( void );
	void	BufferReadBytes( char *pOutput, int size );
	void	BufferSkipBytes( int bytes );
	int		BufferSkipZString( void );
	int		BufferCheckZString( const char *string );
	void	BufferReadHeader( HEADER *pheader );
	int		m_global;
	BOOL	m_precache;
};
struct globalentity_s
{
	char			name[64];
	char			levelName[32];
	GLOBALESTATE	state;
	globalentity_t	*pNext;
};
class CGlobalState __packed
{
public:
					CGlobalState();
	void			Reset( void );
	void			ClearStates( void );
	void			EntityAdd( string_t globalname, string_t mapName, GLOBALESTATE state );
	void			EntitySetState( string_t globalname, GLOBALESTATE state );
	void			EntityUpdate( string_t globalname, string_t mapname );
	const globalentity_t	*EntityFromTable( string_t globalname );
	GLOBALESTATE	EntityGetState( string_t globalname );
	int				EntityInTable( string_t globalname ) ;
	int				Save( CSave &save );
	int				Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	void			DumpGlobals( void );
private:
	globalentity_t	*Find( string_t globalname );
	globalentity_t	*m_pList;
	int				m_listCount;
};
typedef struct
	{
	int		fAllSolid;
	int		fStartSolid;
	int		fInOpen;
	int		fInWater;
	float	flFraction;
	vec3_t	vecEndPos;
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;
	edict_t	*pHit;
	hitgroup_t		iHitgroup;
	} TraceResult;
class EHANDLE __packed
{
private:
	edict_t *m_pent;
	int		m_serialnumber;
public:
	edict_t *Get( void );
	edict_t *Set( edict_t *pent );
	operator int ();
	operator CBaseEntity *();
	CBaseEntity * operator = (CBaseEntity *pEntity);
	CBaseEntity * operator ->();
};
typedef enum
	{
	at_notice,
	at_console,
	at_aiconsole,
	at_warning,
	at_error,
	at_logged
	} ALERT_TYPE;
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;
typedef enum
{
	force_exactfile,
	force_model_samebounds,
	force_model_specifybounds,
} FORCE_TYPE;
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(char* s);
	int			(*pfnPrecacheSound)			(char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, walkmove_t iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, channel_t channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, hull_t hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, hull_t hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	contents_t			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(msg_t msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, char *szFmt, ...);
	void		(*pfnEngineFprintf)			(FILE *pfile, char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, long cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	struct entvars_s*	(*pfnGetVarsOfEnt)			(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(struct entvars_s* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	unsigned long (*pfnFunctionFromName)	( const char *pName );
	const char *(*pfnNameForFunction)		( unsigned long function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg );
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );
	const char *(*pfnCmd_Argv)				( int argc );
	int			(*pfnCmd_Argc)				( void );
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	long		(*pfnRandomLong)			(long  lLow,  long  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName);
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e );
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);
	cvar_t		*(*pfnCVarGetPointer)		(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)		(edict_t *e);
	void		(*pfnInfo_RemoveKey)		( char *s, const char *key );
	const char *(*pfnGetPhysicsKeyValue)	( const edict_t *pClient, const char *key );
	void		(*pfnSetPhysicsKeyValue)	( const edict_t *pClient, const char *key, const char *value );
	const char *(*pfnGetPhysicsInfoString)	( const edict_t *pClient );
	unsigned short (*pfnPrecacheEvent)		( int type, const char*psz );
	void		(*pfnPlaybackEvent)			( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	unsigned char *(*pfnSetFatPVS)			( float *org );
	unsigned char *(*pfnSetFatPAS)			( float *org );
	int			(*pfnCheckVisibility )		( const edict_t *entity, unsigned char *pset );
	void		(*pfnDeltaSetField)			( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaUnsetField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaAddEncoder)		( char *name, void (*conditionalencode)( struct delta_s *pFields, const unsigned char *from, const unsigned char *to ) );
	int			(*pfnGetCurrentPlayer)		( void );
	int			(*pfnCanSkipPlayer)			( const edict_t *player );
	int			(*pfnDeltaFindField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaSetFieldByIndex)	( struct delta_s *pFields, int fieldNumber );
	void		(*pfnDeltaUnsetFieldByIndex)( struct delta_s *pFields, int fieldNumber );
	void		(*pfnSetGroupMask)			( int mask, int op );
	int			(*pfnCreateInstancedBaseline) ( int classname, struct entity_state_s *baseline );
	void		(*pfnCvar_DirectSet)		( struct cvar_s *var, char *value );
	void		(*pfnForceUnmodified)		( FORCE_TYPE type, float *mins, float *maxs, const char *filename );
	void		(*pfnGetPlayerStats)		( const edict_t *pClient, int *ping, int *packet_loss );
} enginefuncs_t;
struct __data_var_refs vtable_for_CBaseEntity
{
  void	(* Spawn)( CBaseEntity* p ) ;
  void	(* Precache)( CBaseEntity* p ) ;
  void	(* KeyValue)( CBaseEntity* p, KeyValueData* pkvd) ;
  int		(* Save)( CBaseEntity* p, CSave &save );
  int		(* Restore)( CBaseEntity* p, CRestore &restore );
  fcap_t		(* ObjectCaps)( CBaseEntity* p ) ;
  void	(* Activate)( CBaseEntity* p ) ;
  void	(* SetObjectCollisionBox)( CBaseEntity* p );
  class_t (* Classify)( CBaseEntity* p ) ;
  void (* DeathNotice)( CBaseEntity* p, entvars_t *pevChild ) ;
  void	(* TraceAttack)( CBaseEntity* p, entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
  int		(* TakeDamage)( CBaseEntity* p, entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
  int		(* TakeHealth)( CBaseEntity* p, float flHealth, dmg_t bitsDamageType );
  void	(* Killed)( CBaseEntity* p, entvars_t *pevAttacker, gib_t iGib );
  bloodcolor_t		(* BloodColor)( CBaseEntity* p ) ;
  void	(* TraceBleed)( CBaseEntity* p, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType );
  BOOL    (* IsTriggered)( CBaseEntity* p, CBaseEntity *pActivator ) ;
  CBaseMonster *(*MyMonsterPointer)( CBaseEntity* p ) ;
  CSquadMonster *(*MySquadMonsterPointer)( CBaseEntity* p ) ;
  int		(* GetToggleState)( CBaseEntity* p ) ;
  void	(* AddPoints)( CBaseEntity* p, int score, BOOL bAllowNegativeScore ) ;
  void	(* AddPointsToTeam)( CBaseEntity* p, int score, BOOL bAllowNegativeScore ) ;
  BOOL	(* AddPlayerItem)( CBaseEntity* p, CBasePlayerItem *pItem ) ;
  BOOL	(* RemovePlayerItem)( CBaseEntity* p, CBasePlayerItem *pItem ) ;
  int 	(* GiveAmmo)( CBaseEntity* p, int iAmount, char *szName, int iMax ) ;
  float	(* GetDelay)( CBaseEntity* p ) ;
  int		(* IsMoving)( CBaseEntity* p ) ;
  void	(* OverrideReset)( CBaseEntity* p ) ;
  int		(* DamageDecal)( CBaseEntity* p, dmg_t bitsDamageType );
  void	(* SetToggleState)( CBaseEntity* p, int state ) ;
  void    (* StartSneaking)( CBaseEntity* p ) ;
  void    (* StopSneaking)( CBaseEntity* p ) ;
  BOOL	(* OnControls)( CBaseEntity* p, entvars_t *pev ) ;
  BOOL    (* IsSneaking)( CBaseEntity* p ) ;
  BOOL	(* IsAlive)( CBaseEntity* p ) ;
  BOOL	(* IsBSPModel)( CBaseEntity* p ) ;
  BOOL	(* ReflectGauss)( CBaseEntity* p ) ;
  BOOL	(* HasTarget)( CBaseEntity* p, string_t targetname ) ;
  BOOL    (* IsInWorld)( CBaseEntity* p );
  BOOL	(* IsPlayer)( CBaseEntity* p ) ;
  BOOL	(* IsNetClient)( CBaseEntity* p ) ;
  const char *(* TeamID)( CBaseEntity* p ) ;
  CBaseEntity *(* GetNextTarget)( CBaseEntity* p );
  void (* Think)( CBaseEntity* p ) ;
  void (* Touch)( CBaseEntity* p, CBaseEntity *pOther ) ;
  void (* Use)( CBaseEntity* p, CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
  void (* Blocked)( CBaseEntity* p, CBaseEntity *pOther ) ;
  CBaseEntity * (* Respawn)( CBaseEntity* p ) ;
  void (* UpdateOwner)( CBaseEntity* p ) ;
  BOOL (* FBecomeProne)( CBaseEntity* p ) ;
  Vector (* Center)( CBaseEntity* p ) ;
  Vector (* EyePosition)( CBaseEntity* p ) ;
  Vector (* EarPosition)( CBaseEntity* p ) ;
  Vector (* BodyTarget)( CBaseEntity* p, const Vector &posSrc ) ;
  int (* Illumination)( CBaseEntity* p ) ;
  BOOL (* FVisible)( CBaseEntity* p, CBaseEntity *pEntity );
  BOOL (* FVisible2)( CBaseEntity* p, const Vector &vecOrigin ); // Was originally named FVisible
};
class CBaseEntity __packed
{
	struct vtable_for_CBaseEntity* vtable;
public:
	entvars_t *pev;
	CBaseEntity			*m_pGoalEnt;
	CBaseEntity			*m_pLink;
	static	TYPEDESCRIPTION m_SaveData[];
  // TODO: Binary ninja does not seem to recognize member function pointer definitions.
  /*
	void (CBaseEntity ::*m_pfnThink)(void);
	void (CBaseEntity ::*m_pfnTouch)( CBaseEntity *pOther );
	void (CBaseEntity ::*m_pfnUse)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void (CBaseEntity ::*m_pfnBlocked)( CBaseEntity *pOther );
  */
	void (*m_pfnThink)(void);
	void (*m_pfnTouch)( CBaseEntity *pOther );
	void (*m_pfnUse)( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void (*m_pfnBlocked)( CBaseEntity *pOther );
    void *operator new( size_t stAllocateBlock, entvars_t *pev );
#if _MSC_VER >= 1200
	void operator delete(void *pMem, entvars_t *pev);
#endif
	void UpdateOnRemove( void );
	void EXPORT SUB_Remove( void );
	void EXPORT SUB_DoNothing( void );
	void EXPORT SUB_StartFadeOut ( void );
	void EXPORT SUB_FadeOut ( void );
	void EXPORT SUB_CallUseToggle( void ) ;
	int			ShouldToggle( USE_TYPE useType, BOOL currentState );
	void		FireBullets( ULONG	cShots, Vector  vecSrc, Vector	vecDirShooting,	Vector	vecSpread, float flDistance, Bullet iBulletType, int iTracerFreq = 4, int iDamage = 0, entvars_t *pevAttacker = NULL  );
	void SUB_UseTargets( CBaseEntity *pActivator, USE_TYPE useType, float value );
	int		Intersects( CBaseEntity *pOther );
	void	MakeDormant( void );
	int		IsDormant( void );
	BOOL    IsLockedByMaster( void ) ;
#ifdef _DEBUG
	static CBaseEntity *Instance( edict_t *pent ) ;
#else
	static CBaseEntity *Instance( edict_t *pent );
#endif
	static CBaseEntity *Instance( entvars_t *pev ) ;
	static CBaseEntity *Instance( int eoffset) ;
	CBaseMonster *GetMonsterPointer( entvars_t *pevMonster ) ;
	CBaseMonster *GetMonsterPointer( edict_t *pentMonster ) ;
#ifdef _DEBUG
	void FunctionCheck( void *pFunction, char *name ) ;
	BASEPTR	ThinkSet( BASEPTR func, char *name ) ;
	ENTITYFUNCPTR TouchSet( ENTITYFUNCPTR func, char *name ) ;
	USEPTR	UseSet( USEPTR func, char *name ) ;
	ENTITYFUNCPTR	BlockedSet( ENTITYFUNCPTR func, char *name ) ;
#endif
	static CBaseEntity *Create( char *szName, const Vector &vecOrigin, const Vector &vecAngles, edict_t *pentOwner = NULL );
	edict_t *edict() ;
	EOFFSET eoffset( ) ;
	int	  entindex( ) ;
};
class CNode __packed
{
public:
	Vector	m_vecOrigin;
	Vector  m_vecOriginPeek;
	BYTE    m_Region[3];
	int		m_afNodeInfo;
	int		m_cNumLinks;
	int		m_iFirstLink;
	int		m_pNextBestNode[MAX_NODE_HULLS][2];
	float   m_flClosestSoFar;
	int		m_iPreviousNode;
	short	m_sHintType;
	short	m_sHintActivity;
	float	m_flHintYaw;
};
class CLink __packed
{
public:
	int		m_iSrcNode;
	int		m_iDestNode;
	entvars_t	*m_pLinkEnt;
	char	m_szLinkEntModelname[ 4 ];
	int		m_afLinkInfo;
	float	m_flWeight;
};
typedef struct
{
	int m_SortedBy[3];
	int m_CheckedEvent;
} DIST_INFO;
typedef struct
{
	Vector v;
	short n;
} CACHE_ENTRY;
class CGraph __packed
{
public:
	BOOL	m_fGraphPresent;
	BOOL	m_fGraphPointersSet;
	BOOL    m_fRoutingComplete;
	CNode	*m_pNodes;
	CLink	*m_pLinkPool;
	char    *m_pRouteInfo;
	int		m_cNodes;
	int		m_cLinks;
	int     m_nRouteInfo;
	DIST_INFO *m_di;
	int m_RangeStart[3][NUM_RANGES];
	int m_RangeEnd[3][NUM_RANGES];
	float m_flShortest;
	int m_iNearest;
	int m_minX, m_minY, m_minZ, m_maxX, m_maxY, m_maxZ;
	int m_minBoxX, m_minBoxY, m_minBoxZ, m_maxBoxX, m_maxBoxY, m_maxBoxZ;
	int m_CheckedCounter;
	float m_RegionMin[3], m_RegionMax[3];
	CACHE_ENTRY m_Cache[CACHE_SIZE];
	int m_HashPrimes[16];
	short *m_pHashLinks;
	int m_nHashLinks;
	int		m_iLastActiveIdleSearch;
	int		m_iLastCoverSearch;
	int		LinkVisibleNodes ( CLink *pLinkPool, FILE *file, int *piBadNode );
	int		RejectInlineLinks ( CLink *pLinkPool, FILE *file );
	int		FindShortestPath ( int *piPath, int iStart, int iDest, int iHull, int afCapMask);
	int		FindNearestNode ( const Vector &vecOrigin, CBaseEntity *pEntity );
	int		FindNearestNode ( const Vector &vecOrigin, int afNodeTypes );
	float	PathLength( int iStart, int iDest, int iHull, int afCapMask );
	int		NextNodeInRoute( int iCurrentNode, int iDest, int iHull, int iCap );
	enum NODEQUERY { NODEGRAPH_DYNAMIC, NODEGRAPH_STATIC };
	int		HandleLinkEnt ( int iNode, entvars_t *pevLinkEnt, int afCapMask, NODEQUERY queryType );
	entvars_t*	LinkEntForLink ( CLink *pLink, CNode *pNode );
	void	ShowNodeConnections ( int iNode );
	void	InitGraph( void );
	int		AllocNodes ( void );
	int		CheckNODFile(char *szMapName);
	int		FLoadGraph(char *szMapName);
	int		FSaveGraph(char *szMapName);
	int		FSetGraphPointers(void);
	void	CheckNode(Vector vecOrigin, int iNode);
	void    BuildRegionTables(void);
	void    ComputeStaticRoutingTables(void);
	void    TestRoutingTables(void);
	void	HashInsert(int iSrcNode, int iDestNode, int iKey);
	void    HashSearch(int iSrcNode, int iDestNode, int &iKey);
	void	HashChoosePrimes(int TableSize);
	void    BuildLinkLookups(void);
	void    SortNodes(void);
	int			HullIndex( const CBaseEntity *pEntity );
	int			NodeType( const CBaseEntity *pEntity );
	inline int	CapIndex( int afCapMask );
	inline	CNode &Node( int i );
	inline	CLink &Link( int i );
	inline CLink &NodeLink( int iNode, int iLink );
	inline CLink &NodeLink( const CNode &node, int iLink );
	inline  int	INodeLink ( int iNode, int iLink );
#if 0
	inline CNode &SourceNode( int iNode, int iLink );
	inline CNode &DestNode( int iNode, int iLink );
	inline	CNode *PNodeLink ( int iNode, int iLink );
#endif
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CNodeEnt
{
	fcap_t	(* ObjectCaps)( class CNodeEnt* p ) ;
};
class __base(CBaseEntity, 0) CNodeEnt __packed
{
	struct vtable_for_CNodeEnt* vtable;
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	short m_sHintType;
	short m_sHintActivity;
};
class CSound __packed
{
public:
	void	Clear ( void );
	void	Reset ( void );
	Vector	m_vecOrigin;
	bitssound_t		m_iType;
	int		m_iVolume;
	float	m_flExpireTime;
	int		m_iNext;
	int		m_iNextAudible;
	BOOL	FIsSound( void );
	BOOL	FIsScent( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSoundEnt
{
	fcap_t	(* ObjectCaps)( class CSoundEnt* p ) ;
};
class __base(CBaseEntity, 0) CSoundEnt __packed
{
	struct vtable_for_CSoundEnt* vtable;
public:
	void Precache ( void );
	void Spawn( void );
	void Think( void );
	void Initialize ( void );
	static void		InsertSound ( bitssound_t iType, const Vector &vecOrigin, int iVolume, float flDuration );
	static void		FreeSound ( int iSound, int iPrevious );
	static int		ActiveList( void );
	static int		FreeList( void );
	static CSound*	SoundPointerForIndex( int iIndex );
	static int		ClientSoundIndex ( edict_t *pClient );
	BOOL	IsEmpty( void ) ;
	int		ISoundsInList ( int iListType );
	int		IAllocSound ( void );
	int		m_iFreeSound;
	int		m_iActiveSound;
	int		m_cLastActiveSounds;
	BOOL	m_fShowReport;
private:
	CSound		m_SoundPool[ MAX_WORLD_SOUNDS ];
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CWorld
{
};
class __base(CBaseEntity, 0) CWorld __packed
{
	struct vtable_for_CWorld* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CWorldItem
{
};
class __base(CBaseEntity, 0) CWorldItem __packed
{
	struct vtable_for_CWorldItem* vtable;
public:
	void	KeyValue(KeyValueData *pkvd );
	void	Spawn( void );
	int		m_iType;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSprayCan
{
	fcap_t	(* ObjectCaps)( class CSprayCan* p ) ;
};
class __base(CBaseEntity, 0) CSprayCan __packed
{
	struct vtable_for_CSprayCan* vtable;
public:
	void	Spawn ( entvars_t *pevOwner );
	void	Think( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBloodSplat
{
};
class __base(CBaseEntity, 0) CBloodSplat __packed
{
	struct vtable_for_CBloodSplat* vtable;
public:
	void	Spawn ( entvars_t *pevOwner );
	void	Spray ( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CDecal
{
};
class __base(CBaseEntity, 0) CDecal __packed
{
  	struct vtable_for_CDecal* vtable;
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT StaticDecal( void );
	void	EXPORT TriggerDecal( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCorpse
{
	fcap_t	(* ObjectCaps)( class CCorpse* p ) ;
};
class __base(CBaseEntity, 0) CCorpse __packed
{
  struct vtable_for_CCorpse* vtable;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPointEntity
{
	fcap_t	(* ObjectCaps)( class CPointEntity* p ) ;
};
class __base(CBaseEntity, 0) CPointEntity __packed
{
  struct vtable_for_CPointEntity* vtable;
public:
	void	Spawn( void );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CLight
{
	void	(* KeyValue)( class CLight* p, KeyValueData* pkvd );
	void	(* Spawn)( class CLight* p );
	int		(* Save)( class CLight* p, CSave &save );
	int		(* Restore)( class CLight* p, CRestore &restore );
};
class __base(CPointEntity, 0) CLight __packed
{
  struct vtable_for_CLight* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int		m_iStyle;
	int		m_iszPattern;
};
struct __base(vtable_for_CLight, 0) __data_var_refs vtable_for_CEnvLight
{
};
class __base(CLight, 0) CEnvLight __packed
{
  struct vtable_for_CEnvLight* vtable;
public:
	void	KeyValue( KeyValueData* pkvd );
	void	Spawn( void );
};
typedef struct dynpitchvol
{
	int preset;
	int pitchrun;
	int pitchstart;
	int spinup;
	int spindown;
	int volrun;
	int volstart;
	int fadein;
	int fadeout;
	int	lfotype;
	int lforate;
	int lfomodpitch;
	int lfomodvol;
	int cspinup;
	int	cspincount;
	int pitch;
	int spinupsav;
	int spindownsav;
	int pitchfrac;
	int vol;
	int fadeinsav;
	int fadeoutsav;
	int volfrac;
	int	lfofrac;
	int	lfomult;
} dynpitchvol_t;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CAmbientGeneric
{
  int (*Save)(class CAmbientGeneric* p, CSave & save);
  int (*Restore)(class CAmbientGeneric* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CAmbientGeneric* p);
};
class __base(CBaseEntity, 0) CAmbientGeneric __packed
{
  struct vtable_for_CAmbientGeneric* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Precache( void );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT RampThink( void );
	void InitModulationParms(void);
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flAttenuation;
	dynpitchvol_t m_dpv;
	BOOL	m_fActive;
	BOOL	m_fLooping;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CMultiSource
{
  int (*Save)(class CMultiSource* p, CSave & save);
  int (*Restore)(class CMultiSource* p, CRestore & restore);
};
class __base(CPointEntity, 0) CMultiSource __packed
{
  struct vtable_for_CMultiSource* vtable;
public:
	void Spawn( );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	fcap_t	ObjectCaps( void ) ;
	BOOL IsTriggered( CBaseEntity *pActivator );
	void EXPORT Register( void );
	static	TYPEDESCRIPTION m_SaveData[];
	EHANDLE		m_rgEntities[MS_MAX_TARGETS];
	int			m_rgTriggered[MS_MAX_TARGETS];
	int			m_iTotal;
	string_t	m_globalstate;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CTargetCDAudio
{
  void (*Use)(class CTargetCDAudio* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
};
class __base(CPointEntity, 0) CTargetCDAudio __packed
{
  struct vtable_for_CTargetCDAudio* vtable;
public:
	void			Spawn( void );
	void			KeyValue( KeyValueData *pkvd );
	void			Think( void );
	void			Play( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CEnvSound
{
  int (*Save)(class CEnvSound* p, CSave & save);
  int (*Restore)(class CEnvSound* p, CRestore & restore);
};
class __base(CPointEntity, 0) CEnvSound __packed
{
  struct vtable_for_CEnvSound* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Think( void );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flRadius;
	float m_flRoomtype;
};
typedef struct sentenceg
{
	char szgroupname[CBSENTENCENAME_MAX];
	int count;
	unsigned char rgblru[CSENTENCE_LRU_MAX];
} SENTENCEG;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSpeaker
{
  int (*Save)(class CSpeaker* p, CSave & save);
  int (*Restore)(class CSpeaker* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CSpeaker* p);
};
class __base(CBaseEntity, 0) CSpeaker __packed
{
  struct vtable_for_CSpeaker* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Spawn( void );
	void Precache( void );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT SpeakerThink( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int	m_preset;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CNullEntity
{
};
class __base(CBaseEntity, 0) CNullEntity __packed
{
  struct vtable_for_CNullEntity* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CBaseDMStart
{
};
class __base(CPointEntity, 0) CBaseDMStart __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	BOOL		IsTriggered( CBaseEntity *pEntity );
private:
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFrictionModifier
{
  int (*Save)(class CFrictionModifier* p, CSave & save);
  int (*Restore)(class CFrictionModifier* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CFrictionModifier* p);
};
class __base(CBaseEntity, 0) CFrictionModifier __packed
{
  struct vtable_for_CFrictionModifier* vtable;
public:
	void		Spawn( void );
	void		KeyValue( KeyValueData *pkvd );
	void EXPORT	ChangeFriction( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float		m_frictionFraction;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBubbling
{
  int (*Save)(class CBubbling* p, CSave & save);
  int (*Restore)(class CBubbling* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CBubbling* p);
};
class __base(CBaseEntity, 0) CBubbling __packed
{
  struct vtable_for_CBubbling* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT FizzThink( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_density;
	int		m_frequency;
	int		m_bubbleModel;
	int		m_state;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CBlood
{
};
class __base(CPointEntity, 0) CBlood __packed
{
  struct vtable_for_CBlood* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	int		Color( void ) ;
	inline	float 	BloodAmount( void ) ;
	inline	void SetColor( int color ) ;
	inline	void SetBloodAmount( float amount ) ;
	Vector	Direction( void );
	Vector	BloodPosition( CBaseEntity *pActivator );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CShake
{
};
class __base(CPointEntity, 0) CShake __packed
{
  struct vtable_for_CShake* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	float	Amplitude( void ) ;
	inline	float	Frequency( void ) ;
	inline	float	Duration( void ) ;
	inline	float	Radius( void ) ;
	inline	void	SetAmplitude( float amplitude ) ;
	inline	void	SetFrequency( float frequency ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetRadius( float radius ) ;
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CFade
{
};
class __base(CPointEntity, 0) CFade __packed
{
  struct vtable_for_CFade* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	float	Duration( void ) ;
	inline	float	HoldTime( void ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetHoldTime( float hold ) ;
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CMessage
{
};
class __base(CPointEntity, 0) CMessage __packed
{
  struct vtable_for_CMessage* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CSprite
{
  int (*Save)(class CSprite* p, CSave & save);
  int (*Restore)(class CSprite* p, CRestore & restore);
};
class __base(CPointEntity, 0) CSprite __packed
{
  struct vtable_for_CSprite* vtable;
public:
	void Spawn( void );
	void Precache( void );
	fcap_t		ObjectCaps( void );
	void EXPORT AnimateThink( void );
	void EXPORT ExpandThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void Animate( float frames );
	void Expand( float scaleSpeed, float fadeSpeed );
	void SpriteInit( const char *pSpriteName, const Vector &origin );
	inline void SetAttachment( edict_t *pEntity, int attachment );
	void TurnOff( void );
	void TurnOn( void );
	inline float Frames( void ) ;
	inline void SetTransparency( int rendermode, int r, int g, int b, int a, int fx );
	inline void SetTexture( int spriteIndex ) ;
	inline void SetScale( float scale ) ;
	inline void SetColor( int r, int g, int b ) ;
	inline void SetBrightness( int brightness ) ;
	inline void AnimateAndDie( float framerate ) ;
	void EXPORT AnimateUntilDead( void );
	static	TYPEDESCRIPTION m_SaveData[];
	static CSprite *SpriteCreate( const char *pSpriteName, const Vector &origin, BOOL animate );
private:
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBeam
{
};
class __base(CBaseEntity, 0) CBeam __packed
{
  struct vtable_for_CBeam* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	fcap_t		ObjectCaps( void );
	void EXPORT TriggerTouch( CBaseEntity *pOther );
	inline void	SetType( int type ) ;
	inline void	SetFlags( beamf_t flags ) ;
	inline void SetStartPos( const Vector& pos ) ;
	inline void SetEndPos( const Vector& pos ) ;
	void SetStartEntity( int entityIndex );
	void SetEndEntity( int entityIndex );
	inline void SetStartAttachment( int attachment ) ;
	inline void SetEndAttachment( int attachment ) ;
	inline void SetTexture( int spriteIndex ) ;
	inline void SetWidth( int width ) ;
	inline void SetNoise( int amplitude ) ;
	inline void SetColor( int r, int g, int b ) ;
	inline void SetBrightness( int brightness ) ;
	inline void SetFrame( float frame ) ;
	inline void SetScrollRate( int speed ) ;
	inline int	GetType( void ) ;
	inline int	GetFlags( void ) ;
	inline int	GetStartEntity( void ) ;
	inline int	GetEndEntity( void ) ;
	const Vector &GetStartPos( void );
	const Vector &GetEndPos( void );
	Vector Center( void ) ;
	inline int  GetTexture( void ) ;
	inline int  GetWidth( void ) ;
	inline int  GetNoise( void ) ;
	inline int  GetBrightness( void ) ;
	inline int  GetFrame( void ) ;
	inline int  GetScrollRate( void ) ;
	void		RelinkBeam( void );
	void		DoSparks( const Vector &start, const Vector &end );
	CBaseEntity *RandomTargetname( const char *szName );
	void		BeamDamage( TraceResult *ptr );
	void		BeamInit( const char *pSpriteName, int width );
	void		PointsInit( const Vector &start, const Vector &end );
	void		PointEntInit( const Vector &start, int endIndex );
	void		EntsInit( int startIndex, int endIndex );
	void		HoseInit( const Vector &start, const Vector &direction );
	static CBeam *BeamCreate( const char *pSpriteName, int width );
	inline void LiveForTime( float time ) ;
	inline void	BeamDamageInstant( TraceResult *ptr, float damage ) ;
};
struct __base(vtable_for_CBeam, 0) __data_var_refs vtable_for_CLaser
{
  int (*Save)(class CLaser* p, CSave & save);
  int (*Restore)(class CLaser* p, CRestore & restore);
};
class __base(CBeam, 0) CLaser __packed
{
  struct vtable_for_CLaser* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	TurnOn( void );
	void	TurnOff( void );
	int		IsOn( void );
	void	FireAtPoint( TraceResult &point );
	void	EXPORT StrikeThink( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	CSprite	*m_pSprite;
	int		m_iszSpriteName;
	Vector  m_firePosition;
};
struct __base(vtable_for_CBeam, 0) __data_var_refs vtable_for_CLightning
{
  int (*Save)(class CLightning* p, CSave & save);
  int (*Restore)(class CLightning* p, CRestore & restore);
};
class __base(CBeam, 0) CLightning __packed
{
  struct vtable_for_CLightning* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Activate( void );
	void	EXPORT StrikeThink( void );
	void	EXPORT DamageThink( void );
	void	RandomArea( void );
	void	RandomPoint( Vector &vecSrc );
	void	Zap( const Vector &vecSrc, const Vector &vecDest );
	void	EXPORT StrikeUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT ToggleUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL ServerSide( void );
	static	TYPEDESCRIPTION m_SaveData[];
	void	BeamUpdateVars( void );
	int		m_active;
	int		m_iszStartEntity;
	int		m_iszEndEntity;
	float	m_life;
	int		m_boltWidth;
	int		m_noiseAmplitude;
	int		m_brightness;
	int		m_speed;
	float	m_restrike;
	int		m_spriteTexture;
	int		m_iszSpriteName;
	int		m_frameStart;
	float	m_radius;
};
struct __base(vtable_for_CLightning, 0) __data_var_refs vtable_for_CTripBeam
{
};
class __base(CLightning, 0) CTripBeam __packed
{
  struct vtable_for_CTripBeam* vtable;
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CGlow
{
  int (*Save)(class CGlow* p, CSave & save);
  int (*Restore)(class CGlow* p, CRestore & restore);
};
class __base(CPointEntity, 0) CGlow __packed
{
  struct vtable_for_CGlow* vtable;
public:
	void Spawn( void );
	void Think( void );
	void Animate( float frames );
	static	TYPEDESCRIPTION m_SaveData[];
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CShower
{
};
class __base(CBaseEntity, 0) CShower __packed
{
  struct vtable_for_CShower* vtable;
	void Spawn( void );
	void Think( void );
	void Touch( CBaseEntity *pOther );
	fcap_t ObjectCaps( void ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CRenderFxManager
{
};
class __base(CBaseEntity, 0) CRenderFxManager __packed
{
  struct vtable_for_CRenderFxManager* vtable;
public:
	void Spawn( void );
	void Use ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBaseDelay
{
  void  (*KeyValue)(class CBaseDelay* p, KeyValueData * pkvd);
  int (*Save)(class CBaseDelay* p, CSave & save);
  int (*Restore)(class CBaseDelay* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CBaseDelay __packed
{
  struct vtable_for_CBaseDelay* vtable;
public:
	float		m_flDelay;
	int			m_iszKillTarget;
	static	TYPEDESCRIPTION m_SaveData[];
	void SUB_UseTargets( CBaseEntity *pActivator, USE_TYPE useType, float value );
	void EXPORT DelayThink( void );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTestEffect
{
};
class __base(CBaseDelay, 0) CTestEffect __packed
{
  struct vtable_for_CTestEffect* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void EXPORT TestThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		m_iLoop;
	int		m_iBeam;
	CBeam	*m_pBeam[24];
	float	m_flBeamTime[24];
	float	m_flStartTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CAutoTrigger
{
  int (*Save)(class CAutoTrigger* p, CSave & save);
  int (*Restore)(class CAutoTrigger* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CAutoTrigger __packed
{
  struct vtable_for_CAutoTrigger* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Precache( void );
	void Think( void );
	fcap_t ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int			m_globalstate;
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerRelay
{
  int (*Save)(class CTriggerRelay* p, CSave & save);
  int (*Restore)(class CTriggerRelay* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CTriggerRelay __packed
{
  struct vtable_for_CTriggerRelay* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	fcap_t ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CBreakable
{
  int (*TakeDamage)(class CBreakable* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, dmg_t bitsDamageType);
  fcap_t (*ObjectCaps)(class CBreakable* p);
  int (*Save)(class CBreakable* p, CSave & save);
  int (*Restore)(class CBreakable* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CBreakable __packed
{
  struct vtable_for_CBreakable* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData* pkvd);
	void EXPORT BreakTouch( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void DamageSound( void );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType );
	BOOL IsBreakable( void );
	BOOL SparkWhenHit( void );
	int	 DamageDecal( dmg_t bitsDamageType );
	void EXPORT		Die( void );
	inline BOOL		Explodable( void ) ;
	inline int		ExplosionMagnitude( void ) ;
	inline void		ExplosionSetMagnitude( int magnitude ) ;
	static void MaterialSoundPrecache( Materials precacheMaterial );
	static void MaterialSoundRandom( edict_t *pEdict, Materials soundMaterial, float volume );
	static const char **MaterialSoundList( Materials precacheMaterial, int &soundCount );
	static const char *pSoundsWood[];
	static const char *pSoundsFlesh[];
	static const char *pSoundsGlass[];
	static const char *pSoundsMetal[];
	static const char *pSoundsConcrete[];
	static const char *pSpawnObjects[];
	static	TYPEDESCRIPTION m_SaveData[];
	Materials	m_Material;
	Explosions	m_Explosion;
	int			m_idShard;
	float		m_angle;
	int			m_iszGibModel;
	int			m_iszSpawnObject;
};
struct __base(vtable_for_CBreakable, 0) __data_var_refs vtable_for_CPushable
{
  fcap_t (*ObjectCaps)(class CPushable* p);
  int (*Save)(class CPushable* p, CSave & save);
  int (*Restore)(class CPushable* p, CRestore & restore);
  int (*TakeDamage)(class CPushable* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, dmg_t bitsDamageType);
};
class __base(CBreakable, 0) CPushable __packed
{
  struct vtable_for_CPushable* vtable;
public:
	void	Spawn ( void );
	void	Precache( void );
	void	Touch ( CBaseEntity *pOther );
	void	Move( CBaseEntity *pMover, int push );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT StopSound( void );
	inline float MaxSpeed( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	static char *m_soundNames[3];
	int		m_lastSound;
	float	m_maxSpeed;
	float	m_soundTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CEnvFunnel
{
};
class __base(CBaseDelay, 0) CEnvFunnel __packed
{
  struct vtable_for_CEnvFunnel* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int		m_iSprite;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CEnvBeverage
{
};
class __base(CBaseDelay, 0) CEnvBeverage __packed
{
  struct vtable_for_CEnvBeverage* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CItemSoda
{
};
class __base(CBaseEntity, 0) CItemSoda __packed
{
  struct vtable_for_CItemSoda* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	EXPORT CanThink ( void );
	void	EXPORT CanTouch ( CBaseEntity *pOther );
};
typedef struct
{
	int			event;
	char		*options;
} MonsterEvent_t;
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CBaseAnimating
{
  int (*Save)(class CBaseAnimating* p, CSave & save);
  int (*Restore)(class CBaseAnimating* p, CRestore & restore);
  void (*HandleAnimEvent)(class CBaseAnimating* p, MonsterEvent_t * pEvent);
};
class __base(CBaseDelay, 0) CBaseAnimating __packed
{
  struct vtable_for_CBaseAnimating* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	float StudioFrameAdvance( float flInterval = 0.0 );
	int	 GetSequenceFlags( void );
	int  LookupActivity ( int activity );
	int  LookupActivityHeaviest ( int activity );
	int  LookupSequence ( const char *label );
	void ResetSequenceInfo ( );
	void DispatchAnimEvents ( float flFutureInterval = 0.1 );
	float SetBoneController ( int iController, float flValue );
	void InitBoneControllers ( void );
	float SetBlending ( int iBlender, float flValue );
	void GetBonePosition ( int iBone, Vector &origin, Vector &angles );
	void GetAutomovement( Vector &origin, Vector &angles, float flInterval = 0.1 );
	int  FindTransition( int iEndingSequence, int iGoalSequence, int *piDir );
	void GetAttachment ( int iAttachment, Vector &origin, Vector &angles );
	void SetBodygroup( int iGroup, int iValue );
	int GetBodygroup( int iGroup );
	int ExtractBbox( int sequence, float *mins, float *maxs );
	void SetSequenceBox( void );
	float				m_flFrameRate;
	float				m_flGroundSpeed;
	float				m_flLastEventCheck;
	BOOL				m_fSequenceFinished;
	BOOL				m_fSequenceLoops;
};
typedef enum
	{
	TS_AT_TOP,
	TS_AT_BOTTOM,
	TS_GOING_UP,
	TS_GOING_DOWN
	} TOGGLE_STATE;
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CBaseToggle
{
  int (*Save)(class CBaseToggle* p, CSave & save);
  int (*Restore)(class CBaseToggle* p, CRestore & restore);
  int (*GetToggleState)(class CBaseToggle* p);
  float (*GetDelay)(class CBaseToggle* p);
};
class __base(CBaseAnimating, 0) CBaseToggle __packed
{
  struct vtable_for_CBaseToggle* vtable;
public:
	void				KeyValue( KeyValueData *pkvd );
	TOGGLE_STATE		m_toggle_state;
	float				m_flActivateFinished;
	float				m_flMoveDistance;
	float				m_flWait;
	float				m_flLip;
	float				m_flTWidth;
	float				m_flTLength;
	Vector				m_vecPosition1;
	Vector				m_vecPosition2;
	Vector				m_vecAngle1;
	Vector				m_vecAngle2;
	int					m_cTriggersLeft;
	float				m_flHeight;
	EHANDLE				m_hActivator;
  // TODO: Binary ninja does not seem to recognize member function pointer definitions.
	//void (CBaseToggle::*m_pfnCallWhenMoveDone)(void);
	void (*m_pfnCallWhenMoveDone)(void);
	Vector				m_vecFinalDest;
	Vector				m_vecFinalAngle;
	int					m_bitsDamageInflict;
	static	TYPEDESCRIPTION m_SaveData[];
	void LinearMove( Vector	vecDest, float flSpeed );
	void EXPORT LinearMoveDone( void );
	void AngularMove( Vector vecDestAngle, float flSpeed );
	void EXPORT AngularMoveDone( void );
	BOOL IsLockedByMaster( void );
	static float		AxisValue( int flags, const Vector &angles );
	static void			AxisDir( entvars_t *pev );
	static float		AxisDelta( int flags, const Vector &angle1, const Vector &angle2 );
	string_t m_sMaster;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMultiManager
{
  int (*Save)(class CMultiManager* p, CSave & save);
  int (*Restore)(class CMultiManager* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMultiManager __packed
{
  struct vtable_for_CMultiManager* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn ( void );
	void EXPORT ManagerThink ( void );
	void EXPORT ManagerUse   ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
#if _DEBUG
	void EXPORT ManagerReport( void );
#endif
	BOOL		HasTarget( string_t targetname );
	fcap_t ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_cTargets;
	int		m_index;
	float	m_startTime;
	int		m_iTargetName	[ MAX_MULTI_TARGETS ];
	float	m_flTargetDelay [ MAX_MULTI_TARGETS ];
private:
	inline BOOL IsClone( void ) ;
	inline BOOL ShouldClone( void );
	CMultiManager *Clone( void );
};
typedef struct locksounds
{
	string_t	sLockedSound;
	string_t	sLockedSentence;
	string_t	sUnlockedSound;
	string_t	sUnlockedSentence;
	int		iLockedSentence;
	int		iUnlockedSentence;
	float	flwaitSound;
	float	flwaitSentence;
	BYTE	bEOFLocked;
	BYTE	bEOFUnlocked;
} locksound_t;
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseButton
{
  void (*Precache)(class CBaseButton* p);
  void (*KeyValue)(class CBaseButton* p, KeyValueData * pkvd);
  int (*TakeDamage)(class CBaseButton* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, dmg_t bitsDamageType);
  int (*Save)(class CBaseButton* p, CSave & save);
  int (*Restore)(class CBaseButton* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CBaseButton* p);
};
class __base(CBaseToggle, 0) CBaseButton __packed
{
  struct vtable_for_CBaseButton* vtable;
public:
	void Spawn( void );
	void RotSpawn( void );
	void ButtonActivate( );
	void SparkSoundCache( void );
	void EXPORT ButtonShot( void );
	void EXPORT ButtonTouch( CBaseEntity *pOther );
	void EXPORT ButtonSpark ( void );
	void EXPORT TriggerAndWait( void );
	void EXPORT ButtonReturn( void );
	void EXPORT ButtonBackHome( void );
	void EXPORT ButtonUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	enum BUTTON_CODE { BUTTON_NOTHING, BUTTON_ACTIVATE, BUTTON_RETURN };
	BUTTON_CODE	ButtonResponseToTouch( void );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL	m_fStayPushed;
	BOOL	m_fRotating;
	string_t m_strChangeTarget;
	locksound_t m_ls;
	BYTE	m_bLockedSound;
	BYTE	m_bLockedSentence;
	BYTE	m_bUnlockedSound;
	BYTE	m_bUnlockedSentence;
	int		m_sounds;
};
typedef enum {
	ACT_RESET = 0,
	ACT_IDLE = 1,
	ACT_GUARD,
	ACT_WALK,
	ACT_RUN,
	ACT_FLY,
	ACT_SWIM,
	ACT_HOP,
	ACT_LEAP,
	ACT_FALL,
	ACT_LAND,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_TWITCH,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_ARM,
	ACT_DISARM,
	ACT_EAT,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_SLEEP,
	ACT_INSPECT_FLOOR,
	ACT_INSPECT_WALL,
	ACT_IDLE_ANGRY,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_FLY_LEFT,
	ACT_FLY_RIGHT,
	ACT_DETECT_SCENT,
	ACT_SNIFF,
	ACT_BITE,
	ACT_THREAT_DISPLAY,
	ACT_FEAR_DISPLAY,
	ACT_EXCITED,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
} Activity;
typedef enum
{
	MONSTERSTATE_NONE = 0,
	MONSTERSTATE_IDLE,
	MONSTERSTATE_COMBAT,
	MONSTERSTATE_ALERT,
	MONSTERSTATE_HUNT,
	MONSTERSTATE_PRONE,
	MONSTERSTATE_SCRIPT,
	MONSTERSTATE_PLAYDEAD,
	MONSTERSTATE_DEAD
} MONSTERSTATE;
typedef struct {
	int	type;
	char *name;
} activity_map_t;
enum SCHEDULE_TYPE : int32_t
{
		SCHED_NONE = 0,
		SCHED_IDLE_STAND,
		SCHED_IDLE_WALK,
		SCHED_WAKE_ANGRY,
		SCHED_WAKE_CALLED,
		SCHED_ALERT_FACE,
		SCHED_ALERT_SMALL_FLINCH,
		SCHED_ALERT_BIG_FLINCH,
		SCHED_ALERT_STAND,
		SCHED_INVESTIGATE_SOUND,
		SCHED_COMBAT_FACE,
		SCHED_COMBAT_STAND,
		SCHED_CHASE_ENEMY,
		SCHED_CHASE_ENEMY_FAILED,
		SCHED_VICTORY_DANCE,
		SCHED_TARGET_FACE,
		SCHED_TARGET_CHASE,
		SCHED_SMALL_FLINCH,
		SCHED_TAKE_COVER_FROM_ENEMY,
		SCHED_TAKE_COVER_FROM_BEST_SOUND,
		SCHED_TAKE_COVER_FROM_ORIGIN,
		SCHED_COWER,
		SCHED_MELEE_ATTACK1,
		SCHED_MELEE_ATTACK2,
		SCHED_RANGE_ATTACK1,
		SCHED_RANGE_ATTACK2,
		SCHED_SPECIAL_ATTACK1,
		SCHED_SPECIAL_ATTACK2,
		SCHED_STANDOFF,
		SCHED_ARM_WEAPON,
		SCHED_RELOAD,
		SCHED_GUARD,
		SCHED_AMBUSH,
		SCHED_DIE,
		SCHED_WAIT_TRIGGER,
		SCHED_FOLLOW,
		SCHED_SLEEP,
		SCHED_WAKE,
		SCHED_BARNACLE_VICTIM_GRAB,
		SCHED_BARNACLE_VICTIM_CHOMP,
		SCHED_AISCRIPT,
		SCHED_FAIL,
		LAST_COMMON_SCHEDULE
};
enum SHARED_TASKS : int32_t
{
		TASK_INVALID = 0,
		TASK_WAIT,
		TASK_WAIT_FACE_ENEMY,
		TASK_WAIT_PVS,
		TASK_SUGGEST_STATE,
		TASK_WALK_TO_TARGET,
		TASK_RUN_TO_TARGET,
		TASK_MOVE_TO_TARGET_RANGE,
		TASK_GET_PATH_TO_ENEMY,
		TASK_GET_PATH_TO_ENEMY_LKP,
		TASK_GET_PATH_TO_ENEMY_CORPSE,
		TASK_GET_PATH_TO_LEADER,
		TASK_GET_PATH_TO_SPOT,
		TASK_GET_PATH_TO_TARGET,
		TASK_GET_PATH_TO_HINTNODE,
		TASK_GET_PATH_TO_LASTPOSITION,
		TASK_GET_PATH_TO_BESTSOUND,
		TASK_GET_PATH_TO_BESTSCENT,
		TASK_RUN_PATH,
		TASK_WALK_PATH,
		TASK_STRAFE_PATH,
		TASK_CLEAR_MOVE_WAIT,
		TASK_STORE_LASTPOSITION,
		TASK_CLEAR_LASTPOSITION,
		TASK_PLAY_ACTIVE_IDLE,
		TASK_FIND_HINTNODE,
		TASK_CLEAR_HINTNODE,
		TASK_SMALL_FLINCH,
		TASK_FACE_IDEAL,
		TASK_FACE_ROUTE,
		TASK_FACE_ENEMY,
		TASK_FACE_HINTNODE,
		TASK_FACE_TARGET,
		TASK_FACE_LASTPOSITION,
		TASK_RANGE_ATTACK1,
		TASK_RANGE_ATTACK2,
		TASK_MELEE_ATTACK1,
		TASK_MELEE_ATTACK2,
		TASK_RELOAD,
		TASK_RANGE_ATTACK1_NOTURN,
		TASK_RANGE_ATTACK2_NOTURN,
		TASK_MELEE_ATTACK1_NOTURN,
		TASK_MELEE_ATTACK2_NOTURN,
		TASK_RELOAD_NOTURN,
		TASK_SPECIAL_ATTACK1,
		TASK_SPECIAL_ATTACK2,
		TASK_CROUCH,
		TASK_STAND,
		TASK_GUARD,
		TASK_STEP_LEFT,
		TASK_STEP_RIGHT,
		TASK_STEP_FORWARD,
		TASK_STEP_BACK,
		TASK_DODGE_LEFT,
		TASK_DODGE_RIGHT,
		TASK_SOUND_ANGRY,
		TASK_SOUND_DEATH,
		TASK_SET_ACTIVITY,
		TASK_SET_SCHEDULE,
		TASK_SET_FAIL_SCHEDULE,
		TASK_CLEAR_FAIL_SCHEDULE,
		TASK_PLAY_SEQUENCE,
		TASK_PLAY_SEQUENCE_FACE_ENEMY,
		TASK_PLAY_SEQUENCE_FACE_TARGET,
		TASK_SOUND_IDLE,
		TASK_SOUND_WAKE,
		TASK_SOUND_PAIN,
		TASK_SOUND_DIE,
		TASK_FIND_COVER_FROM_BEST_SOUND,
		TASK_FIND_COVER_FROM_ENEMY,
		TASK_FIND_LATERAL_COVER_FROM_ENEMY,
		TASK_FIND_NODE_COVER_FROM_ENEMY,
		TASK_FIND_NEAR_NODE_COVER_FROM_ENEMY,
		TASK_FIND_FAR_NODE_COVER_FROM_ENEMY,
		TASK_FIND_COVER_FROM_ORIGIN,
		TASK_EAT,
		TASK_DIE,
		TASK_WAIT_FOR_SCRIPT,
		TASK_PLAY_SCRIPT,
		TASK_ENABLE_SCRIPT,
		TASK_PLANT_ON_SCRIPT,
		TASK_FACE_SCRIPT,
		TASK_WAIT_RANDOM,
		TASK_WAIT_INDEFINITE,
		TASK_STOP_MOVING,
		TASK_TURN_LEFT,
		TASK_TURN_RIGHT,
		TASK_REMEMBER,
		TASK_FORGET,
		TASK_WAIT_FOR_MOVEMENT,
		LAST_COMMON_TASK,
};
struct Task_t
{
	SHARED_TASKS		iTask;
	float	flData;
};
struct Schedule_t
{
	Task_t	*pTasklist;
	int		cTasks;
	bitscond_t		iInterruptMask;
	bitssound_t		iSoundMask;
	const	char *pName;
};
struct WayPoint_t
{
	Vector	vecLocation;
	bitsmf_t		iType;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseMonster
{
  int (*Save)(class CBaseMonster* p, CSave &save);
  int (*Restore)(class CBaseMonster* p, CRestore &restore);
  bloodcolor_t (*BloodColor)(class CBaseMonster* p);
  CBaseMonster *(*MyMonsterPointer)(class CBaseMonster* p);
  void (*Look)(class CBaseMonster* p, int iDistance);
  void (*RunAI)(class CBaseMonster* p);
  BOOL (*IsAlive)(class CBaseMonster* p);
  BOOL (*ShouldFadeOnDeath)(class CBaseMonster* p);
  float (*ChangeYaw)(class CBaseMonster* p, int speed);
  void (*MonsterThink)(class CBaseMonster* p);
  disposition_t (*IRelationship)(class CBaseMonster* p, CBaseEntity *pTarget);
  void (*MonsterInit)(class CBaseMonster* p);
  void (*MonsterInitDead)(class CBaseMonster* p);
  void (*BecomeDead)(class CBaseMonster* p);
  void (*StartMonster)(class CBaseMonster* p);
  CBaseEntity* (*BestVisibleEnemy)(class CBaseMonster* p);
  BOOL (*FInViewCone)(class CBaseMonster* p, CBaseEntity *pEntity);
  BOOL (*FInViewCone2)(class CBaseMonster* p, Vector *pOrigin); // Was originally named FInViewCone
  void (*HandleAnimEvent)(class CBaseMonster* p, MonsterEvent_t *pEvent);
  localmove_t (*CheckLocalMove)(class CBaseMonster* p, const Vector &vecStart, const Vector &vecEnd, CBaseEntity *pTarget, float *pflDist);
  void (*Move)(class CBaseMonster* p, float flInterval);
  void (*MoveExecute)(class CBaseMonster* p, CBaseEntity *pTargetEnt, const Vector &vecDir, float flInterval);
  BOOL (*ShouldAdvanceRoute)(class CBaseMonster* p, float flWaypointDist);
  Activity (*GetStoppedActivity)(class CBaseMonster* p);
  void (*Stop)(class CBaseMonster* p);
  BOOL (*CheckRangeAttack1)(class CBaseMonster* p, float flDot, float flDist);
  BOOL (*CheckRangeAttack2)(class CBaseMonster* p, float flDot, float flDist);
  BOOL (*CheckMeleeAttack1)(class CBaseMonster* p, float flDot, float flDist);
  BOOL (*CheckMeleeAttack2)(class CBaseMonster* p, float flDot, float flDist);
  Schedule_t *(*ScheduleFromName)(class CBaseMonster* p, const char *pName);
  void (*StartTask)(class CBaseMonster* p, Task_t *pTask);
  void (*RunTask)(class CBaseMonster* p, Task_t *pTask);
  Schedule_t *(*GetScheduleOfType)(class CBaseMonster* p, SCHEDULE_TYPE Type);
  Schedule_t *(*GetSchedule)(class CBaseMonster* p);
  void (*ScheduleChange)(class CBaseMonster* p);
  int (*CanPlaySequence)(class CBaseMonster* p, BOOL fDisregardState, int interruptLevel);
  int (*CanPlaySentence)(class CBaseMonster* p, BOOL fDisregardState);
  void (*PlaySentence)(class CBaseMonster* p, const char *pszSentence, float duration, float volume, float attenuation);
  void (*PlayScriptedSentence)(class CBaseMonster* p, const char *pszSentence, float duration, float volume, float attenuation, BOOL bConcurrent, CBaseEntity *pListener);
  void (*SentenceStop)(class CBaseMonster* p);
  MONSTERSTATE (*GetIdealState)(class CBaseMonster* p);
  void (*SetActivity)(class CBaseMonster* p, Activity NewActivity);
  void (*ReportAIState)(class CBaseMonster* p);
  int (*CheckEnemy)(class CBaseMonster* p, CBaseEntity *pEnemy);
  BOOL (*FTriangulate)(class CBaseMonster* p, const Vector &vecStart , const Vector &vecEnd, float flDist, CBaseEntity *pTargetEnt, Vector *pApex);
  void (*SetYawSpeed)(class CBaseMonster* p);
  BOOL (*BuildNearestRoute)(class CBaseMonster* p, Vector vecThreat, Vector vecViewOffset, float flMinDist, float flMaxDist);
  BOOL (*FindCover)(class CBaseMonster* p, Vector vecThreat, Vector vecViewOffset, float flMinDist, float flMaxDist);
  BOOL (*FValidateCover)(class CBaseMonster* p, const Vector &vecCoverLocation);
  float (*CoverRadius)(class CBaseMonster* p);
  BOOL (*FCanCheckAttacks)(class CBaseMonster* p);
  void (*CheckAmmo)(class CBaseMonster* p);
  bitscond_t (*IgnoreConditions)(class CBaseMonster* p);
  BOOL (*FValidateHintType)(class CBaseMonster* p, short sHint);
  BOOL (*FCanActiveIdle)(class CBaseMonster* p);
  bitssound_t (*ISoundMask)(class CBaseMonster* p);
  CSound* (*PBestSound)(class CBaseMonster* p);
  CSound* (*PBestScent)(class CBaseMonster* p);
  float (*HearingSensitivity)(class CBaseMonster* p);
  void (*BarnacleVictimBitten)(class CBaseMonster* p, entvars_t *pevBarnacle);
  void (*BarnacleVictimReleased)(class CBaseMonster* p);
  void (*PrescheduleThink)(class CBaseMonster* p);
  Activity (*GetDeathActivity)(class CBaseMonster* p);
  void (*Killed)(class CBaseMonster* p, entvars_t *pevAttacker, gib_t iGib);
  void (*GibMonster)(class CBaseMonster* p);
  BOOL (*HasHumanGibs)(class CBaseMonster* p);
  BOOL (*HasAlienGibs)(class CBaseMonster* p);
  void (*FadeMonster)(class CBaseMonster* p);
  Vector (*BodyTarget)(class CBaseMonster* p, const Vector &posSrc);
  Vector  (*GetGunPosition)(class CBaseMonster* p);
  int (*TakeHealth)(class CBaseMonster* p, float flHealth, dmg_t bitsDamageType);
  int (*TakeDamage)(class CBaseMonster* p, entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType);
  int (*IsMoving)(class CBaseMonster* p);
  void (*DeathSound)(class CBaseMonster* p);
  void (*AlertSound)(class CBaseMonster* p);
  void (*IdleSound)(class CBaseMonster* p);
  void (*PainSound)(class CBaseMonster* p);
  void (*StopFollowing)(class CBaseMonster* p, BOOL clearSchedule);
};
class __base(CBaseToggle, 0) CBaseMonster __packed
{
  struct vtable_for_CBaseMonster* vtable;
private:
		bitscond_t					m_afConditions;
public:
		typedef enum
		{
			SCRIPT_PLAYING = 0,
			SCRIPT_WAIT,
			SCRIPT_CLEANUP,
			SCRIPT_WALK_TO_MARK,
			SCRIPT_RUN_TO_MARK,
		} SCRIPTSTATE;
		EHANDLE				m_hEnemy;
		EHANDLE				m_hTargetEnt;
		EHANDLE				m_hOldEnemy[ MAX_OLD_ENEMIES ];
		Vector				m_vecOldEnemy[ MAX_OLD_ENEMIES ];
		float				m_flFieldOfView;
		float				m_flWaitFinished;
		float				m_flMoveWaitFinished;
		Activity			m_Activity;
		Activity			m_IdealActivity;
		hitgroup_t					m_LastHitGroup;
		MONSTERSTATE		m_MonsterState;
		MONSTERSTATE		m_IdealMonsterState;
		taskstatus_t					m_iTaskStatus;
		Schedule_t			*m_pSchedule;
		int					m_iScheduleIndex;
		WayPoint_t			m_Route[ ROUTE_SIZE ];
		movegoal_t					m_movementGoal;
		int					m_iRouteIndex;
		float				m_moveWaitTime;
		Vector				m_vecMoveGoal;
		Activity			m_movementActivity;
		int					m_iAudibleList;
		int					m_afSoundTypes;
		Vector				m_vecLastPosition;
		int					m_iHintNode;
		bitsmemory_t					m_afMemory;
		int					m_iMaxHealth;
	Vector				m_vecEnemyLKP;
	int					m_cAmmoLoaded;
	bitscap_t					m_afCapability;
	float				m_flNextAttack;
	dmg_t					m_bitsDamageType;
	BYTE				m_rgbTimeBasedDamage[CDMG_TIMEBASED];
	int					m_lastDamageAmount;
	bloodcolor_t					m_bloodColor;
	SCHEDULE_TYPE					m_failSchedule;
	float				m_flHungryTime;
	float				m_flDistTooFar;
	float				m_flDistLook;
	aitrigger_t					m_iTriggerCondition;
	string_t			m_iszTriggerTarget;
	Vector				m_HackedGunPos;
	SCRIPTSTATE			m_scriptState;
	CCineMonster		*m_pCine;
	static	TYPEDESCRIPTION m_SaveData[];
	void KeyValue( KeyValueData *pkvd );
	void EXPORT			MonsterUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT			CorpseUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void Listen ( void );
	float VecToYaw( Vector vecDir );
	float FlYawDiff ( void );
	float DamageForce( float damage );
		void EXPORT	CallMonsterThink( void );
		void EXPORT CorpseFallThink( void );
		void EXPORT MonsterInitThink ( void );
		inline void StopAnimation( void );
		BOOL FHaveSchedule( void );
		BOOL FScheduleValid ( void );
		void ClearSchedule( void );
		BOOL FScheduleDone ( void );
		void ChangeSchedule ( Schedule_t *pNewSchedule );
		void NextScheduledTask ( void );
		Schedule_t *ScheduleInList( const char *pName, Schedule_t **pList, int listCount );
		static Schedule_t *m_scheduleList[];
		void MaintainSchedule ( void );
		Task_t *GetTask ( void );
		void SetSequenceByName ( char *szSequence );
		void SetState ( MONSTERSTATE State );
		void CheckAttacks ( CBaseEntity *pTarget, float flDist );
		void PushEnemy( CBaseEntity *pEnemy, Vector &vecLastKnownPos );
		BOOL PopEnemy( void );
		BOOL FGetNodeRoute ( Vector vecDest );
		inline void TaskComplete( void );
		void MovementComplete( void );
		inline void TaskFail( void );
		inline void TaskBegin( void );
		int TaskIsRunning( void );
		inline int TaskIsComplete( void );
		inline int MovementIsComplete( void );
		int IScheduleFlags ( void );
		BOOL FRefreshRoute( void );
		BOOL FRouteClear ( void );
		void RouteSimplify( CBaseEntity *pTargetEnt );
		void AdvanceRoute ( float distance );
		void MakeIdealYaw( Vector vecTarget );
		BOOL BuildRoute ( const Vector &vecGoal, bitsmf_t iMoveFlag, CBaseEntity *pTarget );
		int RouteClassify( bitsmf_t iMoveFlag );
		void InsertWaypoint ( Vector vecLocation, bitsmf_t afMoveFlags );
		BOOL FindLateralCover ( const Vector &vecThreat, const Vector &vecViewOffset );
		inline void	SetConditions( bitscond_t iConditions );
		inline void	ClearConditions( bitscond_t iConditions );
		inline BOOL HasConditions( bitscond_t iConditions );
		inline BOOL HasAllConditions( bitscond_t iConditions );
		int FindHintNode ( void );
		void SetTurnActivity ( void );
		float FLSoundVolume ( CSound *pSound );
		BOOL MoveToNode( Activity movementAct, float waitTime, const Vector &goal );
		BOOL MoveToTarget( Activity movementAct, float waitTime );
		BOOL MoveToLocation( Activity movementAct, float waitTime, const Vector &goal );
		BOOL MoveToEnemy( Activity movementAct, float waitTime );
		float	OpenDoorAndWait( entvars_t *pevDoor );
		BOOL FBecomeProne ( void );
		void SetEyePosition ( void );
		BOOL FShouldEat( void );
		void Eat ( float flFullDuration );
		CBaseEntity *CheckTraceHullAttack( float flDist, int iDamage, int iDmgType );
		BOOL FacingIdeal( void );
		BOOL FCheckAITrigger( void );
		BOOL NoFriendlyFire( void );
		BOOL BBoxFlat( void );
		BOOL GetEnemy ( void );
		void MakeDamageBloodDecal ( int cCount, float flNoise, TraceResult *ptr, const Vector &vecDir );
		void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	float UpdateTarget ( entvars_t *pevTarget );
	Activity GetSmallFlinchActivity( void );
	BOOL		 ShouldGibMonster( gib_t iGib );
	void		 CallGibMonster( void );
	Vector ShootAtEnemy( const Vector &shootOrigin );
	int			DeadTakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void RadiusDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, class_t iClassIgnore, dmg_t bitsDamageType );
	void RadiusDamage(Vector vecSrc, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, class_t iClassIgnore, dmg_t bitsDamageType );
	void RouteClear( void );
	void RouteNew( void );
	inline void	Remember( bitsmemory_t iMemory );
	inline void	Forget( bitsmemory_t iMemory );
	inline BOOL HasMemory( bitsmemory_t iMemory );
	inline BOOL HasAllMemories( bitsmemory_t iMemory );
	BOOL ExitScriptedSequence( );
	BOOL CineCleanup( );
	CBaseEntity* DropItem ( char *pszItemName, const Vector &vecPos, const Vector &vecAng );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CSquadMonster
{
  CSquadMonster *(*MySquadMonsterPointer)( class CSquadMonster* p );
};
class __base(CBaseMonster, 0) CSquadMonster __packed
{
  struct vtable_for_CSquadMonster* vtable;
public:
	EHANDLE	m_hSquadLeader;
	EHANDLE	m_hSquadMember[MAX_SQUAD_MEMBERS-1];
	int		m_afSquadSlots;
	float	m_flLastEnemySightTime;
	BOOL	m_fEnemyEluded;
	int		m_iMySlot;
	int  CheckEnemy ( CBaseEntity *pEnemy );
	void StartMonster ( void );
	void VacateSlot( void );
	void ScheduleChange( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	BOOL OccupySlot( int iDesiredSlot );
	BOOL NoFriendlyFire( void );
	CSquadMonster *MySquadLeader( );
	CSquadMonster *MySquadMember( int i );
	int	InSquad ( void );
	int IsLeader ( void );
	int SquadJoin ( int searchRadius );
	int SquadRecruit ( int searchRadius, int maxMembers );
	int	SquadCount( void );
	void SquadRemove( CSquadMonster *pRemove );
	void SquadUnlink( void );
	BOOL SquadAdd( CSquadMonster *pAdd );
	void SquadDisband( void );
	void SquadAddConditions ( bitscond_t iConditions );
	void SquadMakeEnemy ( CBaseEntity *pEnemy );
	void SquadPasteEnemyInfo ( void );
	void SquadCopyEnemyInfo ( void );
	BOOL SquadEnemySplit ( void );
	BOOL SquadMemberInRange( const Vector &vecLocation, float flDist );
	static TYPEDESCRIPTION m_SaveData[];
	int	Save( CSave &save ); 
	int Restore( CRestore &restore );
	BOOL FValidateCover ( const Vector &vecCoverLocation );
	MONSTERSTATE GetIdealState ( void );
	Schedule_t	*GetScheduleOfType ( SCHEDULE_TYPE iType );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CCineMonster
{
  void (*KeyValue)(class CCineMonster* p, KeyValueData *pkvd );
  void (*Use)(class CCineMonster* p,CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
  void (*Blocked)(class CCineMonster* p,CBaseEntity *pOther );
  void (*Touch)(class CCineMonster* p,CBaseEntity *pOther );
  fcap_t	 (*ObjectCaps)(class CCineMonster* p );
  void (*Activate)(class CCineMonster* p );
  int	(*Save)(class CCineMonster* p, CSave &save );
  int	(*Restore)(class CCineMonster* p, CRestore &restore );
  void (*PossessEntity)(class CCineMonster* p );
  BOOL (*StartSequence)(class CCineMonster* p, CBaseMonster *pTarget, int iszSeq, BOOL completeOnEmpty );
  BOOL (*FCanOverrideState)(class CCineMonster* p );
  void (*FixScriptMonsterSchedule)(class CCineMonster* p, CBaseMonster *pMonster );
};
class __base(CBaseMonster, 0) CCineMonster __packed
{
  struct vtable_for_CCineMonster* vtable;
public:
	void Spawn( void );
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT CineThink( void );
	void Pain( void );
	void Die( void );
	void DelayStart( int state );
	BOOL FindEntity( void );
	void ReleaseEntity( CBaseMonster *pEntity );
	void CancelScript( void );
	void SequenceDone ( CBaseMonster *pMonster );
	BOOL	CanInterrupt( void );
	void	AllowInterrupt( BOOL fAllow );
	bitscond_t		IgnoreConditions( void );
	int	m_iszIdle;
	int	m_iszPlay;
	int m_iszEntity;
	int m_fMoveTo;
	int m_iFinishSchedule;
	float m_flRadius;
	float m_flRepeat;
	int m_iDelay;
	float m_startTime;
	int	m_saved_movetype;
	int	m_saved_solid;
	int m_saved_effects;
	BOOL m_interruptable;
};
struct __base(vtable_for_CCineMonster, 0) __data_var_refs vtable_for_CCineAI
{
	 void (*FixScriptMonsterSchedule)(class CCineAI* p, CBaseMonster *pMonster );
};
class __base(CCineMonster, 0) CCineAI __packed
{
  struct vtable_for_CCineAI* vtable;
	BOOL StartSequence( CBaseMonster *pTarget, int iszSeq, BOOL completeOnEmpty );
	void PossessEntity( void );
	BOOL FCanOverrideState ( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBasePlayerAmmo
{
  void (*Spawn)(class CBasePlayerAmmo* p);
  BOOL(*AddAmmo)(class CBasePlayerAmmo* p, CBaseEntity * pOther);
};
class __base(CBaseEntity, 0) CBasePlayerAmmo __packed
{
  struct vtable_for_CBasePlayerAmmo* vtable;
public:
	void EXPORT DefaultTouch( CBaseEntity *pOther );
	CBaseEntity* Respawn( void );
	void EXPORT Materialize( void );
};
typedef struct
{
	int		iSlot;
	int		iPosition;
	const char	*pszAmmo1;
	int		iMaxAmmo1;
	const char	*pszAmmo2;
	int		iMaxAmmo2;
	const char	*pszName;
	int		iMaxClip;
	weapontype_t		iId;
	int		iFlags;
	int		iWeight;
} ItemInfo;
typedef struct
{
	const char *pszName;
	int iId;
} AmmoInfo;
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CBasePlayerItem
{
  void (*SetObjectCollisionBox)( class CBasePlayerItem* p );
  int		(*Save)( class CBasePlayerItem* p,  CSave &save );
  int		(*Restore)( class CBasePlayerItem* p,  CRestore &restore );
  int (*AddToPlayer)( class CBasePlayerItem* p,  CBasePlayer *pPlayer );
  int (*AddDuplicate)( class CBasePlayerItem* p,  CBasePlayerItem *pItem );
  int (*GetItemInfo)( class CBasePlayerItem* p0, ItemInfo *p);
  BOOL (*CanDeploy)( class CBasePlayerItem* p );
  BOOL (*Deploy)( class CBasePlayerItem* p );
  BOOL (*CanHolster)( class CBasePlayerItem* p );
  void (*Holster)( class CBasePlayerItem* p,  int skiplocal );
  void (*UpdateItemInfo)( class CBasePlayerItem* p );
  void (*ItemPreFrame)( class CBasePlayerItem* p );
  void (*ItemPostFrame)( class CBasePlayerItem* p );
  void (*Drop)( class CBasePlayerItem* p );
  void (*Kill)( class CBasePlayerItem* p );
  void (*AttachToPlayer) ( class CBasePlayerItem* p,  CBasePlayer *pPlayer );
  int (*PrimaryAmmoIndex)( class CBasePlayerItem* p );
  int (*SecondaryAmmoIndex)( class CBasePlayerItem* p );
  int (*UpdateClientData)( class CBasePlayerItem* p,  CBasePlayer *pPlayer );
  CBasePlayerItem *(*GetWeaponPtr)( class CBasePlayerItem* p );
  int (*iItemSlot)( class CBasePlayerItem* p );
};
class __base(CBaseAnimating, 0) CBasePlayerItem __packed
{
  struct vtable_for_CBasePlayerItem* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT DestroyItem( void );
	void EXPORT DefaultTouch( CBaseEntity *pOther );
	void EXPORT FallThink ( void );
	void EXPORT Materialize( void );
	void EXPORT AttemptToMaterialize( void );
	CBaseEntity* Respawn ( void );
	void FallInit( void );
	void CheckRespawn( void );
	static ItemInfo ItemInfoArray[ MAX_WEAPONS ];
	static AmmoInfo AmmoInfoArray[ MAX_AMMO_SLOTS ];
	CBasePlayer	*m_pPlayer;
	CBasePlayerItem *m_pNext;
	weapontype_t		m_iId;
	int			iItemPosition( void );
	const char	*pszAmmo1( void );
	int			iMaxAmmo1( void );
	const char	*pszAmmo2( void );
	int			iMaxAmmo2( void );
	const char	*pszName( void );
	int			iMaxClip( void );
	int			iWeight( void );
	int			iFlags( void );
	// int		m_iIdPrimary;
	// int		m_iIdSecondary;
};
typedef struct
{
	CBaseEntity		*pEntity;
	float			amount;
	int				type;
} MULTIDAMAGE;
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CWeaponBox
{
};
class __base(CBaseEntity, 0) CWeaponBox __packed
{
  struct vtable_for_CWeaponBox* vtable;
	void Precache( void );
	void Spawn( void );
	void Touch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	BOOL IsEmpty( void );
	int  GiveAmmo( int iCount, char *szName, int iMax, int *pIndex = NULL );
	void SetObjectCollisionBox( void );
public:
	void EXPORT Kill ( void );
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL HasWeapon( CBasePlayerItem *pCheckItem );
	BOOL PackWeapon( CBasePlayerItem *pWeapon );
	BOOL PackAmmo( int iszName, int iCount );
	CBasePlayerItem	*m_rgpPlayerItems[MAX_ITEM_TYPES];
	int m_rgiszAmmo[MAX_AMMO_SLOTS];
	int	m_rgAmmo[MAX_AMMO_SLOTS];
	int m_cAmmoTypes;
};
struct __base(vtable_for_CBasePlayerItem, 0) __data_var_refs vtable_for_CBasePlayerWeapon
{
  int		(*Save)( class CBasePlayerWeapon* p,  CSave &save );
  int		(*Restore)( class CBasePlayerWeapon* p,  CRestore &restore );
  int (*AddToPlayer)( class CBasePlayerWeapon* p,  CBasePlayer *pPlayer );
  int (*AddDuplicate)( class CBasePlayerWeapon* p,  CBasePlayerItem *pItem );
  int (*ExtractAmmo)( class CBasePlayerWeapon* p,  CBasePlayerWeapon *pWeapon );
  int (*ExtractClipAmmo)( class CBasePlayerWeapon* p,  CBasePlayerWeapon *pWeapon );
  int (*AddWeapon)( class CBasePlayerWeapon* p );
  void (*UpdateItemInfo)( class CBasePlayerWeapon* p );
  BOOL (*PlayEmptySound)( class CBasePlayerWeapon* p );
  void (*ResetEmptySound)( class CBasePlayerWeapon* p );
  void (*SendWeaponAnim)( class CBasePlayerWeapon* p,  int iAnim, int skiplocal );
  BOOL (*CanDeploy)( class CBasePlayerWeapon* p );
  BOOL (*IsUseable)( class CBasePlayerWeapon* p );
  void (*ItemPostFrame)( class CBasePlayerWeapon* p );
  void (*PrimaryAttack)( class CBasePlayerWeapon* p );
  void (*SecondaryAttack)( class CBasePlayerWeapon* p );
  void (*Reload)( class CBasePlayerWeapon* p );
  void (*WeaponIdle)( class CBasePlayerWeapon* p );
  int (*UpdateClientData)( class CBasePlayerWeapon* p,  CBasePlayer *pPlayer );
  void (*RetireWeapon)( class CBasePlayerWeapon* p );
  BOOL (*ShouldWeaponIdle)( class CBasePlayerWeapon* p );
  void (*Holster)( class CBasePlayerWeapon* p,  int skiplocal );
  BOOL (*UseDecrement)( class CBasePlayerWeapon* p );
  CBasePlayerItem *(*GetWeaponPtr)( class CBasePlayerWeapon* p );
};
class __base(CBasePlayerItem, 0) CBasePlayerWeapon __packed
{
  struct vtable_for_CBasePlayerWeapon* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL AddPrimaryAmmo( int iCount, char *szName, int iMaxClip, int iMaxCarry );
	BOOL AddSecondaryAmmo( int iCount, char *szName, int iMaxCarry );
	int m_iPlayEmptySound;
	int m_fFireOnEmpty;
	BOOL DefaultDeploy( char *szViewModel, char *szWeaponModel, int iAnim, char *szAnimExt, int skiplocal = 0 );
	int DefaultReload( int iClipSize, int iAnim, float fDelay );
	int	PrimaryAmmoIndex();
	int	SecondaryAmmoIndex();
	void PrintState( void );
	float	m_flNextPrimaryAttack;
	float	m_flNextSecondaryAttack;
	float	m_flTimeWeaponIdle;
	int		m_iPrimaryAmmoType;
	int		m_iSecondaryAmmoType;
	int		m_iClip;
	int		m_iClientClip;
	int		m_iClientWeaponState;
	int		m_fInReload;
	int		m_iDefaultAmmo;
};
typedef enum
{
	PLAYER_IDLE,
	PLAYER_WALK,
	PLAYER_JUMP,
	PLAYER_SUPERJUMP,
	PLAYER_DIE,
	PLAYER_ATTACK1,
} PLAYER_ANIM;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBasePlayer
{
  void (*Spawn)( class CBasePlayer* p );
  void (*Jump)( class CBasePlayer* p );
  void (*Duck)( class CBasePlayer* p );
  void (*PreThink)( class CBasePlayer* p );
  void (*PostThink)( class CBasePlayer* p );
  Vector (*GetGunPosition)( class CBasePlayer* p );
  int (*TakeHealth)( class CBasePlayer* p,  float flHealth, dmg_t bitsDamageType );
  void (*TraceAttack)( class CBasePlayer* p,  entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
  int (*TakeDamage)( class CBasePlayer* p,  entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType);
  void	(*Killed)( class CBasePlayer* p,  entvars_t *pevAttacker, gib_t iGib );
  Vector (*BodyTarget)( class CBasePlayer* p,  const Vector &posSrc );
  void (*StartSneaking)( class CBasePlayer* p );
  void (*StopSneaking)( class CBasePlayer* p );
  BOOL (*IsSneaking)( class CBasePlayer* p );
  BOOL (*IsAlive)( class CBasePlayer* p );
  BOOL (*ShouldFadeOnDeath)( class CBasePlayer* p );
  BOOL (*IsPlayer)( class CBasePlayer* p );
  BOOL (*IsNetClient)( class CBasePlayer* p );
  const char *(*TeamID)( class CBasePlayer* p );
  int		(*Save)( class CBasePlayer* p,  CSave &save );
  int		(*Restore)( class CBasePlayer* p,  CRestore &restore );
  void (*UpdateClientData)( class CBasePlayer* p );
  fcap_t		(*ObjectCaps)( class CBasePlayer* p );
  void	(*Precache)( class CBasePlayer* p );
  void (*ImpulseCommands)( class CBasePlayer* p );
};
class __base(CBaseMonster, 0) CBasePlayer __packed
{
  struct vtable_for_CBasePlayer* vtable;
public:
	int					random_seed;
	int					m_iPlayerSound;
	int					m_iTargetVolume;
	int					m_iWeaponVolume;
	int					m_iExtraSoundTypes;
	int					m_iWeaponFlash;
	float				m_flStopExtraSoundTime;
	float				m_flFlashLightTime;
	int					m_iFlashBattery;
	int					m_afButtonLast;
	int					m_afButtonPressed;
	int					m_afButtonReleased;
	edict_t			   *m_pentSndLast;
	float				m_flSndRoomtype;
	float				m_flSndRange;
	float				m_flFallVelocity;
	int					m_rgItems[MAX_ITEMS];
	int					m_fKnownItem;
	int					m_fNewAmmo;
	unsigned int		m_afPhysicsFlags;
	float				m_fNextSuicideTime;
	float				m_flTimeStepSound;
	float				m_flTimeWeaponIdle;
	float				m_flSwimTime;
	float				m_flDuckTime;
	float				m_flWallJumpTime;
	float				m_flSuitUpdate;
	int					m_rgSuitPlayList[CSUITPLAYLIST];
	int					m_iSuitPlayNext;
	int					m_rgiSuitNoRepeat[CSUITNOREPEAT];
	float				m_rgflSuitNoRepeatTime[CSUITNOREPEAT];
	int					m_lastDamageAmount;
	float				m_tbdPrev;
	float				m_flgeigerRange;
	float				m_flgeigerDelay;
	int					m_igeigerRangePrev;
	int					m_iStepLeft;
	char				m_szTextureName[CBTEXTURENAMEMAX];
	char				m_chTextureType;
	int					m_idrowndmg;
	int					m_idrownrestored;
	int					m_bitsHUDDamage;
	BOOL				m_fInitHUD;
	BOOL				m_fGameHUDInitialized;
	int					m_iTrain;
	BOOL				m_fWeapon;
	EHANDLE				m_pTank;
	float				m_fDeadTime;
	BOOL			m_fNoPlayerSound;
	BOOL			m_fLongJump;
	float       m_tSneaking;
	int			m_iUpdateTime;
	int			m_iClientHealth;
	int			m_iClientBattery;
	hidehud_t			m_iHideHUD;
	hidehud_t			m_iClientHideHUD;
	int			m_iFOV;
	int			m_iClientFOV;
	CBasePlayerItem	*m_rgpPlayerItems[MAX_ITEM_TYPES];
	CBasePlayerItem *m_pActiveItem;
	CBasePlayerItem *m_pClientActiveItem;
	CBasePlayerItem *m_pLastItem;
	int	m_rgAmmo[MAX_AMMO_SLOTS];
	int	m_rgAmmoLast[MAX_AMMO_SLOTS];
	Vector				m_vecAutoAim;
	BOOL				m_fOnTarget;
	int					m_iDeaths;
	float				m_iRespawnFrames;
	int m_lastx, m_lasty;
	int m_nCustomSprayFrames;
	float	m_flNextDecalTime;
	char m_szTeamName[TEAM_NAME_LENGTH];
	void Pain( void );
	void RenewItems(void);
	void PackDeadPlayerItems( void );
	void RemoveAllItems( BOOL removeSuit );
	BOOL SwitchWeapon( CBasePlayerItem *pWeapon );
	static	TYPEDESCRIPTION m_playerSaveData[];
	BOOL			IsOnLadder( void );
	BOOL			FlashlightIsOn( void );
	void			FlashlightTurnOn( void );
	void			FlashlightTurnOff( void );
	void UpdatePlayerSound ( void );
	void DeathSound ( void );
	class_t Classify ( void );
	void SetAnimation( PLAYER_ANIM playerAnim );
	void SetWeaponAnimType( const char *szExtention );
	char m_szAnimExtention[32];
	void CheatImpulseCommands( int iImpulse );
	void StartDeathCam( void );
	void StartObserver( Vector vecPosition, Vector vecViewAngle );
	void AddPoints( int score, BOOL bAllowNegativeScore );
	void AddPointsToTeam( int score, BOOL bAllowNegativeScore );
	BOOL AddPlayerItem( CBasePlayerItem *pItem );
	BOOL RemovePlayerItem( CBasePlayerItem *pItem );
	void DropPlayerItem ( char *pszItemName );
	BOOL HasPlayerItem( CBasePlayerItem *pCheckItem );
	BOOL HasNamedPlayerItem( const char *pszItemName );
	BOOL HasWeapons( void );
	void SelectPrevItem( int iItem );
	void SelectNextItem( int iItem );
	void SelectLastItem(void);
	void SelectItem(const char *pstr);
	void ItemPreFrame( void );
	void ItemPostFrame( void );
	void GiveNamedItem( const char *szName );
	void EnableControl(BOOL fControl);
	int  GiveAmmo( int iAmount, char *szName, int iMax );
	void SendAmmoUpdate(void);
	void WaterMove( void );
	void EXPORT PlayerDeathThink( void );
	void PlayerUse( void );
	void CheckSuitUpdate();
	void SetSuitUpdate(char *name, int fgroup, int iNoRepeat);
	void UpdateGeigerCounter( void );
	void CheckTimeBasedDamage( void );
	void UpdateStepSound( void );
	void PlayStepSound(int step, float fvol);
	BOOL FBecomeProne ( void );
	void BarnacleVictimBitten ( entvars_t *pevBarnacle );
	void BarnacleVictimReleased ( void );
	static int GetAmmoIndex(const char *psz);
	int AmmoInventory( int iAmmoIndex );
	int Illumination( void );
	void ResetAutoaim( void );
	Vector GetAutoaimVector( float flDelta  );
	Vector AutoaimDeflection( Vector &vecSrc, float flDist, float flDelta  );
	void ForceClientDllUpdate( void );
	void DeathMessage( entvars_t *pevKiller );
	void SetCustomDecalFrames( int nFrames );
	int GetCustomDecalFrames( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CItem
{
  BOOL(*MyTouch)(class CItem* p, CBasePlayer * pPlayer);
};
class __base(CBaseEntity, 0) CItem __packed
{
  struct vtable_for_CItem* vtable;
public:
	void	Spawn( void );
	CBaseEntity*	Respawn( void );
	void	EXPORT ItemTouch( CBaseEntity *pOther );
	void	EXPORT Materialize( void );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CHealthKit
{
  int (*Save)(class CHealthKit* p, CSave & save);
  int (*Restore)(class CHealthKit* p, CRestore & restore);
};
class __base(CItem, 0) CHealthKit __packed
{
  struct vtable_for_CHealthKit* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemSuit
{
};
class __base(CItem, 0) CItemSuit __packed
{
  struct vtable_for_CItemSuit* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemBattery
{
};
class __base(CItem, 0) CItemBattery __packed
{
  struct vtable_for_CItemBattery* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemAntidote
{
};
class __base(CItem, 0) CItemAntidote __packed
{
  struct vtable_for_CItemAntidote* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemSecurity
{
};
class __base(CItem, 0) CItemSecurity __packed
{
  struct vtable_for_CItemSecurity* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct __base(vtable_for_CItem, 0) __data_var_refs vtable_for_CItemLongJump
{
};
class __base(CItem, 0) CItemLongJump __packed
{
  struct vtable_for_CItemLongJump* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL MyTouch( CBasePlayer *pPlayer );
};
struct skilldata_t
{
	int iSkillLevel;
	float	agruntHealth;
	float agruntDmgPunch;
	float apacheHealth;
	float barneyHealth;
	float bigmommaHealthFactor;
	float bigmommaDmgSlash;
	float bigmommaDmgBlast;
	float bigmommaRadiusBlast;
	float bullsquidHealth;
	float bullsquidDmgBite;
	float bullsquidDmgWhip;
	float bullsquidDmgSpit;
	float gargantuaHealth;
	float gargantuaDmgSlash;
	float gargantuaDmgFire;
	float gargantuaDmgStomp;
	float hassassinHealth;
	float headcrabHealth;
	float headcrabDmgBite;
	float hgruntHealth;
	float hgruntDmgKick;
	float hgruntShotgunPellets;
	float hgruntGrenadeSpeed;
	float houndeyeHealth;
	float houndeyeDmgBlast;
	float slaveHealth;
	float slaveDmgClaw;
	float slaveDmgClawrake;
	float slaveDmgZap;
	float ichthyosaurHealth;
	float ichthyosaurDmgShake;
	float leechHealth;
	float leechDmgBite;
	float controllerHealth;
	float controllerDmgZap;
	float controllerSpeedBall;
	float controllerDmgBall;
	float nihilanthHealth;
	float nihilanthZap;
	float scientistHealth;
	float snarkHealth;
	float snarkDmgBite;
	float snarkDmgPop;
	float zombieHealth;
	float zombieDmgOneSlash;
	float zombieDmgBothSlash;
	float turretHealth;
	float miniturretHealth;
	float sentryHealth;
	float plrDmgCrowbar;
	float plrDmg9MM;
	float plrDmg357;
	float plrDmgMP5;
	float plrDmgM203Grenade;
	float plrDmgBuckshot;
	float plrDmgCrossbowClient;
	float plrDmgCrossbowMonster;
	float plrDmgRPG;
	float plrDmgGauss;
	float plrDmgEgonNarrow;
	float plrDmgEgonWide;
	float plrDmgHornet;
	float plrDmgHandGrenade;
	float plrDmgSatchel;
	float plrDmgTripmine;
	float monDmg9MM;
	float monDmgMP5;
	float monDmg12MM;
	float monDmgHornet;
	float suitchargerCapacity;
	float batteryCapacity;
	float healthchargerCapacity;
	float healthkitCapacity;
	float scientistHeal;
	float monHead;
	float monChest;
	float monStomach;
	float monLeg;
	float monArm;
	float plrHead;
	float plrChest;
	float plrStomach;
	float plrLeg;
	float plrArm;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBaseSpectator
{
};
class __base(CBaseEntity , 0) CBaseSpectator __packed
{
  struct vtable_for_CBaseSpectator* vtable;
public:
	void Spawn();
	void SpectatorConnect(void);
	void SpectatorDisconnect(void);
	void SpectatorThink(void);
private:
	void SpectatorImpulseCommand(void);
};
struct __data_var_refs vtable_for_CGameRules
{
  void (*RefreshSkillData)( class CGameRules* p );
  void (*Think)( class CGameRules* p ) = 0;
  BOOL (*IsAllowedToSpawn)( class CGameRules* p,  CBaseEntity *pEntity ) = 0;
  BOOL (*FAllowFlashlight)( class CGameRules* p ) = 0;
  BOOL (*FShouldSwitchWeapon)( class CGameRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon ) = 0;
  BOOL (*GetNextBestWeapon)( class CGameRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon ) = 0;
  BOOL (*IsMultiplayer)( class CGameRules* p ) = 0;
  BOOL (*IsDeathmatch)( class CGameRules* p ) = 0;
  BOOL (*IsTeamplay)( class CGameRules* p );
  BOOL (*IsCoOp)( class CGameRules* p ) = 0;
  const char *(*GetGameDescription)( class CGameRules* p );
  BOOL (*ClientConnected)( class CGameRules* p,  edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] ) = 0;
  void (*InitHUD)( class CGameRules* p,  CBasePlayer *pl ) = 0;
  void (*ClientDisconnected)( class CGameRules* p,  edict_t *pClient ) = 0;
  void (*UpdateGameMode)( class CGameRules* p,  CBasePlayer *pPlayer );
  float (*FlPlayerFallDamage)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  BOOL  (*FPlayerCanTakeDamage)( class CGameRules* p,  CBasePlayer *pPlayer, CBaseEntity *pAttacker );
  BOOL (*ShouldAutoAim)( class CGameRules* p,  CBasePlayer *pPlayer, edict_t *target );
  void (*PlayerSpawn)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  void (*PlayerThink)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  BOOL (*FPlayerCanRespawn)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  float (*FlPlayerSpawnTime)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  edict_t *(*GetPlayerSpawnSpot)( class CGameRules* p, CBasePlayer *pPlayer );
  BOOL (*AllowAutoTargetCrosshair)( class CGameRules* p );
  BOOL (*ClientCommand)( class CGameRules* p,  CBasePlayer *pPlayer, const char *pcmd );
  void (*ClientUserInfoChanged)( class CGameRules* p,  CBasePlayer *pPlayer, char *infobuffer );
  int (*IPointsForKill)( class CGameRules* p,  CBasePlayer *pAttacker, CBasePlayer *pKilled ) = 0;
  void (*PlayerKilled)( class CGameRules* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor ) = 0;
  void (*DeathNotice)( class CGameRules* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor )=  0;
  BOOL (*CanHavePlayerItem)( class CGameRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  void (*PlayerGotWeapon)( class CGameRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon ) = 0;
  int (*WeaponShouldRespawn)( class CGameRules* p,  CBasePlayerItem *pWeapon ) = 0;
  float (*FlWeaponRespawnTime)( class CGameRules* p,  CBasePlayerItem *pWeapon ) = 0;
  float (*FlWeaponTryRespawn)( class CGameRules* p,  CBasePlayerItem *pWeapon ) = 0;
  Vector (*VecWeaponRespawnSpot)( class CGameRules* p,  CBasePlayerItem *pWeapon ) = 0;
  BOOL (*CanHaveItem)( class CGameRules* p,  CBasePlayer *pPlayer, CItem *pItem ) = 0;
  void (*PlayerGotItem)( class CGameRules* p,  CBasePlayer *pPlayer, CItem *pItem ) = 0;
  int (*ItemShouldRespawn)( class CGameRules* p,  CItem *pItem ) = 0;
  float (*FlItemRespawnTime)( class CGameRules* p,  CItem *pItem ) = 0;
  Vector (*VecItemRespawnSpot)( class CGameRules* p,  CItem *pItem ) = 0;
  BOOL (*CanHaveAmmo)( class CGameRules* p,  CBasePlayer *pPlayer, const char *pszAmmoName, int iMaxCarry );
  void (*PlayerGotAmmo)( class CGameRules* p,  CBasePlayer *pPlayer, char *szName, int iCount ) = 0;
  int (*AmmoShouldRespawn)( class CGameRules* p,  CBasePlayerAmmo *pAmmo ) = 0;
  float (*FlAmmoRespawnTime)( class CGameRules* p,  CBasePlayerAmmo *pAmmo ) = 0;
  Vector (*VecAmmoRespawnSpot)( class CGameRules* p,  CBasePlayerAmmo *pAmmo ) = 0;
  float (*FlHealthChargerRechargeTime)( class CGameRules* p ) = 0;
  float (*FlHEVChargerRechargeTime)( class CGameRules* p );
  int (*DeadPlayerWeapons)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  int (*DeadPlayerAmmo)( class CGameRules* p,  CBasePlayer *pPlayer ) = 0;
  const char *(*GetTeamID)( class CGameRules* p, CBaseEntity *pEntity ) = 0;
  int (*PlayerRelationship)( class CGameRules* p,  CBaseEntity *pPlayer, CBaseEntity *pTarget ) = 0;
  int (*GetTeamIndex)( class CGameRules* p,  const char *pTeamName );
  const char *(*GetIndexedTeamName)( class CGameRules* p, int teamIndex );
  BOOL (*IsValidTeam)( class CGameRules* p,  const char *pTeamName );
  void (*ChangePlayerTeam)( class CGameRules* p,  CBasePlayer *pPlayer, const char *pTeamName, BOOL bKill, BOOL bGib );
  const char *(*SetDefaultPlayerTeam)( class CGameRules* p,CBasePlayer *pPlayer );
  BOOL (*PlayTextureSounds)( class CGameRules* p );
  BOOL (*PlayFootstepSounds)( class CGameRules* p,  CBasePlayer *pl, float fvol );
  BOOL (*FAllowMonsters)( class CGameRules* p ) = 0;
  void (*EndMultiplayerGame)( class CGameRules* p );
};
class CGameRules
{
  struct vtable_for_CGameRules* vtable;
public:
};
struct __base(vtable_for_CGameRules, 0) __data_var_refs vtable_for_CHalfLifeRules
{
  void (*Think)( class CHalfLifeRules* p );
  BOOL (*IsAllowedToSpawn)( class CHalfLifeRules* p,  CBaseEntity *pEntity );
  BOOL (*FAllowFlashlight)( class CHalfLifeRules* p );
  BOOL (*FShouldSwitchWeapon)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  BOOL (*GetNextBestWeapon)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon );
  BOOL (*IsMultiplayer)( class CHalfLifeRules* p );
  BOOL (*IsDeathmatch)( class CHalfLifeRules* p );
  BOOL (*IsCoOp)( class CHalfLifeRules* p );
  BOOL (*ClientConnected)( class CHalfLifeRules* p,  edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
  void (*InitHUD)( class CHalfLifeRules* p,  CBasePlayer *pl );
  void (*ClientDisconnected)( class CHalfLifeRules* p,  edict_t *pClient );
  float (*FlPlayerFallDamage)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  void (*PlayerSpawn)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  void (*PlayerThink)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  BOOL (*FPlayerCanRespawn)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  float (*FlPlayerSpawnTime)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  BOOL (*AllowAutoTargetCrosshair)( class CHalfLifeRules* p );
  int (*IPointsForKill)( class CHalfLifeRules* p,  CBasePlayer *pAttacker, CBasePlayer *pKilled );
  void (*PlayerKilled)( class CHalfLifeRules* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor );
  void (*DeathNotice)( class CHalfLifeRules* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor );
  void (*PlayerGotWeapon)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  int (*WeaponShouldRespawn)( class CHalfLifeRules* p,  CBasePlayerItem *pWeapon );
  float (*FlWeaponRespawnTime)( class CHalfLifeRules* p,  CBasePlayerItem *pWeapon );
  float (*FlWeaponTryRespawn)( class CHalfLifeRules* p,  CBasePlayerItem *pWeapon );
  Vector (*VecWeaponRespawnSpot)( class CHalfLifeRules* p,  CBasePlayerItem *pWeapon );
  BOOL (*CanHaveItem)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, CItem *pItem );
  void (*PlayerGotItem)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, CItem *pItem );
  int (*ItemShouldRespawn)( class CHalfLifeRules* p,  CItem *pItem );
  float (*FlItemRespawnTime)( class CHalfLifeRules* p,  CItem *pItem );
  Vector (*VecItemRespawnSpot)( class CHalfLifeRules* p,  CItem *pItem );
  void (*PlayerGotAmmo)( class CHalfLifeRules* p,  CBasePlayer *pPlayer, char *szName, int iCount );
  int (*AmmoShouldRespawn)( class CHalfLifeRules* p,  CBasePlayerAmmo *pAmmo );
  float (*FlAmmoRespawnTime)( class CHalfLifeRules* p,  CBasePlayerAmmo *pAmmo );
  Vector (*VecAmmoRespawnSpot)( class CHalfLifeRules* p,  CBasePlayerAmmo *pAmmo );
  float (*FlHealthChargerRechargeTime)( class CHalfLifeRules* p );
  int (*DeadPlayerWeapons)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  int (*DeadPlayerAmmo)( class CHalfLifeRules* p,  CBasePlayer *pPlayer );
  BOOL (*FAllowMonsters)( class CHalfLifeRules* p );
  const char *(*GetTeamID)( class CHalfLifeRules* p, CBaseEntity *pEntity );
  int (*PlayerRelationship)( class CHalfLifeRules* p,  CBaseEntity *pPlayer, CBaseEntity *pTarget );
};
class __base(CGameRules, 0) CHalfLifeRules __packed
{
  struct vtable_for_CHalfLifeRules* vtable;
public:
	CHalfLifeRules ( void );
};
struct __base(vtable_for_CGameRules, 0) __data_var_refs vtable_for_CHalfLifeMultiplay
{
  void (*Think)( class CHalfLifeMultiplay* p );
  void (*RefreshSkillData)( class CHalfLifeMultiplay* p );
  BOOL (*IsAllowedToSpawn)( class CHalfLifeMultiplay* p,  CBaseEntity *pEntity );
  BOOL (*FAllowFlashlight)( class CHalfLifeMultiplay* p );
  BOOL (*FShouldSwitchWeapon)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  BOOL (*GetNextBestWeapon)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CBasePlayerItem *pCurrentWeapon );
  BOOL (*IsMultiplayer)( class CHalfLifeMultiplay* p );
  BOOL (*IsDeathmatch)( class CHalfLifeMultiplay* p );
  BOOL (*IsCoOp)( class CHalfLifeMultiplay* p );
  BOOL (*ClientConnected)( class CHalfLifeMultiplay* p,  edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
  void (*InitHUD)( class CHalfLifeMultiplay* p,  CBasePlayer *pl );
  void (*ClientDisconnected)( class CHalfLifeMultiplay* p,  edict_t *pClient );
  void (*UpdateGameMode)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  float (*FlPlayerFallDamage)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  BOOL  (*FPlayerCanTakeDamage)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CBaseEntity *pAttacker );
  void (*PlayerSpawn)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  void (*PlayerThink)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  BOOL (*FPlayerCanRespawn)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  float (*FlPlayerSpawnTime)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  edict_t *(*GetPlayerSpawnSpot)( class CHalfLifeMultiplay* p, CBasePlayer *pPlayer );
  BOOL (*AllowAutoTargetCrosshair)( class CHalfLifeMultiplay* p );
  int (*IPointsForKill)( class CHalfLifeMultiplay* p,  CBasePlayer *pAttacker, CBasePlayer *pKilled );
  void (*PlayerKilled)( class CHalfLifeMultiplay* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor );
  void (*DeathNotice)( class CHalfLifeMultiplay* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor );
  void (*PlayerGotWeapon)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  BOOL (*CanHavePlayerItem)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CBasePlayerItem *pWeapon );
  int (*WeaponShouldRespawn)( class CHalfLifeMultiplay* p,  CBasePlayerItem *pWeapon );
  float (*FlWeaponRespawnTime)( class CHalfLifeMultiplay* p,  CBasePlayerItem *pWeapon );
  float (*FlWeaponTryRespawn)( class CHalfLifeMultiplay* p,  CBasePlayerItem *pWeapon );
  Vector (*VecWeaponRespawnSpot)( class CHalfLifeMultiplay* p,  CBasePlayerItem *pWeapon );
  BOOL (*CanHaveItem)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CItem *pItem );
  void (*PlayerGotItem)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, CItem *pItem );
  int (*ItemShouldRespawn)( class CHalfLifeMultiplay* p,  CItem *pItem );
  float (*FlItemRespawnTime)( class CHalfLifeMultiplay* p,  CItem *pItem );
  Vector (*VecItemRespawnSpot)( class CHalfLifeMultiplay* p,  CItem *pItem );
  void (*PlayerGotAmmo)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer, char *szName, int iCount );
  int (*AmmoShouldRespawn)( class CHalfLifeMultiplay* p,  CBasePlayerAmmo *pAmmo );
  float (*FlAmmoRespawnTime)( class CHalfLifeMultiplay* p,  CBasePlayerAmmo *pAmmo );
  Vector (*VecAmmoRespawnSpot)( class CHalfLifeMultiplay* p,  CBasePlayerAmmo *pAmmo );
  float (*FlHealthChargerRechargeTime)( class CHalfLifeMultiplay* p );
  float (*FlHEVChargerRechargeTime)( class CHalfLifeMultiplay* p );
  int (*DeadPlayerWeapons)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  int (*DeadPlayerAmmo)( class CHalfLifeMultiplay* p,  CBasePlayer *pPlayer );
  const char *(*GetTeamID)( class CHalfLifeMultiplay* p, CBaseEntity *pEntity );
  int (*PlayerRelationship)( class CHalfLifeMultiplay* p,  CBaseEntity *pPlayer, CBaseEntity *pTarget );
  BOOL (*PlayTextureSounds)( class CHalfLifeMultiplay* p );
  BOOL (*PlayFootstepSounds)( class CHalfLifeMultiplay* p,  CBasePlayer *pl, float fvol );
  BOOL (*FAllowMonsters)( class CHalfLifeMultiplay* p );
  void (*EndMultiplayerGame)( class CHalfLifeMultiplay* p );
  void (*ChangeLevel)( class CHalfLifeMultiplay* p );
  void (*GoToIntermission)( class CHalfLifeMultiplay* p );
};
class __base(CGameRules, 0) CHalfLifeMultiplay __packed
{
  struct vtable_for_CHalfLifeMultiplay* vtable;
public:
	CHalfLifeMultiplay();
protected:
	float m_flIntermissionEndTime;
	BOOL m_iEndIntermissionButtonHit;
	void SendMOTDToClient( edict_t *client );
};
struct __base(vtable_for_CHalfLifeMultiplay, 0) __data_var_refs vtable_for_CHalfLifeTeamplay
{
  BOOL (*ClientCommand)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer, const char *pcmd );
  void (*ClientUserInfoChanged)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer, char *infobuffer );
  BOOL (*IsTeamplay)( class CHalfLifeTeamplay* p );
  BOOL (*FPlayerCanTakeDamage)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer, CBaseEntity *pAttacker );
  int (*PlayerRelationship)( class CHalfLifeTeamplay* p,  CBaseEntity *pPlayer, CBaseEntity *pTarget );
  const char *(*GetTeamID)( class CHalfLifeTeamplay* p, CBaseEntity *pEntity );
  BOOL (*ShouldAutoAim)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer, edict_t *target );
  int (*IPointsForKill)( class CHalfLifeTeamplay* p,  CBasePlayer *pAttacker, CBasePlayer *pKilled );
  void (*InitHUD)( class CHalfLifeTeamplay* p,  CBasePlayer *pl );
  void (*DeathNotice)( class CHalfLifeTeamplay* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pevInflictor );
  const char *(*GetGameDescription)( class CHalfLifeTeamplay* p );
  void (*UpdateGameMode)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer );
  void (*PlayerKilled)( class CHalfLifeTeamplay* p,  CBasePlayer *pVictim, entvars_t *pKiller, entvars_t *pInflictor );
  void (*Think) ( class CHalfLifeTeamplay* p );
  int (*GetTeamIndex)( class CHalfLifeTeamplay* p,  const char *pTeamName );
  const char *(*GetIndexedTeamName)( class CHalfLifeTeamplay* p, int teamIndex );
  BOOL (*IsValidTeam)( class CHalfLifeTeamplay* p,  const char *pTeamName );
  void (*ChangePlayerTeam)( class CHalfLifeTeamplay* p,  CBasePlayer *pPlayer, const char *pTeamName, BOOL bKill, BOOL bGib );
};
class __base(CHalfLifeMultiplay, 0) CHalfLifeTeamplay __packed
{
  struct vtable_for_CHalfLifeTeamplay* vtable;
public:
	CHalfLifeTeamplay();
	const char *SetDefaultPlayerTeam( CBasePlayer *pPlayer );
private:
	void RecountTeams( void );
	const char *TeamWithFewestPlayers( void );
	BOOL m_DisableDeathMessages;
	BOOL m_DisableDeathPenalty;
	BOOL m_teamLimit;
	char m_szTeamList[TEAMPLAY_TEAMLISTLENGTH];
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CRuleEntity
{
  int (*Save)(class CRuleEntity* p, CSave & save);
  int (*Restore)(class CRuleEntity* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CRuleEntity __packed
{
  struct vtable_for_CRuleEntity* vtable;
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	void	SetMaster( int iszMaster ) ;
protected:
	BOOL	CanFireForActivator( CBaseEntity *pActivator );
private:
	string_t	m_iszMaster;
};
struct __base(vtable_for_CRuleEntity, 0) __data_var_refs vtable_for_CRulePointEntity
{
};
class __base(CRuleEntity, 0) CRulePointEntity __packed
{
  struct vtable_for_CRulePointEntity* vtable;
public:
	void		Spawn( void );
};
struct __base(vtable_for_CRuleEntity, 0) __data_var_refs vtable_for_CRuleBrushEntity
{
};
class __base(CRuleEntity, 0) CRuleBrushEntity __packed
{
  struct vtable_for_CRuleBrushEntity* vtable;
public:
	void		Spawn( void );
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameScore
{
};
class __base(CRulePointEntity, 0) CGameScore __packed
{
  struct vtable_for_CGameScore* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	inline	int		Points( void ) ;
	inline	BOOL	AllowNegativeScore( void ) ;
	inline	BOOL	AwardToTeam( void ) ;
	inline	void	SetPoints( int points ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameEnd
{
};
class __base(CRulePointEntity, 0) CGameEnd __packed
{
  struct vtable_for_CGameEnd* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
};
typedef struct hudtextparms_s
{
	float		x;
	float		y;
	int			effect;
	byte		r1, g1, b1, a1;
	byte		r2, g2, b2, a2;
	float		fadeinTime;
	float		fadeoutTime;
	float		holdTime;
	float		fxTime;
	int			channel;
} hudtextparms_t;
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameText
{
  int (*Save)(class CGameText* p, CSave & save);
  int (*Restore)(class CGameText* p, CRestore & restore);
};
class __base(CRulePointEntity, 0) CGameText __packed
{
  struct vtable_for_CGameText* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	inline	BOOL	MessageToAll( void ) ;
	inline	void	MessageSet( const char *pMessage ) ;
	inline	const char *MessageGet( void )	;
private:
	hudtextparms_t	m_textParms;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameTeamMaster
{
};
class __base(CRulePointEntity, 0) CGameTeamMaster __packed
{
  struct vtable_for_CGameTeamMaster* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	fcap_t			ObjectCaps( void ) ;
	BOOL		IsTriggered( CBaseEntity *pActivator );
	const char	*TeamID( void );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL AnyTeam( void ) ;
private:
	BOOL		TeamMatch( CBaseEntity *pActivator );
	int			m_teamIndex;
	USE_TYPE	triggerType;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameTeamSet
{
};
class __base(CRulePointEntity, 0) CGameTeamSet __packed
{
  struct vtable_for_CGameTeamSet* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ShouldClearTeam( void ) ;
private:
};
struct __base(vtable_for_CRuleBrushEntity, 0) __data_var_refs vtable_for_CGamePlayerZone
{
  int (*Save)(class CGamePlayerZone* p, CSave & save);
  int (*Restore)(class CGamePlayerZone* p, CRestore & restore);
};
class __base(CRuleBrushEntity, 0) CGamePlayerZone __packed
{
  struct vtable_for_CGamePlayerZone* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	string_t	m_iszInTarget;
	string_t	m_iszOutTarget;
	string_t	m_iszInCount;
	string_t	m_iszOutCount;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerHurt
{
};
class __base(CRulePointEntity, 0) CGamePlayerHurt __packed
{
  struct vtable_for_CGamePlayerHurt* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameCounter
{
};
class __base(CRulePointEntity, 0) CGameCounter __packed
{
  struct vtable_for_CGameCounter* vtable;
public:
	void		Spawn( void );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ResetOnFire( void ) ;
	inline void CountUp( void ) ;
	inline void CountDown( void ) ;
	inline void ResetCount( void ) ;
	inline int  CountValue( void ) ;
	inline int	LimitValue( void ) ;
	inline BOOL HitLimit( void ) ;
private:
	inline void SetCountValue( int value ) ;
	inline void SetInitialValue( int value ) ;
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGameCounterSet
{
};
class __base(CRulePointEntity, 0) CGameCounterSet __packed
{
  struct vtable_for_CGameCounterSet* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL RemoveOnFire( void ) ;
private:
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerEquip
{
};
class __base(CRulePointEntity, 0) CGamePlayerEquip __packed
{
  struct vtable_for_CGamePlayerEquip* vtable;
public:
	void		KeyValue( KeyValueData *pkvd );
	void		Touch( CBaseEntity *pOther );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	inline BOOL	UseOnly( void ) ;
private:
	void		EquipPlayer( CBaseEntity *pPlayer );
	string_t	m_weaponNames[MAX_EQUIP];
	int			m_weaponCount[MAX_EQUIP];
};
struct __base(vtable_for_CRulePointEntity, 0) __data_var_refs vtable_for_CGamePlayerTeam
{
};
class __base(CRulePointEntity, 0) CGamePlayerTeam __packed
{
  struct vtable_for_CGamePlayerTeam* vtable;
public:
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
	inline BOOL RemoveOnFire( void ) ;
	inline BOOL ShouldKillPlayer( void ) ;
	inline BOOL ShouldGibPlayer( void ) ;
	const char *TargetTeamName( const char *pszTargetName );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CStripWeapons
{
};
class __base(CPointEntity, 0) CStripWeapons __packed
{
  struct vtable_for_CStripWeapons* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
private:
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CRevertSaved
{
  int (*Save)(class CRevertSaved* p, CSave & save);
  int (*Restore)(class CRevertSaved* p, CRestore & restore);
};
class __base(CPointEntity, 0) CRevertSaved __packed
{
  struct vtable_for_CRevertSaved* vtable;
public:
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT MessageThink( void );
	void	EXPORT LoadThink( void );
	void	KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	inline	float	Duration( void ) ;
	inline	float	HoldTime( void ) ;
	inline	float	MessageTime( void ) ;
	inline	float	LoadTime( void ) ;
	inline	void	SetDuration( float duration ) ;
	inline	void	SetHoldTime( float hold ) ;
	inline	void	SetMessageTime( float time ) ;
	inline	void	SetLoadTime( float time ) ;
private:
	float	m_messageTime;
	float	m_loadTime;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CInfoIntermission
{
};
class __base(CPointEntity, 0) CInfoIntermission __packed
{
  struct vtable_for_CInfoIntermission* vtable;
	void Spawn( void );
	void Think( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CGib
{
  fcap_t (*ObjectCaps)(class CGib* p);
};
class __base(CBaseEntity, 0) CGib __packed
{
  struct vtable_for_CGib* vtable;
public:
	void Spawn( const char *szGibModel );
	void EXPORT BounceGibTouch ( CBaseEntity *pOther );
	void EXPORT StickyGibTouch ( CBaseEntity *pOther );
	void EXPORT WaitTillLand( void );
	void		LimitVelocity( void );
	static	void SpawnHeadGib( entvars_t *pevVictim );
	static	void SpawnRandomGibs( entvars_t *pevVictim, int cGibs, int human );
	static  void SpawnStickyGibs( entvars_t *pevVictim, Vector vecOrigin, int cGibs );
	bloodcolor_t		m_bloodColor;
	int		m_cBloodDecals;
	int		m_material;
	float	m_lifeTime;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CGibShooter
{
  CGib* (*CreateGib)(class CGibShooter* p);
  int (*Save)(class CGibShooter* p, CSave & save);
  int (*Restore)(class CGibShooter* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CGibShooter __packed
{
  struct vtable_for_CGibShooter* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void EXPORT ShootThink( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int	m_iGibs;
	int m_iGibCapacity;
	int m_iGibMaterial;
	int m_iGibModelIndex;
	float m_flGibVelocity;
	float m_flVariance;
	float m_flGibLife;
};
struct __base(vtable_for_CGibShooter, 0) __data_var_refs vtable_for_CEnvShooter
{
};
class __base(CGibShooter, 0) CEnvShooter __packed
{
  struct vtable_for_CEnvShooter* vtable;
	void		Precache( void );
	void		KeyValue( KeyValueData *pkvd );
	CGib		*CreateGib( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CPathTrack
{
  int (*Save)(class CPathTrack* p, CSave & save);
  int (*Restore)(class CPathTrack* p, CRestore & restore);
};
class __base(CPointEntity, 0) CPathTrack __packed
{
  struct vtable_for_CPathTrack* vtable;
public:
	void		Spawn( void );
	void		Activate( void );
	void		KeyValue( KeyValueData* pkvd);
	void		SetPrevious( CPathTrack *pprevious );
	void		Link( void );
	void		Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	CPathTrack	*ValidPath( CPathTrack *ppath, int testFlag );
	void		Project( CPathTrack *pstart, CPathTrack *pend, Vector *origin, float dist );
	static CPathTrack *Instance( edict_t *pent );
	CPathTrack	*LookAhead( Vector *origin, float dist, int move );
	CPathTrack	*Nearest( Vector origin );
	CPathTrack	*GetNext( void );
	CPathTrack	*GetPrevious( void );
	static	TYPEDESCRIPTION m_SaveData[];
#if PATH_SPARKLE_DEBUG
	void EXPORT Sparkle(void);
#endif
	float		m_length;
	string_t	m_altName;
	CPathTrack	*m_pnext;
	CPathTrack	*m_pprevious;
	CPathTrack	*m_paltpath;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTrackTrain
{
  int (*Save)(class CFuncTrackTrain* p, CSave & save);
  int (*Restore)(class CFuncTrackTrain* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CFuncTrackTrain* p);
  void  (*OverrideReset)(class CFuncTrackTrain* p);
};
class __base(CBaseEntity, 0) CFuncTrackTrain __packed
{
  struct vtable_for_CFuncTrackTrain* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Blocked( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void KeyValue( KeyValueData* pkvd );
	void EXPORT Next( void );
	void EXPORT Find( void );
	void EXPORT NearestPath( void );
	void EXPORT DeadEnd( void );
	void		NextThink( float thinkTime, BOOL alwaysThink );
	void SetTrack( CPathTrack *track ) ;
	void SetControls( entvars_t *pevControls );
	BOOL OnControls( entvars_t *pev );
	void StopSound ( void );
	void UpdateSound ( void );
	static CFuncTrackTrain *Instance( edict_t *pent );
	static	TYPEDESCRIPTION m_SaveData[];
	CPathTrack	*m_ppath;
	float		m_length;
	float		m_height;
	float		m_speed;
	float		m_dir;
	float		m_startSpeed;
	Vector		m_controlMins;
	Vector		m_controlMaxs;
	int			m_soundPlaying;
	int			m_sounds;
	float		m_flVolume;
	float		m_flBank;
	float		m_oldSpeed;
private:
	unsigned short m_usAdjustPitch;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CPathCorner
{
  int (*Save)(class CPathCorner* p, CSave & save);
  int (*Restore)(class CPathCorner* p, CRestore & restore);
};
class __base(CPointEntity, 0) CPathCorner __packed
{
  struct vtable_for_CPathCorner* vtable;
public:
	void Spawn( );
	void KeyValue( KeyValueData* pkvd );
	float GetDelay( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	float	m_flWait;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBasePlatTrain
{
  fcap_t (*ObjectCaps)(class CBasePlatTrain* p);
  BOOL(*IsTogglePlat)(class CBasePlatTrain* p);
  int (*Save)(class CBasePlatTrain* p, CSave & save);
  int (*Restore)(class CBasePlatTrain* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CBasePlatTrain __packed
{
  struct vtable_for_CBasePlatTrain* vtable;
public:
	void KeyValue( KeyValueData* pkvd);
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	BYTE	m_bMoveSnd;
	BYTE	m_bStopSnd;
	float	m_volume;
};
struct __base(vtable_for_CBasePlatTrain, 0) __data_var_refs vtable_for_CFuncPlat
{
  void (*Blocked)(class CFuncPlat* p, CBaseEntity * pOther);
  void (*GoUp)(class CFuncPlat* p);
  void (*GoDown)(class CFuncPlat* p);
  void (*HitTop)(class CFuncPlat* p);
  void (*HitBottom)(class CFuncPlat* p);
};
class __base(CBasePlatTrain, 0) CFuncPlat __packed
{
  struct vtable_for_CFuncPlat* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Setup( void );
	void EXPORT PlatUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT CallGoDown( void ) ;
	void	EXPORT CallHitTop( void  ) ;
	void	EXPORT CallHitBottom( void ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPlatTrigger
{
  fcap_t (*ObjectCaps)(class CPlatTrigger* p);
};
class __base(CBaseEntity, 0) CPlatTrigger __packed
{
  struct vtable_for_CPlatTrigger* vtable;
public:
	void SpawnInsideTrigger( CFuncPlat *pPlatform );
	void Touch( CBaseEntity *pOther );
	CFuncPlat *m_pPlatform;
};
struct __base(vtable_for_CFuncPlat, 0) __data_var_refs vtable_for_CFuncPlatRot
{
  void  (*GoUp)(class CFuncPlatRot* p);
  void  (*GoDown)(class CFuncPlatRot* p);
  void  (*HitTop)(class CFuncPlatRot* p);
  void  (*HitBottom)(class CFuncPlatRot* p);
  int (*Save)(class CFuncPlatRot* p, CSave & save);
  int (*Restore)(class CFuncPlatRot* p, CRestore & restore);
};
class __base(CFuncPlat, 0) CFuncPlatRot __packed
{
  struct vtable_for_CFuncPlatRot* vtable;
public:
	void Spawn( void );
	void SetupRotation( void );
	void			RotMove( Vector &destAngle, float time );
	static	TYPEDESCRIPTION m_SaveData[];
	Vector	m_end, m_start;
};
struct __base(vtable_for_CBasePlatTrain, 0) __data_var_refs vtable_for_CFuncTrain
{
  int (*Save)(class CFuncTrain* p, CSave & save);
  int (*Restore)(class CFuncTrain* p, CRestore & restore);
};
class __base(CBasePlatTrain, 0) CFuncTrain __packed
{
  struct vtable_for_CFuncTrain* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Activate( void );
	void OverrideReset( void );
	void Blocked( CBaseEntity *pOther );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT Wait( void );
	void EXPORT Next( void );
	static	TYPEDESCRIPTION m_SaveData[];
	entvars_t	*m_pevCurrentTarget;
	int			m_sounds;
	BOOL		m_activated;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTrainControls
{
  fcap_t (*ObjectCaps)(class CFuncTrainControls* p);
};
class __base(CBaseEntity, 0) CFuncTrainControls __packed
{
  struct vtable_for_CFuncTrainControls* vtable;
public:
	void Spawn( void );
	void EXPORT Find( void );
};
struct __base(vtable_for_CFuncPlatRot, 0) __data_var_refs vtable_for_CFuncTrackChange
{
  void EXPORT (*GoUp)(class CFuncTrackChange* p);
  void EXPORT (*GoDown)(class CFuncTrackChange* p);
  void (*HitBottom)(class CFuncTrackChange* p);
  void (*HitTop)(class CFuncTrackChange* p);
  void (*UpdateAutoTargets)(class CFuncTrackChange* p, int toggleState);
  BOOL (*IsTogglePlat)(class CFuncTrackChange* p);
  int (*Save)(class CFuncTrackChange* p, CSave & save);
  int (*Restore)(class CFuncTrackChange* p, CRestore & restore);
  void (*OverrideReset)(class CFuncTrackChange* p);
};
class __base(CFuncPlatRot, 0) CFuncTrackChange __packed
{
  struct vtable_for_CFuncTrackChange* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void			KeyValue( KeyValueData* pkvd );
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void			EXPORT Find( void );
	TRAIN_CODE		EvaluateTrain( CPathTrack *pcurrent );
	void			UpdateTrain( Vector &dest );
	void			Touch( CBaseEntity *pOther );
	void			DisableUse( void ) ;
	void			EnableUse( void ) ;
	int				UseEnabled( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	CPathTrack		*m_trackTop;
	CPathTrack		*m_trackBottom;
	CFuncTrackTrain	*m_train;
	int				m_trackTopName;
	int				m_trackBottomName;
	int				m_trainName;
	TRAIN_CODE		m_code;
	int				m_targetState;
	int				m_use;
};
struct __base(vtable_for_CFuncTrackChange, 0) __data_var_refs vtable_for_CFuncTrackAuto
{
  void  (*UpdateAutoTargets)(class CFuncTrackAuto* p, int toggleState);
};
class __base(CFuncTrackChange, 0) CFuncTrackAuto __packed
{
  struct vtable_for_CFuncTrackAuto* vtable;
public:
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncWall
{
  fcap_t (*ObjectCaps)(class CFuncWall* p);
};
class __base(CBaseEntity, 0) CFuncWall __packed
{
  struct vtable_for_CFuncWall* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncWallToggle
{
};
class __base(CFuncWall, 0) CFuncWallToggle __packed
{
  struct vtable_for_CFuncWallToggle* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	TurnOff( void );
	void	TurnOn( void );
	BOOL	IsOn( void );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncConveyor
{
};
class __base(CFuncWall, 0) CFuncConveyor __packed
{
  struct vtable_for_CFuncConveyor* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	UpdateSpeed( float speed );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CFuncIllusionary
{
  fcap_t (*ObjectCaps)(class CFuncIllusionary* p);
};
class __base(CBaseToggle , 0) CFuncIllusionary __packed
{
  struct vtable_for_CFuncIllusionary* vtable;
public:
	void Spawn( void );
	void EXPORT SloshTouch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
};
struct __base(vtable_for_CFuncWall, 0) __data_var_refs vtable_for_CFuncMonsterClip
{
};
class __base(CFuncWall, 0) CFuncMonsterClip __packed
{
  struct vtable_for_CFuncMonsterClip* vtable;
public:
	void	Spawn( void );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncRotating
{
  fcap_t (*ObjectCaps)(class CFuncRotating* p);
  int (*Save)(class CFuncRotating* p, CSave & save);
  int (*Restore)(class CFuncRotating* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncRotating __packed
{
  struct vtable_for_CFuncRotating* vtable;
public:
	void Spawn( void  );
	void Precache( void  );
	void EXPORT SpinUp ( void );
	void EXPORT SpinDown ( void );
	void KeyValue( KeyValueData* pkvd);
	void EXPORT HurtTouch ( CBaseEntity *pOther );
	void EXPORT RotatingUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT Rotate( void );
	void RampPitchVol (int fUp );
	void Blocked( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flFanFriction;
	float m_flAttenuation;
	float m_flVolume;
	float m_pitch;
	int	  m_sounds;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CPendulum
{
  fcap_t (*ObjectCaps)(class CPendulum* p);
  int (*Save)(class CPendulum* p, CSave & save);
  int (*Restore)(class CPendulum* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CPendulum __packed
{
  struct vtable_for_CPendulum* vtable;
public:
	void	Spawn ( void );
	void	KeyValue( KeyValueData *pkvd );
	void	EXPORT Swing( void );
	void	EXPORT PendulumUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT Stop( void );
	void	Touch( CBaseEntity *pOther );
	void	EXPORT RopeTouch ( CBaseEntity *pOther );
	void	Blocked( CBaseEntity *pOther );
	static	TYPEDESCRIPTION m_SaveData[];
	float	m_accel;
	float	m_distance;
	float	m_time;
	float	m_damp;
	float	m_maxSpeed;
	float	m_dampSpeed;
	vec3_t	m_center;
	vec3_t	m_start;
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CEnvGlobal
{
  int (*Save)(class CEnvGlobal* p, CSave & save);
  int (*Restore)(class CEnvGlobal* p, CRestore & restore);
};
class __base(CPointEntity, 0) CEnvGlobal __packed
{
  struct vtable_for_CEnvGlobal* vtable;
public:
	void	Spawn( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	string_t	m_globalstate;
	int			m_triggermode;
	int			m_initialstate;
};
struct __base(vtable_for_CBaseButton, 0) __data_var_refs vtable_for_CRotButton
{
};
class __base(CBaseButton, 0) CRotButton __packed
{
  struct vtable_for_CRotButton* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMomentaryRotButton
{
  fcap_t (*ObjectCaps)(class CMomentaryRotButton* p);
  int (*Save)(class CMomentaryRotButton* p, CSave & save);
  int (*Restore)(class CMomentaryRotButton* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMomentaryRotButton __packed
{
  struct vtable_for_CMomentaryRotButton* vtable;
public:
	void	Spawn ( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT Off( void );
	void	EXPORT Return( void );
	void	UpdateSelf( float value );
	void	UpdateSelfReturn( float value );
	void	UpdateAllButtons( float value, int start );
	void	PlaySound( void );
	void	UpdateTarget( float value );
	static CMomentaryRotButton *Instance( edict_t *pent ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_lastUsed;
	int		m_direction;
	float	m_returnSpeed;
	vec3_t	m_start;
	vec3_t	m_end;
	int		m_sounds;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseDoor
{
  void (*KeyValue)(class CBaseDoor* p, KeyValueData * pkvd);
  void (*Use)(class CBaseDoor* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
  void (*Blocked)(class CBaseDoor* p, CBaseEntity * pOther);
  fcap_t (*ObjectCaps)(class CBaseDoor* p);
  int (*Save)(class CBaseDoor* p, CSave & save);
  int (*Restore)(class CBaseDoor* p, CRestore & restore);
  void (*SetToggleState)(class CBaseDoor* p, int state);
};
class __base(CBaseToggle, 0) CBaseDoor __packed
{
  struct vtable_for_CBaseDoor* vtable;
public:
	void Spawn( void );
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT DoorTouch( CBaseEntity *pOther );
	int DoorActivate( );
	void EXPORT DoorGoUp( void );
	void EXPORT DoorGoDown( void );
	void EXPORT DoorHitTop( void );
	void EXPORT DoorHitBottom( void );
	BYTE	m_bHealthValue;
	BYTE	m_bMoveSnd;
	BYTE	m_bStopSnd;
	locksound_t m_ls;
	BYTE	m_bLockedSound;
	BYTE	m_bLockedSentence;
	BYTE	m_bUnlockedSound;
	BYTE	m_bUnlockedSentence;
};
struct __base(vtable_for_CBaseDoor, 0) __data_var_refs vtable_for_CRotDoor
{
  void (*SetToggleState)(class CRotDoor* p, int state);
};
class __base(CBaseDoor, 0) CRotDoor __packed
{
  struct vtable_for_CRotDoor* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CMomentaryDoor
{
  fcap_t (*ObjectCaps)(class CMomentaryDoor* p);
  int (*Save)(class CMomentaryDoor* p, CSave & save);
  int (*Restore)(class CMomentaryDoor* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CMomentaryDoor __packed
{
  struct vtable_for_CMomentaryDoor* vtable;
public:
	void	Spawn( void );
	void Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	BYTE	m_bMoveSnd;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CWallHealth
{
  fcap_t (*ObjectCaps)(class CWallHealth* p);
  int (*Save)(class CWallHealth* p, CSave & save);
  int (*Restore)(class CWallHealth* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CWallHealth __packed
{
  struct vtable_for_CWallHealth* vtable;
public:
	void Spawn( );
	void Precache( void );
	void EXPORT Off(void);
	void EXPORT Recharge(void);
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flNextCharge;
	int		m_iReactivate ;
	int		m_iJuice;
	int		m_iOn;
	float   m_flSoundTime;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CRecharge
{
  fcap_t (*ObjectCaps)(class CRecharge* p);
  int (*Save)(class CRecharge* p, CSave & save);
  int (*Restore)(class CRecharge* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CRecharge __packed
{
  struct vtable_for_CRecharge* vtable;
public:
	void Spawn( );
	void Precache( void );
	void EXPORT Off(void);
	void EXPORT Recharge(void);
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flNextCharge;
	int		m_iReactivate ;
	int		m_iJuice;
	int		m_iOn;
	float   m_flSoundTime;
};
enum TANKBULLET
{
	TANK_BULLET_NONE = 0,
	TANK_BULLET_9MM = 1,
	TANK_BULLET_MP5 = 2,
	TANK_BULLET_12MM = 3,
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTank
{
  void (*Fire)(class CFuncTank* p, const Vector & barrelEnd, const Vector & forward, entvars_t * pevAttacker);
  Vector(*UpdateTargetPosition)(class CFuncTank* p, CBaseEntity * pTarget);
  fcap_t (*ObjectCaps)(class CFuncTank* p);
  int (*Save)(class CFuncTank* p, CSave & save);
  int (*Restore)(class CFuncTank* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncTank __packed
{
  struct vtable_for_CFuncTank* vtable;
public:
	void	Spawn( void );
	void	Precache( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	Think( void );
	void	TrackTarget( void );
	void	StartRotSound( void );
	void	StopRotSound( void );
	inline BOOL IsActive( void ) ;
	inline void TankActivate( void ) ;
	inline void TankDeactivate( void ) ;
	inline BOOL CanFire( void ) ;
	BOOL		InRange( float range );
	edict_t		*FindTarget( edict_t *pPlayer );
	void		TankTrace( const Vector &vecStart, const Vector &vecForward, const Vector &vecSpread, TraceResult &tr );
	Vector		BarrelPosition( void );
	void		AdjustAnglesForBarrel( Vector &angles, float distance );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL OnControls( entvars_t *pevTest );
	BOOL StartControl( CBasePlayer* pController );
	void StopControl( void );
	void ControllerPostFrame( void );
protected:
	CBasePlayer* m_pController;
	float		m_flNextAttack;
	Vector		m_vecControllerUsePos;
	float		m_yawCenter;
	float		m_yawRate;
	float		m_yawRange;
	float		m_yawTolerance;
	float		m_pitchCenter;
	float		m_pitchRate;
	float		m_pitchRange;
	float		m_pitchTolerance;
	float		m_fireLast;
	float		m_fireRate;
	float		m_lastSightTime;
	float		m_persist;
	float		m_minRange;
	float		m_maxRange;
	Vector		m_barrelPos;
	float		m_spriteScale;
	int			m_iszSpriteSmoke;
	int			m_iszSpriteFlash;
	TANKBULLET	m_bulletType;
	int			m_iBulletDamage;
	Vector		m_sightOrigin;
	int			m_spread;
	int			m_iszMaster;
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankGun
{
};
class __base(CFuncTank, 0) CFuncTankGun __packed
{
  struct vtable_for_CFuncTankGun* vtable;
public:
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankLaser
{
  int (*Save)(class CFuncTankLaser* p, CSave & save);
  int (*Restore)(class CFuncTankLaser* p, CRestore & restore);
};
class __base(CFuncTank, 0) CFuncTankLaser __packed
{
  struct vtable_for_CFuncTankLaser* vtable;
public:
	void	Activate( void );
	void	KeyValue( KeyValueData *pkvd );
	void	Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
	void	Think( void );
	CLaser *GetLaser( void );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	CLaser	*m_pLaser;
	float	m_laserTime;
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankRocket
{
};
class __base(CFuncTank, 0) CFuncTankRocket __packed
{
  struct vtable_for_CFuncTankRocket* vtable;
public:
	void Precache( void );
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CFuncTank, 0) __data_var_refs vtable_for_CFuncTankMortar
{
};
class __base(CFuncTank, 0) CFuncTankMortar __packed
{
  struct vtable_for_CFuncTankMortar* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Fire( const Vector &barrelEnd, const Vector &forward, entvars_t *pevAttacker );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CFuncTankControls
{
  fcap_t (*ObjectCaps)(class CFuncTankControls* p);
  int (*Save)(class CFuncTankControls* p, CSave & save);
  int (*Restore)(class CFuncTankControls* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CFuncTankControls __packed
{
  struct vtable_for_CFuncTankControls* vtable;
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void Think( void );
	static TYPEDESCRIPTION m_SaveData[];
	CFuncTank *m_pTank;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CFuncMortarField
{
  fcap_t (*ObjectCaps)(class CFuncMortarField* p);
  int (*Save)(class CFuncMortarField* p, CSave & save);
  int (*Restore)(class CFuncMortarField* p, CRestore & restore);
};
class __base(CBaseToggle, 0) CFuncMortarField __packed
{
  struct vtable_for_CFuncMortarField* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	void EXPORT FieldUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int m_iszXController;
	int m_iszYController;
	float m_flSpread;
	float m_flDelay;
	int m_iCount;
	int m_fControl;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CCycler
{
  fcap_t (*ObjectCaps)(class CCycler* p);
  BOOL(*IsAlive)(class CCycler* p);
  int (*Save)(class CCycler* p, CSave & save);
  int (*Restore)(class CCycler* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CCycler __packed
{
  struct vtable_for_CCycler* vtable;
public:
	void GenericCyclerSpawn(char *szModel, Vector vecMin, Vector vecMax);
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	void Spawn( void );
	void Think( void );
	void Use ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int			m_animate;
};
struct __base(vtable_for_CCycler, 0) __data_var_refs vtable_for_CGenericCycler
{
};
class __base(CCycler, 0) CGenericCycler __packed
{
  struct vtable_for_CGenericCycler* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CCycler, 0) __data_var_refs vtable_for_CCyclerProbe
{
};
class __base(CCycler, 0) CCyclerProbe __packed
{
  struct vtable_for_CCyclerProbe* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCyclerSprite
{
  fcap_t (*ObjectCaps)(class CCyclerSprite* p);
  int (*TakeDamage)(class CCyclerSprite* p, entvars_t * pevInflictor, entvars_t * pevAttacker, float flDamage, dmg_t bitsDamageType);
  int (*Save)(class CCyclerSprite* p, CSave & save);
  int (*Restore)(class CCyclerSprite* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CCyclerSprite __packed
{
  struct vtable_for_CCyclerSprite* vtable;
public:
	void Spawn( void );
	void Think( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	Animate( float frames );
	static	TYPEDESCRIPTION m_SaveData[];
	inline int		ShouldAnimate( void ) ;
	int			m_animate;
	float		m_lastTime;
	float		m_maxFrame;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CWeaponCycler
{
};
class __base(CBasePlayerWeapon, 0) CWeaponCycler __packed
{
  struct vtable_for_CWeaponCycler* vtable;
public:
	void Spawn( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p) ;
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	int m_iszModel;
	int m_iModel;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CWreckage
{
};
class __base(CBaseMonster, 0) CWreckage __packed
{
  struct vtable_for_CWreckage* vtable;
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void Think( void );
	int m_flStartTime;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGunTarget
{
  fcap_t (*ObjectCaps)(class CGunTarget* p);
  int (*Save)(class CGunTarget* p, CSave & save);
  int (*Restore)(class CGunTarget* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CGunTarget __packed
{
  struct vtable_for_CGunTarget* vtable;
public:
	void			Spawn( void );
	void			Activate( void );
	void EXPORT		Next( void );
	void EXPORT		Start( void );
	void EXPORT		Wait( void );
	void			Stop( void );
	bloodcolor_t				BloodColor( void ) ;
	class_t				Classify( void ) ;
	int				TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void			Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	Vector			BodyTarget( const Vector &posSrc ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	BOOL			m_on;
};
typedef enum
{
	TLK_ANSWER = 0,
	TLK_QUESTION,
	TLK_IDLE,
	TLK_STARE,
	TLK_USE,
	TLK_UNUSE,
	TLK_STOP,
	TLK_NOSHOOT,
	TLK_HELLO,
	TLK_PHELLO,
	TLK_PIDLE,
	TLK_PQUESTION,
	TLK_PLHURT1,
	TLK_PLHURT2,
	TLK_PLHURT3,
	TLK_SMELL,
	TLK_WOUND,
	TLK_MORTAL,
	TLK_CGROUPS,
} TALKGROUPNAMES;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CTalkMonster
{
  int		(*CanPlaySentence)( class CTalkMonster* p,  BOOL fDisregardState );
  void	(*PlaySentence)( class CTalkMonster* p,  const char *pszSentence, float duration, float volume, float attenuation );
  void	(*DeclineFollowing)( class CTalkMonster* p );
  void	(*SetAnswerQuestion)( class CTalkMonster* p,  CTalkMonster *pSpeaker );
  int		(*FriendNumber)( class CTalkMonster* p,  int arrayNumber )	;
  int		(*Save)( class CTalkMonster* p,  CSave &save );
  int		(*Restore)( class CTalkMonster* p,  CRestore &restore );
  Schedule_t *(*ScheduleFromName)( class CTalkMonster* p, const char *pName );
};
class __base(CBaseMonster, 0) CTalkMonster __packed
{
  struct vtable_for_CTalkMonster* vtable;
public:
	void			TalkInit( void );
	CBaseEntity		*FindNearestFriend(BOOL fPlayer);
	float			TargetDistance( void );
	void			StopTalking( void ) ;
	void			Precache( void );
	int				TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType);
	void			Touch(	CBaseEntity *pOther );
	void			Killed( entvars_t *pevAttacker, gib_t iGib );
	disposition_t				IRelationship ( CBaseEntity *pTarget );
	void			PlayScriptedSentence( const char *pszSentence, float duration, float volume, float attenuation, BOOL bConcurrent, CBaseEntity *pListener );
	void			KeyValue( KeyValueData *pkvd );
	void			SetActivity ( Activity newActivity );
	Schedule_t		*GetScheduleOfType ( SCHEDULE_TYPE Type );
	void			StartTask( Task_t *pTask );
	void			RunTask( Task_t *pTask );
	void			HandleAnimEvent( MonsterEvent_t *pEvent );
	void			PrescheduleThink( void );
	int				GetVoicePitch( void );
	void			IdleRespond( void );
	int				FIdleSpeak( void );
	int				FIdleStare( void );
	int				FIdleHello( void );
	void			IdleHeadTurn( Vector &vecFriend );
	int				FOkToSpeak( void );
	void			TrySmellTalk( void );
	CBaseEntity		*EnumFriends( CBaseEntity *pentPrevious, int listNumber, BOOL bTrace );
	void			AlertFriends( void );
	void			ShutUpFriends( void );
	BOOL			IsTalking( void );
	void			Talk( float flDuration );
	BOOL			CanFollow( void );
	BOOL			IsFollowing( void ) ;
	void			StopFollowing( BOOL clearSchedule );
	void			StartFollowing( CBaseEntity *pLeader );
	void			LimitFollowers( CBaseEntity *pPlayer, int maxFollowers );
	void EXPORT		FollowerUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	static char *m_szFriends[TLK_CFRIENDS];
	static float g_talkWaitTime;
	int			m_bitsSaid;
	int			m_nSpeak;
	int			m_voicePitch;
	const char	*m_szGrp[TLK_CGROUPS];
	float		m_useTime;
	int			m_iszUse;
	int			m_iszUnUse;
	float		m_flLastSaidSmelled;
	float		m_flStopTalkTime;
	EHANDLE		m_hTalkTarget;
	static Schedule_t *m_scheduleList[];
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CEnvSpark
{
  int (*Save)(class CEnvSpark* p, CSave & save);
  int (*Restore)(class CEnvSpark* p, CRestore & restore);
};
class __base(CBaseEntity, 0) CEnvSpark __packed
{
  struct vtable_for_CEnvSpark* vtable;
public:
	void	Spawn(void);
	void	Precache(void);
	void	EXPORT SparkThink(void);
	void	EXPORT SparkStart(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	EXPORT SparkStop(CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void	KeyValue(KeyValueData *pkvd);
	static	TYPEDESCRIPTION m_SaveData[];
	float	m_flDelay;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CEnvExplosion
{
  int (*Save)(class CEnvExplosion* p, CSave & save);
  int (*Restore)(class CEnvExplosion* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CEnvExplosion __packed
{
  struct vtable_for_CEnvExplosion* vtable;
public:
	void Spawn( );
	void EXPORT Smoke ( void );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	static	TYPEDESCRIPTION m_SaveData[];
	int m_iMagnitude;
	int m_spriteScale;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CButtonTarget
{
};
class __base(CBaseEntity, 0) CButtonTarget __packed
{
  struct vtable_for_CButtonTarget* vtable;
public:
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	fcap_t	ObjectCaps( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCrossbowBolt
{
};
class __base(CBaseEntity, 0) CCrossbowBolt __packed
{
  struct vtable_for_CCrossbowBolt* vtable;
	void Spawn( void );
	void Precache( void );
	class_t  Classify ( void );
	void EXPORT BubbleThink( void );
	void EXPORT BoltTouch( CBaseEntity *pOther );
	void EXPORT ExplodeThink( void );
	int m_iTrail;
public:
	static CCrossbowBolt *BoltCreate( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGrenade
{
  void (*BounceSound)(class CGrenade* p);
  bloodcolor_t (*BloodColor)(class CGrenade* p);
  void (*Killed)(class CGrenade* p, entvars_t * pevAttacker, gib_t iGib);
};
class __base(CBaseMonster, 0) CGrenade __packed
{
  struct vtable_for_CGrenade* vtable;
public:
	void Spawn( void );
	typedef enum { SATCHEL_DETONATE = 0, SATCHEL_RELEASE } SATCHELCODE;
	static CGrenade *ShootTimed( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity, float time );
	static CGrenade *ShootContact( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity );
	static CGrenade *ShootSatchelCharge( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity );
	static void UseSatchelCharges( entvars_t *pevOwner, SATCHELCODE code );
	void Explode( Vector vecSrc, Vector vecAim );
	void Explode( TraceResult *pTrace, dmg_t bitsDamageType );
	void EXPORT Smoke( void );
	void EXPORT BounceTouch( CBaseEntity *pOther );
	void EXPORT SlideTouch( CBaseEntity *pOther );
	void EXPORT ExplodeTouch( CBaseEntity *pOther );
	void EXPORT DangerSoundThink( void );
	void EXPORT PreDetonate( void );
	void EXPORT Detonate( void );
	void EXPORT DetonateUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT TumbleThink( void );
	BOOL m_fRegisteredSound;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CAirtank
{
  int (*Save)(class CAirtank* p, CSave & save);
  int (*Restore)(class CAirtank* p, CRestore & restore);
};
class __base(CGrenade, 0) CAirtank __packed
{
  struct vtable_for_CAirtank* vtable;
	void Spawn( void );
	void Precache( void );
	void EXPORT TankThink( void );
	void EXPORT TankTouch( CBaseEntity *pOther );
	bloodcolor_t	 BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	static	TYPEDESCRIPTION m_SaveData[];
	int	 m_state;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CMortar
{
};
class __base(CGrenade, 0) CMortar __packed
{
  struct vtable_for_CMortar* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void EXPORT MortarExplode( void );
	int m_spriteTexture;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CRpgRocket
{
};
class __base(CGrenade, 0) CRpgRocket __packed
{
  struct vtable_for_CRpgRocket* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void EXPORT FollowThink( void );
	void EXPORT IgniteThink( void );
	void EXPORT RocketTouch( CBaseEntity *pOther );
	static CRpgRocket *CreateRpgRocket( Vector vecOrigin, Vector vecAngles, CBaseEntity *pOwner, CRpg *pLauncher );
	int m_iTrail;
	float m_flIgniteTime;
	CRpg *m_pLauncher;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CSatchelCharge
{
};
class __base(CGrenade, 0) CSatchelCharge __packed
{
  struct vtable_for_CSatchelCharge* vtable;
	void Spawn( void );
	void Precache( void );
	void BounceSound( void );
	void EXPORT SatchelSlide( CBaseEntity *pOther );
	void EXPORT SatchelThink( void );
public:
	void Deactivate( void );
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CSqueakGrenade
{
  int (*Save)(class CSqueakGrenade* p, CSave & save);
  int (*Restore)(class CSqueakGrenade* p, CRestore & restore);
};
class __base(CGrenade, 0) CSqueakGrenade __packed
{
  struct vtable_for_CSqueakGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	class_t  Classify( void );
	void EXPORT SuperBounceTouch( CBaseEntity *pOther );
	void EXPORT HuntThink( void );
	bloodcolor_t  BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void GibMonster( void );
	static	TYPEDESCRIPTION m_SaveData[];
	static float m_flNextBounceSoundTime;
	float m_flDie;
	Vector m_vecTarget;
	float m_flNextHunt;
	float m_flNextHit;
	Vector m_posPrev;
	EHANDLE m_hOwner;
	int  m_iMyClass;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CTripmineGrenade
{
  int (*Save)(class CTripmineGrenade* p, CSave & save);
  int (*Restore)(class CTripmineGrenade* p, CRestore & restore);
};
class __base(CGrenade, 0) CTripmineGrenade __packed
{
  struct vtable_for_CTripmineGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void EXPORT WarningThink( void );
	void EXPORT PowerupThink( void );
	void EXPORT BeamBreakThink( void );
	void EXPORT DelayDeathThink( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void MakeBeam( void );
	void KillBeam( void );
	float		m_flPowerUp;
	Vector		m_vecDir;
	Vector		m_vecEnd;
	float		m_flBeamLength;
	EHANDLE		m_hOwner;
	CBeam		*m_pBeam;
	Vector		m_posOwner;
	Vector		m_angleOwner;
	edict_t		*m_pRealOwner;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CHornet
{
  int (*Save)(class CHornet* p, CSave & save);
  int (*Restore)(class CHornet* p, CRestore & restore);
};
class __base(CBaseMonster, 0) CHornet __packed
{
  struct vtable_for_CHornet* vtable;
public:
	void Spawn( void );
	void Precache( void );
	class_t	 Classify ( void );
	disposition_t  IRelationship ( CBaseEntity *pTarget );
	static	TYPEDESCRIPTION m_SaveData[];
	void IgniteTrail( void );
	void EXPORT StartTrack ( void );
	void EXPORT StartDart ( void );
	void EXPORT TrackTarget ( void );
	void EXPORT TrackTouch ( CBaseEntity *pOther );
	void EXPORT DartTouch( CBaseEntity *pOther );
	void EXPORT DieTouch ( CBaseEntity *pOther );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	float			m_flStopAttack;
	int				m_iHornetType;
	float			m_flFlySpeed;
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CCrossbowAmmo
{
};
class __base(CBasePlayerAmmo, 0) CCrossbowAmmo __packed
{
  struct vtable_for_CCrossbowAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CEgonAmmo
{
};
class __base(CBasePlayerAmmo, 0) CEgonAmmo __packed
{
  struct vtable_for_CEgonAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CGaussAmmo
{
};
class __base(CBasePlayerAmmo, 0) CGaussAmmo __packed
{
  struct vtable_for_CGaussAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CGlockAmmo
{
};
class __base(CBasePlayerAmmo, 0) CGlockAmmo __packed
{
  struct vtable_for_CGlockAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5AmmoClip
{
};
class __base(CBasePlayerAmmo, 0) CMP5AmmoClip __packed
{
  struct vtable_for_CMP5AmmoClip* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5Chainammo
{
};
class __base(CBasePlayerAmmo, 0) CMP5Chainammo __packed
{
  struct vtable_for_CMP5Chainammo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CMP5AmmoGrenade
{
};
class __base(CBasePlayerAmmo, 0) CMP5AmmoGrenade __packed
{
  struct vtable_for_CMP5AmmoGrenade* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CPythonAmmo
{
};
class __base(CBasePlayerAmmo, 0) CPythonAmmo __packed
{
  struct vtable_for_CPythonAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CRpgAmmo
{
};
class __base(CBasePlayerAmmo, 0) CRpgAmmo __packed
{
  struct vtable_for_CRpgAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerAmmo, 0) __data_var_refs vtable_for_CShotgunAmmo
{
};
class __base(CBasePlayerAmmo, 0) CShotgunAmmo __packed
{
  struct vtable_for_CShotgunAmmo* vtable;
	void Spawn( void );
	void Precache( void );
	BOOL AddAmmo( CBaseEntity *pOther );
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CCrossbow
{
};
class __base(CBasePlayerWeapon, 0) CCrossbow __packed
{
  struct vtable_for_CCrossbow* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( ) ;
	int GetItemInfo(ItemInfo *p);
	void FireBolt( void );
	void FireSniperBolt( void );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( );
	void Holster( int skiplocal = 0 );
	void Reload( void );
	void WeaponIdle( void );
	int m_fInZoom;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CCrowbar
{
};
class __base(CBasePlayerWeapon, 0) CCrowbar __packed
{
  struct vtable_for_CCrowbar* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	void EXPORT SwingAgain( void );
	void EXPORT Smack( void );
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	int Swing( int fFirst );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	int m_iSwing;
	TraceResult m_trHit;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CEgon
{
};
class __base(CBasePlayerWeapon, 0) CEgon __packed
{
  struct vtable_for_CEgon* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	void CreateEffect( void );
	void UpdateEffect( const Vector &startPoint, const Vector &endPoint, float timeBlend );
	void DestroyEffect( void );
	void EndAttack( void );
	void Attack( void );
	void PrimaryAttack( void );
	void WeaponIdle( void );
	static int g_fireAnims1[];
	static int g_fireAnims2[];
	float m_flAmmoUseTime;
	float GetPulseInterval( void );
	float GetDischargeInterval( void );
	void Fire( const Vector &vecOrigSrc, const Vector &vecDir );
	BOOL HasAmmo( void );
	void UseAmmo( int count );
	enum EGON_FIRESTATE { FIRE_OFF, FIRE_CHARGE };
	enum EGON_FIREMODE { FIRE_NARROW, FIRE_WIDE};
private:
	float				m_shootTime;
	CBeam				*m_pBeam;
	CBeam				*m_pNoise;
	CSprite				*m_pSprite;
	EGON_FIRESTATE		m_fireState;
	EGON_FIREMODE		m_fireMode;
	float				m_shakeTime;
	BOOL				m_deployed;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CGauss
{
};
class __base(CBasePlayerWeapon, 0) CGauss __packed
{
  struct vtable_for_CGauss* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void WeaponIdle( void );
	int m_fInAttack;
	float m_flStartCharge;
	float m_flPlayAftershock;
	void StartFire( void );
	void Fire( Vector vecOrigSrc, Vector vecDirShooting, float flDamage );
	float GetFullChargeTime( void );
	int m_iBalls;
	int m_iGlow;
	int m_iBeam;
	int m_iSoundState;
	float m_flNextAmmoBurn;
	BOOL m_fPrimaryFire;
private:
	unsigned short m_usGaussFire;
	unsigned short m_usGaussSpin;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CGlock
{
  BOOL (*UseDecrement)( class CGlock* p );
};
class __base(CBasePlayerWeapon, 0) CGlock __packed
{
  struct vtable_for_CGlock* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void GlockFire( float flSpread, float flCycleTime, BOOL fUseAutoAim );
	BOOL Deploy( void );
	void Reload( void );
	void WeaponIdle( void );
private:
	int m_iShell;
	unsigned short m_usFireGlock1;
	unsigned short m_usFireGlock2;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CHandGrenade
{
};
class __base(CBasePlayerWeapon, 0) CHandGrenade __packed
{
  struct vtable_for_CHandGrenade* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	BOOL Deploy( void );
	BOOL CanHolster( void );
	void Holster( int skiplocal = 0 );
	void WeaponIdle( void );
	float m_flStartThrow;
	float m_flReleaseThrow;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CHgun
{
};
class __base(CBasePlayerWeapon, 0) CHgun __packed
{
  struct vtable_for_CHgun* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	BOOL IsUseable( void );
	void Holster( int skiplocal = 0 );
	void Reload( void );
	void WeaponIdle( void );
	float m_flNextAnimTime;
	float m_flRechargeTime;
	int m_iFirePhase;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CMP5
{
};
class __base(CBasePlayerWeapon, 0) CMP5 __packed
{
  struct vtable_for_CMP5* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int SecondaryAmmoIndex( void );
	BOOL Deploy( void );
	void Reload( void );
	void WeaponIdle( void );
	float m_flNextAnimTime;
	int m_iShell;
private:
	unsigned short m_usMP5;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CPython
{
};
class __base(CBasePlayerWeapon, 0) CPython __packed
{
  struct vtable_for_CPython* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	void Reload( void );
	void WeaponIdle( void );
	float m_flSoundDelay;
	BOOL m_fInZoom;
private:
	unsigned short m_usFirePython;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CLaserSpot
{
};
class __base(CBaseEntity, 0) CLaserSpot __packed
{
  struct vtable_for_CLaserSpot* vtable;
	void Spawn( void );
	void Precache( void );
	fcap_t	ObjectCaps( void ) ;
public:
	void Suspend( float flSuspendTime );
	void EXPORT Revive( void );
	static CLaserSpot *CreateSpot( void );
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CRpg
{
};
class __base(CBasePlayerWeapon, 0) CRpg __packed
{
  struct vtable_for_CRpg* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void Reload( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	BOOL Deploy( void );
	BOOL CanHolster( void );
	void Holster( int skiplocal = 0 );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	void WeaponIdle( void );
	void UpdateSpot( void );
	BOOL ShouldWeaponIdle( void ) ;
	CLaserSpot *m_pSpot;
	int m_fSpotActive;
	int m_cActiveRockets;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CSatchel
{
};
class __base(CBasePlayerWeapon, 0) CSatchel __packed
{
  struct vtable_for_CSatchel* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	int AddDuplicate( CBasePlayerItem *pOriginal );
	BOOL CanDeploy( void );
	BOOL Deploy( void );
	BOOL IsUseable( void );
	void Holster( int skiplocal = 0 );
	void WeaponIdle( void );
	void Throw( void );
	int m_chargeReady;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CShotgun
{
};
class __base(CBasePlayerWeapon, 0) CShotgun __packed
{
  struct vtable_for_CShotgun* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	int iItemSlot( ) ;
	int GetItemInfo(ItemInfo *p);
	int AddToPlayer( CBasePlayer *pPlayer );
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( );
	void Reload( void );
	void WeaponIdle( void );
	int m_fInReload;
	float m_flNextReload;
	int m_iShell;
	float m_flPumpTime;
private:
	unsigned short m_usDoubleFire;
	unsigned short m_usSingleFire;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CSqueak
{
};
class __base(CBasePlayerWeapon, 0) CSqueak __packed
{
  struct vtable_for_CSqueak* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void PrimaryAttack( void );
	void SecondaryAttack( void );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	void WeaponIdle( void );
	int m_fJustThrown;
};
struct __base(vtable_for_CBasePlayerWeapon, 0) __data_var_refs vtable_for_CTripmine
{
};
class __base(CBasePlayerWeapon, 0) CTripmine __packed
{
  struct vtable_for_CTripmine* vtable;
public:
	void Spawn( void );
	void Precache( void );
	int iItemSlot( void ) ;
	int GetItemInfo(ItemInfo *p);
	void SetObjectCollisionBox( void );
	void PrimaryAttack( void );
	BOOL Deploy( void );
	void Holster( int skiplocal = 0 );
	void WeaponIdle( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CDeadHEV
{
};
class __base(CBaseMonster, 0) CDeadHEV __packed
{
  struct vtable_for_CDeadHEV* vtable;
public:
	void Spawn( void );
	class_t	Classify ( void ) ;
	void KeyValue( KeyValueData *pkvd );
	int	m_iPose;
	static char *m_szPoses[4];
};
struct __base(vtable_for_CBaseAnimating, 0) __data_var_refs vtable_for_CActAnimating
{
  fcap_t (*ObjectCaps)(class CActAnimating* p);
  int (*Save)(class CActAnimating* p, CSave & save);
  int (*Restore)(class CActAnimating* p, CRestore & restore);
};
class __base(CBaseAnimating, 0) CActAnimating __packed
{
  struct vtable_for_CActAnimating* vtable;
public:
	void			SetActivity( Activity act );
	inline Activity	GetActivity( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	Activity	m_Activity;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenPLight
{
  int (*Save)(class CXenPLight* p, CSave & save);
  int (*Restore)(class CXenPLight* p, CRestore & restore);
};
class __base(CActAnimating, 0) CXenPLight __packed
{
  struct vtable_for_CXenPLight* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	void		LightOn( void );
	void		LightOff( void );
	static	TYPEDESCRIPTION m_SaveData[];
private:
	CSprite		*m_pGlow;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenHair
{
};
class __base(CActAnimating, 0) CXenHair __packed
{
  struct vtable_for_CXenHair* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Think( void );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CXenTreeTrigger
{
};
class __base(CBaseEntity, 0) CXenTreeTrigger __packed
{
  struct vtable_for_CXenTreeTrigger* vtable;
public:
	void		Touch( CBaseEntity *pOther );
	static CXenTreeTrigger *TriggerCreate( edict_t *pOwner, const Vector &position );
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenTree
{
  int (*Save)(class CXenTree* p, CSave & save);
  int (*Restore)(class CXenTree* p, CRestore & restore);
};
class __base(CActAnimating, 0) CXenTree __packed
{
  struct vtable_for_CXenTree* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	int			TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType ) ;
	void		HandleAnimEvent( MonsterEvent_t *pEvent );
	void		Attack( void );
	class_t			Classify( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	static const char *pAttackHitSounds[];
	static const char *pAttackMissSounds[];
private:
	CXenTreeTrigger	*m_pTrigger;
};
struct __base(vtable_for_CActAnimating, 0) __data_var_refs vtable_for_CXenSpore
{
};
class __base(CActAnimating, 0) CXenSpore __packed
{
  struct vtable_for_CXenSpore* vtable;
public:
	void		Spawn( void );
	void		Precache( void );
	void		Touch( CBaseEntity *pOther );
	void		Think( void );
	int			TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType ) ;
	void		Attack( void ) ;
	static const char *pModelNames[];
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeSmall
{
};
class __base(CXenSpore, 0) CXenSporeSmall __packed
{
  struct vtable_for_CXenSporeSmall* vtable;
	void		Spawn( void );
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeMed
{
};
class __base(CXenSpore, 0) CXenSporeMed __packed
{
  struct vtable_for_CXenSporeMed* vtable;
	void		Spawn( void );
};
struct __base(vtable_for_CXenSpore, 0) __data_var_refs vtable_for_CXenSporeLarge
{
};
class __base(CXenSpore, 0) CXenSporeLarge __packed
{
  struct vtable_for_CXenSporeLarge* vtable;
	void		Spawn( void );
	static const Vector m_hullSizes[];
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CXenHull
{
};
class __base(CPointEntity, 0) CXenHull __packed
{
  struct vtable_for_CXenHull* vtable;
public:
	static CXenHull	*CreateHull( CBaseEntity *source, const Vector &mins, const Vector &maxs, const Vector &offset );
	class_t			Classify( void ) ;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CBaseTrigger
{
  fcap_t (*ObjectCaps)(class CBaseTrigger* p);
};
class __base(CBaseToggle, 0) CBaseTrigger __packed
{
  struct vtable_for_CBaseTrigger* vtable;
public:
	void EXPORT TeleportTouch ( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT MultiTouch( CBaseEntity *pOther );
	void EXPORT HurtTouch ( CBaseEntity *pOther );
	void EXPORT CDAudioTouch ( CBaseEntity *pOther );
	void ActivateMultiTrigger( CBaseEntity *pActivator );
	void EXPORT MultiWaitOver( void );
	void EXPORT CounterUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT ToggleUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void InitTrigger( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerHurt
{
};
class __base(CBaseTrigger, 0) CTriggerHurt __packed
{
  struct vtable_for_CTriggerHurt* vtable;
public:
	void Spawn( void );
	void EXPORT RadiationThink( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerMonsterJump
{
};
class __base(CBaseTrigger, 0) CTriggerMonsterJump __packed
{
  struct vtable_for_CTriggerMonsterJump* vtable;
public:
	void Spawn( void );
	void Touch( CBaseEntity *pOther );
	void Think( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerCDAudio
{
  void (*Use)(class CTriggerCDAudio* p, CBaseEntity * pActivator, CBaseEntity * pCaller, USE_TYPE useType, float value);
};
class __base(CBaseTrigger, 0) CTriggerCDAudio __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void Spawn( void );
	void PlayTrack( void );
	void Touch ( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerMultiple
{
};
class __base(CBaseTrigger, 0) CTriggerMultiple __packed
{
  struct vtable_for_CTriggerMultiple* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CTriggerMultiple, 0) __data_var_refs vtable_for_CTriggerOnce
{
};
class __base(CTriggerMultiple, 0) CTriggerOnce __packed
{
  struct vtable_for_CTriggerOnce* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerCounter
{
};
class __base(CBaseTrigger, 0) CTriggerCounter __packed
{
  struct vtable_for_CTriggerCounter* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CTriggerVolume
{
};
class __base(CPointEntity, 0) CTriggerVolume __packed
{
  struct vtable_for_CTriggerVolume* vtable;
public:
	void		Spawn( void );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CFireAndDie
{
};
class __base(CBaseDelay, 0) CFireAndDie __packed
{
  struct vtable_for_CFireAndDie* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void Think( void );
	fcap_t ObjectCaps( void ) ;
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CChangeLevel
{
  int (*Save)(class CChangeLevel* p, CSave & save);
  int (*Restore)(class CChangeLevel* p, CRestore & restore);
};
class __base(CBaseTrigger, 0) CChangeLevel __packed
{
  struct vtable_for_CChangeLevel* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT UseChangeLevel ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT TriggerChangeLevel( void );
	void EXPORT ExecuteChangeLevel( void );
	void EXPORT TouchChangeLevel( CBaseEntity *pOther );
	void ChangeLevelNow( CBaseEntity *pActivator );
	static edict_t *FindLandmark( const char *pLandmarkName );
	static int ChangeList( LEVELLIST *pLevelList, int maxList );
	static int AddTransitionToList( LEVELLIST *pLevelList, int listCount, const char *pMapName, const char *pLandmarkName, edict_t *pentLandmark );
	static int InTransitionVolume( CBaseEntity *pEntity, char *pVolumeName );
	static	TYPEDESCRIPTION m_SaveData[];
	char m_szMapName[cchMapNameMost];
	char m_szLandmarkName[cchMapNameMost];
	int		m_changeTarget;
	float	m_changeTargetDelay;
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CLadder
{
};
class __base(CBaseTrigger, 0) CLadder __packed
{
  struct vtable_for_CBaseDMStart* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Precache( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerPush
{
};
class __base(CBaseTrigger, 0) CTriggerPush __packed
{
  struct vtable_for_CTriggerPush* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void Touch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerTeleport
{
};
class __base(CBaseTrigger, 0) CTriggerTeleport __packed
{
  struct vtable_for_CTriggerTeleport* vtable;
public:
	void Spawn( void );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerSave
{
};
class __base(CBaseTrigger, 0) CTriggerSave __packed
{
  struct vtable_for_CTriggerSave* vtable;
public:
	void Spawn( void );
	void EXPORT SaveTouch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerEndSection
{
};
class __base(CBaseTrigger, 0) CTriggerEndSection __packed
{
  struct vtable_for_CTriggerEndSection* vtable;
public:
	void Spawn( void );
	void EXPORT EndSectionTouch( CBaseEntity *pOther );
	void KeyValue( KeyValueData *pkvd );
	void EXPORT EndSectionUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
};
struct __base(vtable_for_CBaseTrigger, 0) __data_var_refs vtable_for_CTriggerGravity
{
};
class __base(CBaseTrigger, 0) CTriggerGravity __packed
{
  struct vtable_for_CTriggerGravity* vtable;
public:
	void Spawn( void );
	void EXPORT GravityTouch( CBaseEntity *pOther );
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerChangeTarget
{
  int (*Save)(class CTriggerChangeTarget* p, CSave & save);
  int (*Restore)(class CTriggerChangeTarget* p, CRestore & restore);
};
class __base(CBaseDelay, 0) CTriggerChangeTarget __packed
{
  struct vtable_for_CTriggerChangeTarget* vtable;
public:
	void KeyValue( KeyValueData *pkvd );
	void Spawn( void );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	fcap_t ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
private:
	int		m_iszNewTarget;
};
struct __base(vtable_for_CBaseDelay, 0) __data_var_refs vtable_for_CTriggerCamera
{
  int (*Save)(class CTriggerCamera* p, CSave & save);
  int (*Restore)(class CTriggerCamera* p, CRestore & restore);
  fcap_t (*ObjectCaps)(class CTriggerCamera* p);
};
class __base(CBaseDelay, 0) CTriggerCamera __packed
{
  struct vtable_for_CTriggerCamera* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT FollowTarget( void );
	void Move(void);
	static	TYPEDESCRIPTION m_SaveData[];
	EHANDLE m_hPlayer;
	EHANDLE m_hTarget;
	CBaseEntity *m_pentPath;
	int	  m_sPath;
	float m_flWait;
	float m_flReturnTime;
	float m_flStopTime;
	float m_moveDistance;
	float m_targetSpeed;
	float m_initialSpeed;
	float m_acceleration;
	float m_deceleration;
	int	  m_state;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CFlyingMonster __packed
{
};
class __base(CBaseMonster, 0) CFlyingMonster __packed
{
  struct vtable_for_CFlyingMonster* vtable;
public:
	localmove_t 		CheckLocalMove ( const Vector &vecStart, const Vector &vecEnd, CBaseEntity *pTarget, float *pflDist );
	BOOL		FTriangulate ( const Vector &vecStart , const Vector &vecEnd, float flDist, CBaseEntity *pTargetEnt, Vector *pApex );
	Activity	GetStoppedActivity( void );
	void		Killed( entvars_t *pevAttacker, gib_t iGib );
	void		Stop( void );
	float		ChangeYaw( int speed );
	void		HandleAnimEvent( MonsterEvent_t *pEvent );
	void		MoveExecute( CBaseEntity *pTargetEnt, const Vector &vecDir, float flInterval );
	void		Move( float flInterval = 0.1 );
	BOOL		ShouldAdvanceRoute( float flWaypointDist );
	inline void	SetFlyingMomentum( float momentum ) ;
	inline void	SetFlyingFlapSound( const char *pFlapSound ) ;
	inline void	SetFlyingSpeed( float speed ) ;
	float		CeilingZ( const Vector &position );
	float		FloorZ( const Vector &position );
	BOOL		ProbeZ( const Vector &position, const Vector &probe, float *pFraction );
protected:
	Vector		m_vecTravel;
	float		m_flightSpeed;
	float		m_stopTime;
	float		m_momentum;
	const char	*m_pFlapSound;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CFlockingFlyerFlock __packed
{
	int		(*Save)( class CFlockingFlyerFlock* p,  CSave &save );
	int		(*Restore)( class CFlockingFlyerFlock* p,  CRestore &restore );
};
class __base(CBaseMonster, 0) CFlockingFlyerFlock __packed
{
  struct vtable_for_CFlockingFlyerFlock* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
	void SpawnFlock( void );
	static	TYPEDESCRIPTION m_SaveData[];
	static  void PrecacheFlockSounds( void );
	int		m_cFlockSize;
	float	m_flFlockRadius;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CFlockingFlyer __packed
{
	int		(*Save)( class CFlockingFlyer* p,  CSave &save );
	int		(*Restore)( class CFlockingFlyer* p,  CRestore &restore );
};
class __base(CBaseMonster, 0) CFlockingFlyer __packed
{
  struct vtable_for_CFlockingFlyer* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SpawnCommonCode( void );
	void EXPORT IdleThink( void );
	void BoidAdvanceFrame( void );
	void EXPORT FormFlock( void );
	void EXPORT Start( void );
	void EXPORT FlockLeaderThink( void );
	void EXPORT FlockFollowerThink( void );
	void EXPORT FallHack( void );
	void MakeSound( void );
	void AlertFlock( void );
	void SpreadFlock( void );
	void SpreadFlock2( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void Poop ( void );
	BOOL FPathBlocked( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int IsLeader( void ) ;
	int	InSquad( void ) ;
	int	SquadCount( void );
	void SquadRemove( CFlockingFlyer *pRemove );
	void SquadUnlink( void );
	void SquadAdd( CFlockingFlyer *pAdd );
	void SquadDisband( void );
	CFlockingFlyer *m_pSquadLeader;
	CFlockingFlyer *m_pSquadNext;
	BOOL	m_fTurning;
	BOOL	m_fCourseAdjust;
	BOOL	m_fPathBlocked;
	Vector	m_vecReferencePoint;
	Vector	m_vecAdjustedVelocity;
	float	m_flGoalSpeed;
	float	m_flLastBlockedTime;
	float	m_flFakeBlockedTime;
	float	m_flAlertTime;
	float	m_flFlockNextSoundTime;
};
struct __base(vtable_for_CSquadMonster, 0) __data_var_refs vtable_for_CAGrunt __packed
{
	Schedule_t *(*ScheduleFromName)( class CAGrunt* p, const char *pName );
	int		(*Save)( class CAGrunt* p,  CSave &save );
	int		(*Restore)( class CAGrunt* p,  CRestore &restore );
};
class __base(CSquadMonster, 0) CAGrunt __packed
{
  struct vtable_for_CAGrunt* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed ( void );
	class_t  Classify ( void );
	bitssound_t  ISoundMask ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void SetObjectCollisionBox( void );
	Schedule_t* GetSchedule ( void );
	Schedule_t* GetScheduleOfType ( SCHEDULE_TYPE Type );
	BOOL FCanCheckAttacks ( void );
	BOOL CheckMeleeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	void StartTask ( Task_t *pTask );
	void AlertSound( void );
	void DeathSound ( void );
	void PainSound ( void );
	void AttackSound ( void );
	void PrescheduleThink ( void );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	disposition_t IRelationship( CBaseEntity *pTarget );
	void StopTalking ( void );
	BOOL ShouldSpeak( void );
	static Schedule_t *m_scheduleList[];
	static	TYPEDESCRIPTION m_SaveData[];
	static const char *pAttackHitSounds[];
	static const char *pAttackMissSounds[];
	static const char *pAttackSounds[];
	static const char *pDieSounds[];
	static const char *pPainSounds[];
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	BOOL	m_fCanHornetAttack;
	float	m_flNextHornetAttackCheck;
	float m_flNextPainTime;
	float	m_flNextSpeakTime;
	float	m_flNextWordTime;
	int		m_iLastWord;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CApache __packed
{
};
class __base(CBaseMonster, 0) CApache __packed
{
  struct vtable_for_CApache* vtable;
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	class_t  Classify( void ) ;
	bloodcolor_t  BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void GibMonster( void );
	void SetObjectCollisionBox( void );
	void EXPORT HuntThink( void );
	void EXPORT FlyTouch( CBaseEntity *pOther );
	void EXPORT CrashTouch( CBaseEntity *pOther );
	void EXPORT DyingThink( void );
	void EXPORT StartupUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT NullThink( void );
	void ShowDamage( void );
	void Flight( void );
	void FireRocket( void );
	BOOL FireGun( void );
	int  TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	int m_iRockets;
	float m_flForce;
	float m_flNextRocket;
	Vector m_vecTarget;
	Vector m_posTarget;
	Vector m_vecDesired;
	Vector m_posDesired;
	Vector m_vecGoal;
	Vector m_angGun;
	float m_flLastSeen;
	float m_flPrevSeen;
	int m_iSoundState;
	int m_iSpriteTexture;
	int m_iExplode;
	int m_iBodyGibs;
	float m_flGoalSpeed;
	int m_iDoSmokePuff;
	CBeam *m_pBeam;
};
struct __base(vtable_for_CGrenade, 0) __data_var_refs vtable_for_CApacheHVR __packed
{
};
class __base(CGrenade, 0) CApacheHVR __packed
{
  struct vtable_for_CApacheHVR* vtable;
	void Spawn( void );
	void Precache( void );
	void EXPORT IgniteThink( void );
	void EXPORT AccelerateThink( void );
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	int m_iTrail;
	Vector m_vecForward;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBarnacle __packed
{
	int		(*Save)( class CBarnacle* p,  CSave &save );
	int		(*Restore)( class CBarnacle* p,  CRestore &restore );
};
class __base(CBaseMonster, 0) CBarnacle __packed
{
  struct vtable_for_CBarnacle* vtable;
public:
	void Spawn( void );
	void Precache( void );
	CBaseEntity *TongueTouchEnt ( float *pflLength );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void EXPORT BarnacleThink ( void );
	void EXPORT WaitTillDead ( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	static	TYPEDESCRIPTION m_SaveData[];
	float m_flAltitude;
	float m_flKillVictimTime;
	int	  m_cGibs;
	BOOL  m_fTongueExtended;
	BOOL  m_fLiftingPrey;
	float m_flTongueAdj;
};
struct __base(vtable_for_CTalkMonster, 0) __data_var_refs vtable_for_CBarney __packed
{
	fcap_t	(*ObjectCaps)( class CBarney* p );
	int		(*Save)( class CBarney* p,  CSave &save );
	int		(*Restore)( class CBarney* p,  CRestore &restore );
	Schedule_t *(*ScheduleFromName)( class CBarney* p, const char *pName );
};
class __base(CTalkMonster, 0) CBarney __packed
{
  struct vtable_for_CBarney* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	bitssound_t  ISoundMask( void );
	void BarneyFirePistol( void );
	void AlertSound( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void RunTask( Task_t *pTask );
	void StartTask( Task_t *pTask );
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType);
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	void DeclineFollowing( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	Schedule_t *GetSchedule ( void );
	MONSTERSTATE GetIdealState ( void );
	void DeathSound( void );
	void PainSound( void );
	void TalkInit( void );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	static	TYPEDESCRIPTION m_SaveData[];
	BOOL	m_fGunDrawn;
	float	m_painTime;
	float	m_checkAttackTime;
	BOOL	m_lastAttackCheck;
	float	m_flPlayerDamage;
	static Schedule_t *m_scheduleList[];
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CDeadBarney __packed
{
};
class __base(CBaseMonster, 0) CDeadBarney __packed
{
  struct vtable_for_CDeadBarney* vtable;
public:
	void Spawn( void );
	class_t	Classify ( void ) ;
	void KeyValue( KeyValueData *pkvd );
	int	m_iPose;
	static char *m_szPoses[3];
};
struct __base(vtable_for_CPointEntity, 0) __data_var_refs vtable_for_CInfoBM __packed
{
	int		(*Save)( class CInfoBM* p,  CSave &save );
	int		(*Restore)( class CInfoBM* p,  CRestore &restore );
};
class __base(CPointEntity, 0) CInfoBM __packed
{
  struct vtable_for_CInfoBM* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData* pkvd );
	static	TYPEDESCRIPTION m_SaveData[];
	int		m_preSequence;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CBMortar __packed
{
	int		(*Save)( class CBMortar* p,  CSave &save );
	int		(*Restore)( class CBMortar* p,  CRestore &restore );
};
class __base(CBaseEntity, 0) CBMortar __packed
{
  struct vtable_for_CBMortar* vtable;
public:
	void Spawn( void );
	static CBMortar *Shoot( edict_t *pOwner, Vector vecStart, Vector vecVelocity );
	void Touch( CBaseEntity *pOther );
	void EXPORT Animate( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int  m_maxFrame;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBigMomma __packed
{
	int	(*Save)( class CBigMomma* p,  CSave &save );
	int	(*Restore)( class CBigMomma* p,  CRestore &restore );
	Schedule_t *(*ScheduleFromName)( class CBigMomma* p, const char *pName );
};
class __base(CBaseMonster, 0) CBigMomma __packed
{
  struct vtable_for_CBigMomma* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void KeyValue( KeyValueData *pkvd );
	void Activate( void );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void		RunTask( Task_t *pTask );
	void		StartTask( Task_t *pTask );
	Schedule_t	*GetSchedule( void );
	Schedule_t	*GetScheduleOfType( SCHEDULE_TYPE Type );
	void		TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType );
	void NodeStart( int iszNextNode );
	void NodeReach( void );
	BOOL ShouldGoToNode( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void LayHeadcrab( void );
	int GetNodeSequence( void );
	int GetNodePresequence( void );
	float GetNodeDelay( void );
	float GetNodeRange( void );
	float GetNodeYaw( void );
	void OverrideReset( void );
	void DeathNotice( entvars_t *pevChild );
	BOOL CanLayCrab( void );
	void LaunchMortar( void );
	void SetObjectCollisionBox( void );
	BOOL CheckMeleeAttack1( float flDot, float flDist );
	BOOL CheckMeleeAttack2( float flDot, float flDist );
	BOOL CheckRangeAttack1( float flDot, float flDist );
	static	TYPEDESCRIPTION m_SaveData[];
	static const char *pChildDieSounds[];
	static const char *pSackSounds[];
	static const char *pDeathSounds[];
	static const char *pAttackSounds[];
	static const char *pAttackHitSounds[];
	static const char *pBirthSounds[];
	static const char *pAlertSounds[];
	static const char *pPainSounds[];
	static const char *pFootSounds[];
	static Schedule_t *m_scheduleList[];
private:
	float	m_nodeTime;
	float	m_crabTime;
	float	m_mortarTime;
	float	m_painSoundTime;
	int		m_crabCount;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBloater __packed
{
};
class __base(CBaseMonster, 0) CBloater __packed
{
  struct vtable_for_CBloater* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void PainSound( void );
	void AlertSound( void );
	void IdleSound( void );
	void AttackSnd( void );
	BOOL CheckRangeAttack1 ( float flDot, float flDist ) ;
	BOOL CheckRangeAttack2 ( float flDot, float flDist ) ;
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSquidSpit __packed
{
	int		(*Save)( class CSquidSpit* p,  CSave &save );
	int		(*Restore)( class CSquidSpit* p,  CRestore &restore );
};
class __base(CBaseEntity, 0) CSquidSpit __packed
{
  struct vtable_for_CSquidSpit* vtable;
public:
	void Spawn( void );
	static void Shoot( entvars_t *pevOwner, Vector vecStart, Vector vecVelocity );
	void Touch( CBaseEntity *pOther );
	void EXPORT Animate( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int  m_maxFrame;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBullsquid __packed
{
  Schedule_t *(*ScheduleFromName)( class CBullsquid* p, const char *pName );
};
class __base(CBaseMonster, 0) CBullsquid __packed
{
  struct vtable_for_CBullsquid* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	bitssound_t  ISoundMask( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void IdleSound( void );
	void PainSound( void );
	void DeathSound( void );
	void AlertSound ( void );
	void AttackSound( void );
	void StartTask ( Task_t *pTask );
	void RunTask ( Task_t *pTask );
	BOOL CheckMeleeAttack1 ( float flDot, float flDist );
	BOOL CheckMeleeAttack2 ( float flDot, float flDist );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	void RunAI( void );
	BOOL FValidateHintType ( short sHint );
	Schedule_t *GetSchedule( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	disposition_t IRelationship ( CBaseEntity *pTarget );
	bitscond_t IgnoreConditions ( void );
	MONSTERSTATE GetIdealState ( void );
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static Schedule_t *m_scheduleList[];
	static TYPEDESCRIPTION m_SaveData[];
	BOOL m_fCanThreatDisplay;
	float m_flLastHurtTime;
	float m_flNextSpitTime;
};
struct __base(vtable_for_CSquadMonster, 0) __data_var_refs vtable_for_CController __packed
{
	int		(*Save)( class CController* p,  CSave &save );
	int		(*Restore)( class CController* p,  CRestore &restore );
  Schedule_t *(*ScheduleFromName)( class CController* p, const char *pName );
};
class __base(CSquadMonster, 0) CController __packed
{
  struct vtable_for_CController* vtable;
public:
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void RunAI( void );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack2 ( float flDot, float flDist );
	BOOL CheckMeleeAttack1 ( float flDot, float flDist );
	Schedule_t* GetSchedule ( void );
	Schedule_t* GetScheduleOfType ( SCHEDULE_TYPE Type );
	void StartTask ( Task_t *pTask );
	void RunTask ( Task_t *pTask );
	static Schedule_t *m_scheduleList[];
	void Stop( void );
	void Move ( float flInterval );
	localmove_t  CheckLocalMove ( const Vector &vecStart, const Vector &vecEnd, CBaseEntity *pTarget, float *pflDist );
	void MoveExecute( CBaseEntity *pTargetEnt, const Vector &vecDir, float flInterval );
	void SetActivity ( Activity NewActivity );
	BOOL ShouldAdvanceRoute( float flWaypointDist );
	int LookupFloat( );
	float m_flNextFlinch;
	float m_flShootTime;
	float m_flShootEnd;
	void PainSound( void );
	void AlertSound( void );
	void IdleSound( void );
	void AttackSound( void );
	void DeathSound( void );
	static const char *pAttackSounds[];
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	static const char *pPainSounds[];
	static const char *pDeathSounds[];
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void GibMonster( void );
	CSprite *m_pBall[2];
	int m_iBall[2];
	float m_iBallTime[2];
	int m_iBallCurrent[2];
	Vector m_vecEstVelocity;
	Vector m_velocity;
	int m_fInCombat;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CControllerHeadBall __packed
{
};
class __base(CBaseMonster, 0) CControllerHeadBall __packed
{
  struct vtable_for_CControllerHeadBall* vtable;
	void Spawn( void );
	void Precache( void );
	void EXPORT HuntThink( void );
	void EXPORT DieThink( void );
	void EXPORT BounceTouch( CBaseEntity *pOther );
	void MovetoTarget( Vector vecTarget );
	void Crawl( void );
	int m_iTrail;
	int m_flNextAttack;
	Vector m_vecIdeal;
	EHANDLE m_hOwner;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CControllerZapBall __packed
{
};
class __base(CBaseMonster, 0) CControllerZapBall __packed
{
  struct vtable_for_CControllerZapBall* vtable;
	void Spawn( void );
	void Precache( void );
	void EXPORT AnimateThink( void );
	void EXPORT ExplodeTouch( CBaseEntity *pOther );
	EHANDLE m_hOwner;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSpiral __packed
{
};
class __base(CBaseEntity, 0) CSpiral __packed
{
  struct vtable_for_CSpiral* vtable;
public:
	void Spawn( void );
	void Think( void );
	fcap_t ObjectCaps( void ) ;
	static CSpiral *Create( const Vector &origin, float height, float radius, float duration );
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CStomp __packed
{
};
class __base(CBaseEntity, 0) CStomp __packed
{
  struct vtable_for_CStomp* vtable;
public:
	void Spawn( void );
	void Think( void );
	static CStomp *StompCreate( const Vector &origin, const Vector &end, float speed );
private:
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGargantua __packed
{
	int		(*Save)( class CGargantua* p,  CSave &save );
	int		(*Restore)( class CGargantua* p,  CRestore &restore );
	Schedule_t *(*ScheduleFromName)( class CGargantua* p, const char *pName );
};
class __base(CBaseMonster, 0) CGargantua __packed
{
  struct vtable_for_CGargantua* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	BOOL CheckMeleeAttack1( float flDot, float flDist );
	BOOL CheckMeleeAttack2( float flDot, float flDist );
	BOOL CheckRangeAttack1( float flDot, float flDist );
	void SetObjectCollisionBox( void );
	Schedule_t *GetScheduleOfType( SCHEDULE_TYPE Type );
	void StartTask( Task_t *pTask );
	void RunTask( Task_t *pTask );
	void PrescheduleThink( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void DeathEffect( void );
	void EyeOff( void );
	void EyeOn( int level );
	void EyeUpdate( void );
	void Leap( void );
	void StompAttack( void );
	void FlameCreate( void );
	void FlameUpdate( void );
	void FlameControls( float angleX, float angleY );
	void FlameDestroy( void );
	inline BOOL FlameIsOn( void ) ;
	void FlameDamage( Vector vecStart, Vector vecEnd, entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, class_t iClassIgnore, dmg_t bitsDamageType );
	static	TYPEDESCRIPTION m_SaveData[];
	static Schedule_t *m_scheduleList[];
private:
	static const char *pAttackHitSounds[];
	static const char *pBeamAttackSounds[];
	static const char *pAttackMissSounds[];
	static const char *pRicSounds[];
	static const char *pFootSounds[];
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	static const char *pPainSounds[];
	static const char *pAttackSounds[];
	static const char *pStompSounds[];
	static const char *pBreatheSounds[];
	CBaseEntity* GargantuaCheckTraceHullAttack(float flDist, int iDamage, int iDmgType);
	CSprite		*m_pEyeGlow;
	CBeam		*m_pFlame[4];
	int			m_eyeBrightness;
	float		m_seeTime;
	float		m_flameTime;
	float		m_painSoundTime;
	float		m_streakTime;
	float		m_flameX;
	float		m_flameY;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CSmoker __packed
{
};
class __base(CBaseEntity, 0) CSmoker __packed
{
  struct vtable_for_CSmoker* vtable;
public:
	void Spawn( void );
	void Think( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGenericMonster __packed
{
};
class __base(CBaseMonster, 0) CGenericMonster __packed
{
  struct vtable_for_CGenericMonster* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	bitssound_t ISoundMask ( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CGMan __packed
{
};
class __base(CBaseMonster, 0) CGMan __packed
{
  struct vtable_for_CGMan* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	bitssound_t ISoundMask ( void );
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	void StartTask( Task_t *pTask );
	void RunTask( Task_t *pTask );
	int  TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	void PlayScriptedSentence( const char *pszSentence, float duration, float volume, float attenuation, BOOL bConcurrent, CBaseEntity *pListener );
	EHANDLE m_hPlayer;
	EHANDLE m_hTalkTarget;
	float m_flTalkTime;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CHAssassin __packed
{
  Schedule_t *(*ScheduleFromName)( class CHAssassin* p, const char *pName );
};
class __base(CBaseMonster, 0) CHAssassin __packed
{
  struct vtable_for_CHAssassin* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed ( void );
	class_t  Classify ( void );
	bitssound_t  ISoundMask ( void);
	void Shoot( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	Schedule_t* GetSchedule ( void );
	Schedule_t* GetScheduleOfType ( SCHEDULE_TYPE Type );
	BOOL CheckMeleeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack2 ( float flDot, float flDist );
	void StartTask ( Task_t *pTask );
	void RunAI( void );
	void RunTask ( Task_t *pTask );
	void DeathSound ( void );
	void IdleSound ( void );
	static Schedule_t *m_scheduleList[];
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	float m_flLastShot;
	float m_flDiviation;
	float m_flNextJump;
	Vector m_vecJumpVelocity;
	float m_flNextGrenadeCheck;
	Vector	m_vecTossVelocity;
	BOOL	m_fThrowGrenade;
	int		m_iTargetRanderamt;
	int		m_iFrustration;
	int		m_iShell;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CHeadCrab __packed
{
	float (*GetDamageAmount)( class CHeadCrab* p );
	int (*GetVoicePitch)( class CHeadCrab* p );
	float (*GetSoundVolue)( class CHeadCrab* p );
	Schedule_t *(*ScheduleFromName)( class CHeadCrab* p, const char *pName );
};
class __base(CBaseMonster, 0) CHeadCrab __packed
{
  struct vtable_for_CHeadCrab* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void RunTask ( Task_t *pTask );
	void StartTask ( Task_t *pTask );
	void SetYawSpeed ( void );
	void EXPORT LeapTouch ( CBaseEntity *pOther );
	Vector Center( void );
	Vector BodyTarget( const Vector &posSrc );
	void PainSound( void );
	void DeathSound( void );
	void IdleSound( void );
	void AlertSound( void );
	void PrescheduleThink( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack2 ( float flDot, float flDist );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	Schedule_t* GetScheduleOfType ( SCHEDULE_TYPE Type );
	static Schedule_t *m_scheduleList[];
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	static const char *pPainSounds[];
	static const char *pAttackSounds[];
	static const char *pDeathSounds[];
	static const char *pBiteSounds[];
};
struct __base(vtable_for_CHeadCrab, 0) __data_var_refs vtable_for_CBabyCrab __packed
{
	int (*GetVoicePitch)( class CBabyCrab* p );
	float (*GetSoundVolue)( class CBabyCrab* p );
};
class __base(CHeadCrab, 0) CBabyCrab __packed
{
  struct vtable_for_CBabyCrab* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed ( void );
	float GetDamageAmount( void ) ;
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	Schedule_t* GetScheduleOfType ( SCHEDULE_TYPE Type );
};
struct __base(vtable_for_CSquadMonster, 0) __data_var_refs vtable_for_CHGrunt __packed
{
  Schedule_t *(*ScheduleFromName)( class CHGrunt* p, const char *pName );
};
class __base(CSquadMonster, 0) CHGrunt __packed
{
  struct vtable_for_CHGrunt* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed ( void );
	class_t  Classify ( void );
	bitssound_t ISoundMask ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	BOOL FCanCheckAttacks ( void );
	BOOL CheckMeleeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack2 ( float flDot, float flDist );
	void CheckAmmo ( void );
	void SetActivity ( Activity NewActivity );
	void StartTask ( Task_t *pTask );
	void RunTask ( Task_t *pTask );
	void DeathSound( void );
	void PainSound( void );
	void IdleSound ( void );
	Vector GetGunPosition( void );
	void Shoot ( void );
	void Shotgun ( void );
	void PrescheduleThink ( void );
	void GibMonster( void );
	void SpeakSentence( void );
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	CBaseEntity	*Kick( void );
	Schedule_t	*GetSchedule( void );
	Schedule_t  *GetScheduleOfType ( SCHEDULE_TYPE Type );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	disposition_t IRelationship ( CBaseEntity *pTarget );
	BOOL FOkToSpeak( void );
	void JustSpoke( void );
	static Schedule_t *m_scheduleList[];
	static TYPEDESCRIPTION m_SaveData[];
	float m_flNextGrenadeCheck;
	float m_flNextPainTime;
	float m_flLastEnemySightTime;
	Vector	m_vecTossVelocity;
	BOOL	m_fThrowGrenade;
	BOOL	m_fStanding;
	BOOL	m_fFirstEncounter;
	int		m_cClipSize;
	int m_voicePitch;
	int		m_iBrassShell;
	int		m_iShotgunShell;
	int		m_iSentence;
	static const char *pGruntSentences[];
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CHGruntRepel __packed
{
};
class __base(CBaseMonster, 0) CHGruntRepel __packed
{
  struct vtable_for_CHGruntRepel* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void EXPORT RepelUse ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	int m_iSpriteTexture;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CDeadHGrunt __packed
{
};
class __base(CBaseMonster, 0) CDeadHGrunt __packed
{
  struct vtable_for_CDeadHGrunt* vtable;
public:
	void Spawn( void );
	class_t	Classify ( void ) ;
	void KeyValue( KeyValueData *pkvd );
	int	m_iPose;
	static char *m_szPoses[3];
};
struct __base(vtable_for_CSquadMonster, 0) __data_var_refs vtable_for_CHoundeye __packed
{
  Schedule_t *(*ScheduleFromName)( class CHoundeye* p, const char *pName );
};
class __base(CSquadMonster, 0) CHoundeye __packed
{
  struct vtable_for_CHoundeye* vtable;
public:
	void Spawn( void );
	void Precache( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void SetYawSpeed ( void );
	void WarmUpSound ( void );
	void AlertSound( void );
	void DeathSound( void );
	void WarnSound( void );
	void PainSound( void );
	void IdleSound( void );
	void StartTask( Task_t *pTask );
	void RunTask ( Task_t *pTask );
	void SonicAttack( void );
	void PrescheduleThink( void );
	void SetActivity ( Activity NewActivity );
	void WriteBeamColor ( void );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL FValidateHintType ( short sHint );
	BOOL FCanActiveIdle ( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	Schedule_t *CHoundeye :: GetSchedule( void );
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static Schedule_t *m_scheduleList[];
	static TYPEDESCRIPTION m_SaveData[];
	int m_iSpriteTexture;
	BOOL m_fAsleep;
	BOOL m_fDontBlink;
	Vector	m_vecPackCenter;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CLegacyCineMonster __packed
{
};
class __base(CBaseMonster, 0) CLegacyCineMonster __packed
{
  struct vtable_for_CLegacyCineMonster* vtable;
public:
	void CineSpawn( char *szModel );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT CineThink( void );
	void Pain( void );
	void Die( void );
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCineScientist __packed
{
};
class __base(CLegacyCineMonster, 0) CCineScientist __packed
{
  struct vtable_for_CCineScientist* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCine2Scientist __packed
{
};
class __base(CLegacyCineMonster, 0) CCine2Scientist __packed
{
  struct vtable_for_CCine2Scientist* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCinePanther __packed
{
};
class __base(CLegacyCineMonster, 0) CCinePanther __packed
{
  struct vtable_for_CCinePanther* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCineBarney __packed
{
};
class __base(CLegacyCineMonster, 0) CCineBarney __packed
{
  struct vtable_for_CCineBarney* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCine2HeavyWeapons __packed
{
};
class __base(CLegacyCineMonster, 0) CCine2HeavyWeapons __packed
{
  struct vtable_for_CCine2HeavyWeapons* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCine2Slave __packed
{
};
class __base(CLegacyCineMonster, 0) CCine2Slave __packed
{
  struct vtable_for_CCine2Slave* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCine3Scientist __packed
{
};
class __base(CLegacyCineMonster, 0) CCine3Scientist __packed
{
  struct vtable_for_CCine3Scientist* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CLegacyCineMonster, 0) __data_var_refs vtable_for_CCine3Barney __packed
{
};
class __base(CLegacyCineMonster, 0) CCine3Barney __packed
{
  struct vtable_for_CCine3Barney* vtable;
public:
	void Spawn( void ) ;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CCineBlood __packed
{
};
class __base(CBaseEntity, 0) CCineBlood __packed
{
  struct vtable_for_CCineBlood* vtable;
public:
	void Spawn( void );
	void EXPORT BloodStart ( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT BloodGush ( void );
};
struct __base(vtable_for_CFlyingMonster, 0) __data_var_refs vtable_for_CIchthyosaur __packed
{
  Schedule_t *(*ScheduleFromName)( class CIchthyosaur* p, const char *pName );
};
class __base(CFlyingMonster, 0) CIchthyosaur __packed
{
  struct vtable_for_CIchthyosaur* vtable;
public:
	void  Spawn( void );
	void  Precache( void );
	void  SetYawSpeed( void );
	class_t   Classify( void );
	void  HandleAnimEvent( MonsterEvent_t *pEvent );
	static Schedule_t *m_scheduleList[];
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	Schedule_t *GetSchedule( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void BecomeDead( void );
	void EXPORT CombatUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT BiteTouch( CBaseEntity *pOther );
	void  StartTask( Task_t *pTask );
	void  RunTask( Task_t *pTask );
	BOOL  CheckMeleeAttack1 ( float flDot, float flDist );
	BOOL  CheckRangeAttack1 ( float flDot, float flDist );
	float ChangeYaw( int speed );
	Activity GetStoppedActivity( void );
	void  Move( float flInterval );
	void  MoveExecute( CBaseEntity *pTargetEnt, const Vector &vecDir, float flInterval );
	void  MonsterThink( void );
	void  Stop( void );
	void  Swim( void );
	Vector DoProbe(const Vector &Probe);
	float VectorToPitch( const Vector &vec);
	float FlPitchDiff( void );
	float ChangePitch( int speed );
	Vector m_SaveVelocity;
	float m_idealDist;
	float m_flBlink;
	float m_flEnemyTouched;
	BOOL  m_bOnAttack;
	float m_flMaxSpeed;
	float m_flMinSpeed;
	float m_flMaxDist;
	CBeam *m_pBeam;
	float m_flNextAlert;
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	static const char *pAttackSounds[];
	static const char *pBiteSounds[];
	static const char *pDieSounds[];
	static const char *pPainSounds[];
	void IdleSound( void );
	void AlertSound( void );
	void AttackSound( void );
	void BiteSound( void );
	void DeathSound( void );
	void PainSound( void );
};
struct __base(vtable_for_CSquadMonster, 0) __data_var_refs vtable_for_CISlave __packed
{
  Schedule_t *(*ScheduleFromName)( class CISlave* p, const char *pName );
};
class __base(CSquadMonster, 0) CISlave __packed
{
  struct vtable_for_CISlave* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	bitssound_t	 ISoundMask( void );
	class_t  Classify ( void );
	disposition_t  IRelationship( CBaseEntity *pTarget );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	BOOL CheckRangeAttack1 ( float flDot, float flDist );
	BOOL CheckRangeAttack2 ( float flDot, float flDist );
	void CallForHelp( char *szClassname, float flDist, EHANDLE hEnemy, Vector &vecLocation );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType);
	void DeathSound( void );
	void PainSound( void );
	void AlertSound( void );
	void IdleSound( void );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
    void StartTask ( Task_t *pTask );
	Schedule_t *GetSchedule( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	static Schedule_t *m_scheduleList[];
	int	Save( CSave &save );
	int Restore( CRestore &restore );
	static TYPEDESCRIPTION m_SaveData[];
	void ClearBeams( );
	void ArmBeam( int side );
	void WackBeam( int side, CBaseEntity *pEntity );
	void ZapBeam( int side );
	void BeamGlow( void );
	int m_iBravery;
	CBeam *m_pBeam[ISLAVE_MAX_BEAMS];
	int m_iBeams;
	float m_flNextAttack;
	int	m_voicePitch;
	EHANDLE m_hDead;
	static const char *pAttackHitSounds[];
	static const char *pAttackMissSounds[];
	static const char *pPainSounds[];
	static const char *pDeathSounds[];
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CLeech __packed
{
	int		(*Save)( class CLeech* p,  CSave &save );
	int		(*Restore)( class CLeech* p,  CRestore &restore );
};
class __base(CBaseMonster, 0) CLeech __packed
{
  struct vtable_for_CLeech* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void EXPORT SwimThink( void );
	void EXPORT DeadThink( void );
	void Touch( CBaseEntity *pOther );
	void SetObjectCollisionBox( void );
	void AttackSound( void );
	void AlertSound( void );
	void UpdateMotion( void );
	float ObstacleDistance( CBaseEntity *pTarget );
	void MakeVectors( void );
	void RecalculateWaterlevel( void );
	void SwitchLeechState( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	bloodcolor_t	BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void Activate( void );
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	class_t	Classify( void ) ;
	disposition_t IRelationship( CBaseEntity *pTarget );
	static	TYPEDESCRIPTION m_SaveData[];
	static const char *pAttackSounds[];
	static const char *pAlertSounds[];
private:
	float	m_flTurning;
	BOOL	m_fPathBlocked;
	float	m_flAccelerate;
	float	m_obstacle;
	float	m_top;
	float	m_bottom;
	float	m_height;
	float	m_waterTime;
	float	m_sideTime;
	float	m_zTime;
	float	m_stateTime;
	float	m_attackSoundTime;
#if DEBUG_BEAMS
	CBeam	*m_pb;
	CBeam	*m_pt;
#endif
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CNihilanth __packed
{
};
class __base(CBaseMonster, 0) CNihilanth __packed
{
  struct vtable_for_CNihilanth* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	class_t  Classify( void ) ;
	bloodcolor_t  BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void GibMonster( void );
	void SetObjectCollisionBox( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void EXPORT StartupThink( void );
	void EXPORT HuntThink( void );
	void EXPORT CrashTouch( CBaseEntity *pOther );
	void EXPORT DyingThink( void );
	void EXPORT StartupUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT NullThink( void );
	void EXPORT CommandUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void FloatSequence( void );
	void NextActivity( void );
	void Flight( void );
	BOOL AbsorbSphere( void );
	BOOL EmitSphere( void );
	void TargetSphere( USE_TYPE useType, float value );
	CBaseEntity *RandomTargetname( const char *szName );
	void ShootBalls( void );
	void MakeFriend( Vector vecPos );
	int  TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	void PainSound( void );
	void DeathSound( void );
	static const char *pAttackSounds[];
	static const char *pBallSounds[];
	static const char *pShootSounds[];
	static const char *pRechargeSounds[];
	static const char *pLaughSounds[];
	static const char *pPainSounds[];
	static const char *pDeathSounds[];
	float m_flForce;
	float m_flNextPainSound;
	Vector m_velocity;
	Vector m_avelocity;
	Vector m_vecTarget;
	Vector m_posTarget;
	Vector m_vecDesired;
	Vector m_posDesired;
	float  m_flMinZ;
	float  m_flMaxZ;
	Vector m_vecGoal;
	float m_flLastSeen;
	float m_flPrevSeen;
	int m_irritation;
	int m_iLevel;
	int m_iTeleport;
	EHANDLE m_hRecharger;
	EHANDLE m_hSphere[N_SPHERES];
	int	m_iActiveSpheres;
	float m_flAdj;
	CSprite *m_pBall;
	char m_szRechargerTarget[64];
	char m_szDrawUse[64];
	char m_szTeleportUse[64];
	char m_szTeleportTouch[64];
	char m_szDeadUse[64];
	char m_szDeadTouch[64];
	float m_flShootEnd;
	float m_flShootTime;
	EHANDLE m_hFriend[3];
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CNihilanthHVR __packed
{
	void (*Crawl)( class CNihilanthHVR* p );
};
class __base(CBaseMonster, 0) CNihilanthHVR __packed
{
  struct vtable_for_CNihilanthHVR* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void Spawn( void );
	void Precache( void );
	void CircleInit( CBaseEntity *pTarget );
	void AbsorbInit( void );
	void TeleportInit( CNihilanth *pOwner, CBaseEntity *pEnemy, CBaseEntity *pTarget, CBaseEntity *pTouch );
	void GreenBallInit( void );
	void ZapInit( CBaseEntity *pEnemy );
	void EXPORT HoverThink( void );
	BOOL CircleTarget( Vector vecTarget );
	void EXPORT DissipateThink( void );
	void EXPORT ZapThink( void );
	void EXPORT TeleportThink( void );
	void EXPORT TeleportTouch( CBaseEntity *pOther );
	void EXPORT RemoveTouch( CBaseEntity *pOther );
	void EXPORT BounceTouch( CBaseEntity *pOther );
	void EXPORT ZapTouch( CBaseEntity *pOther );
	CBaseEntity *RandomClassname( const char *szName );
	void MovetoTarget( Vector vecTarget );
	void Zap( void );
	void Teleport( void );
	float m_flIdealVel;
	Vector m_vecIdeal;
	CNihilanth *m_pNihilanth;
	EHANDLE m_hTouch;
	int m_nFrames;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CTestHull __packed
{
	fcap_t	(*ObjectCaps)( class CTestHull* p );
};
class __base(CBaseMonster, 0) CTestHull __packed
{
  struct vtable_for_CTestHull* vtable;
public:
	void Spawn( entvars_t *pevMasterNode );
	void EXPORT CallBuildNodeGraph ( void );
	void BuildNodeGraph ( void );
	void EXPORT ShowBadNode ( void );
	void EXPORT DropDelay ( void );
	void EXPORT PathFind ( void );
	Vector	vecBadNodeOrigin;
};
struct tagNodePair __packed
{
	short iSrc;
	short iDest;
};
struct __base(vtable_for_CBaseEntity, 0) __data_var_refs vtable_for_CNodeViewer __packed
{
};
class __base(CBaseEntity, 0) CNodeViewer __packed
{
  struct vtable_for_CNodeViewer* vtable;
public:
	void Spawn( void );
	int m_iBaseNode;
	int m_iDraw;
	int	m_nVisited;
	int m_aFrom[128];
	int m_aTo[128];
	int m_iHull;
	int m_afNodeType;
	Vector m_vecColor;
	void FindNodeConnections( int iNode );
	void AddNode( int iFrom, int iTo );
	void EXPORT DrawThink( void );
};
typedef struct
{
	int isValid;
	EHANDLE hGrunt;
	Vector	vecOrigin;
	Vector  vecAngles;
} t_ospreygrunt;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_COsprey __packed
{
};
class __base(CBaseMonster, 0) COsprey __packed
{
  struct vtable_for_COsprey* vtable;
public:
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	fcap_t		ObjectCaps( void ) ;
	void Spawn( void );
	void Precache( void );
	class_t  Classify( void ) ;
	bloodcolor_t  BloodColor( void ) ;
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	void UpdateGoal( void );
	BOOL HasDead( void );
	void EXPORT FlyThink( void );
	void EXPORT DeployThink( void );
	void Flight( void );
	void EXPORT HitTouch( CBaseEntity *pOther );
	void EXPORT FindAllThink( void );
	void EXPORT HoverThink( void );
	CBaseMonster *MakeGrunt( Vector vecSrc );
	void EXPORT CrashTouch( CBaseEntity *pOther );
	void EXPORT DyingThink( void );
	void EXPORT CommandUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void TraceAttack( entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	void ShowDamage( void );
	CBaseEntity *m_pGoalEnt;
	Vector m_vel1;
	Vector m_vel2;
	Vector m_pos1;
	Vector m_pos2;
	Vector m_ang1;
	Vector m_ang2;
	float m_startTime;
	float m_dTime;
	Vector m_velocity;
	float m_flIdealtilt;
	float m_flRotortilt;
	float m_flRightHealth;
	float m_flLeftHealth;
	int	m_iUnits;
	EHANDLE m_hGrunt[MAX_CARRY];
	Vector m_vecOrigin[MAX_CARRY];
	EHANDLE m_hRepel[4];
	int m_iSoundState;
	int m_iSpriteTexture;
	int m_iPitch;
	int m_iExplode;
	int	m_iTailGibs;
	int	m_iBodyGibs;
	int	m_iEngineGibs;
	int m_iDoLeftSmokePuff;
	int m_iDoRightSmokePuff;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CRat __packed
{
};
class __base(CBaseMonster, 0) CRat __packed
{
  struct vtable_for_CRat* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CRoach __packed
{
};
class __base(CBaseMonster, 0) CRoach __packed
{
  struct vtable_for_CRoach* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	void EXPORT MonsterThink ( void );
	void Move ( float flInterval );
	void PickNewDest ( int iCondition );
	void EXPORT Touch ( CBaseEntity *pOther );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	float	m_flLastLightLevel;
	float	m_flNextSmellTime;
	class_t		Classify ( void );
	void	Look ( int iDistance );
	bitssound_t		ISoundMask ( void );
	BOOL	m_fLightHacked;
	int		m_iMode;
};
struct __base(vtable_for_CTalkMonster, 0) __data_var_refs vtable_for_CScientist __packed
{
	int (*FriendNumber)( class CScientist* p,  int arrayNumber );
	int		(*Save)( class CScientist* p,  CSave &save );
	int		(*Restore)( class CScientist* p,  CRestore &restore );
	Schedule_t *(*ScheduleFromName)( class CScientist* p, const char *pName );
};
class __base(CTalkMonster, 0) CScientist __packed
{
  struct vtable_for_CScientist* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void RunTask( Task_t *pTask );
	void StartTask( Task_t *pTask );
	fcap_t	ObjectCaps( void ) ;
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType);
	void SetActivity ( Activity newActivity );
	Activity GetStoppedActivity( void );
	bitssound_t ISoundMask( void );
	void DeclineFollowing( void );
	float	CoverRadius( void ) ;
	BOOL	DisregardEnemy( CBaseEntity *pEnemy ) ;
	BOOL	CanHeal( void );
	void	Heal( void );
	void	Scream( void );
	Schedule_t *GetScheduleOfType ( SCHEDULE_TYPE Type );
	Schedule_t *GetSchedule ( void );
	MONSTERSTATE GetIdealState ( void );
	void DeathSound( void );
	void PainSound( void );
	void TalkInit( void );
	void			Killed( entvars_t *pevAttacker, gib_t iGib );
	static	TYPEDESCRIPTION m_SaveData[];
	static Schedule_t *m_scheduleList[];
private:
	float m_painTime;
	float m_healTime;
	float m_fearTime;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CDeadScientist __packed
{
};
class __base(CBaseMonster, 0) CDeadScientist __packed
{
  struct vtable_for_CDeadScientist* vtable;
public:
	void Spawn( void );
	class_t	Classify ( void ) ;
	void KeyValue( KeyValueData *pkvd );
	int	m_iPose;
	static char *m_szPoses[7];
};
typedef enum
{
SITTING_ANIM_sitlookleft,
SITTING_ANIM_sitlookright,
SITTING_ANIM_sitscared,
SITTING_ANIM_sitting2,
SITTING_ANIM_sitting3
} SITTING_ANIM;
struct __base(vtable_for_CScientist, 0) __data_var_refs vtable_for_CSittingScientist __packed
{
	int		(*Save)( class CSittingScientist* p,  CSave &save );
	int		(*Restore)( class CSittingScientist* p,  CRestore &restore );
	void (*SetAnswerQuestion)( class CSittingScientist* p,  CTalkMonster *pSpeaker );
};
class __base(CScientist, 0) CSittingScientist __packed
{
  struct vtable_for_CSittingScientist* vtable;
public:
	void Spawn( void );
	void  Precache( void );
	void EXPORT SittingThink( void );
	class_t	Classify ( void );
	static	TYPEDESCRIPTION m_SaveData[];
	int FriendNumber( int arrayNumber );
	int FIdleSpeak ( void );
	int		m_baseSequence;
	int		m_headTurn;
	float	m_flResponseDelay;
};
struct __base(vtable_for_CBaseToggle, 0) __data_var_refs vtable_for_CScriptedSentence __packed
{
	int		(*Save)( class CScriptedSentence* p,  CSave &save );
	int		(*Restore)( class CScriptedSentence* p,  CRestore &restore );
};
class __base(CBaseToggle, 0) CScriptedSentence __packed
{
  struct vtable_for_CScriptedSentence* vtable;
public:
	void Spawn( void );
	void KeyValue( KeyValueData *pkvd );
	void Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT FindThink( void );
	void EXPORT DelayThink( void );
	fcap_t	 ObjectCaps( void ) ;
	static	TYPEDESCRIPTION m_SaveData[];
	CBaseMonster *FindEntity( void );
	BOOL AcceptableSpeaker( CBaseMonster *pMonster );
	BOOL StartSentence( CBaseMonster *pTarget );
private:
	int		m_iszSentence;
	int		m_iszEntity;
	float	m_flRadius;
	float	m_flDuration;
	float	m_flRepeat;
	float	m_flAttenuation;
	float	m_flVolume;
	BOOL	m_active;
	int		m_iszListener;
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CFurniture __packed
{
	fcap_t	(*ObjectCaps)( class CFurniture* p );
};
class __base(CBaseMonster, 0) CFurniture __packed
{
  struct vtable_for_CFurniture* vtable;
public:
	void Spawn ( void );
	void Die( void );
	class_t	 Classify ( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CMyMonster __packed
{
};
class __base(CBaseMonster, 0) CMyMonster __packed
{
  struct vtable_for_CMyMonster* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
};
typedef enum
{
	TENTACLE_ANIM_Pit_Idle,
	TENTACLE_ANIM_rise_to_Temp1,
	TENTACLE_ANIM_Temp1_to_Floor,
	TENTACLE_ANIM_Floor_Idle,
	TENTACLE_ANIM_Floor_Fidget_Pissed,
	TENTACLE_ANIM_Floor_Fidget_SmallRise,
	TENTACLE_ANIM_Floor_Fidget_Wave,
	TENTACLE_ANIM_Floor_Strike,
	TENTACLE_ANIM_Floor_Tap,
	TENTACLE_ANIM_Floor_Rotate,
	TENTACLE_ANIM_Floor_Rear,
	TENTACLE_ANIM_Floor_Rear_Idle,
	TENTACLE_ANIM_Floor_to_Lev1,
	TENTACLE_ANIM_Lev1_Idle,
	TENTACLE_ANIM_Lev1_Fidget_Claw,
	TENTACLE_ANIM_Lev1_Fidget_Shake,
	TENTACLE_ANIM_Lev1_Fidget_Snap,
	TENTACLE_ANIM_Lev1_Strike,
	TENTACLE_ANIM_Lev1_Tap,
	TENTACLE_ANIM_Lev1_Rotate,
	TENTACLE_ANIM_Lev1_Rear,
	TENTACLE_ANIM_Lev1_Rear_Idle,
	TENTACLE_ANIM_Lev1_to_Lev2,
	TENTACLE_ANIM_Lev2_Idle,
	TENTACLE_ANIM_Lev2_Fidget_Shake,
	TENTACLE_ANIM_Lev2_Fidget_Swing,
	TENTACLE_ANIM_Lev2_Fidget_Tut,
	TENTACLE_ANIM_Lev2_Strike,
	TENTACLE_ANIM_Lev2_Tap,
	TENTACLE_ANIM_Lev2_Rotate,
	TENTACLE_ANIM_Lev2_Rear,
	TENTACLE_ANIM_Lev2_Rear_Idle,
	TENTACLE_ANIM_Lev2_to_Lev3,
	TENTACLE_ANIM_Lev3_Idle,
	TENTACLE_ANIM_Lev3_Fidget_Shake,
	TENTACLE_ANIM_Lev3_Fidget_Side,
	TENTACLE_ANIM_Lev3_Fidget_Swipe,
	TENTACLE_ANIM_Lev3_Strike,
	TENTACLE_ANIM_Lev3_Tap,
	TENTACLE_ANIM_Lev3_Rotate,
	TENTACLE_ANIM_Lev3_Rear,
	TENTACLE_ANIM_Lev3_Rear_Idle,
	TENTACLE_ANIM_Lev1_Door_reach,
	TENTACLE_ANIM_Lev3_to_Engine,
	TENTACLE_ANIM_Engine_Idle,
	TENTACLE_ANIM_Engine_Sway,
	TENTACLE_ANIM_Engine_Swat,
	TENTACLE_ANIM_Engine_Bob,
	TENTACLE_ANIM_Engine_Death1,
	TENTACLE_ANIM_Engine_Death2,
	TENTACLE_ANIM_Engine_Death3,
	TENTACLE_ANIM_none
} TENTACLE_ANIM;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CTentacle __packed
{
	fcap_t	(*ObjectCaps)( class CTentacle* p );
};
class __base(CBaseMonster, 0) CTentacle __packed
{
  struct vtable_for_CTentacle* vtable;
public:
	CTentacle( void );
	void Spawn( );
	void Precache( );
	void KeyValue( KeyValueData *pkvd );
	int		Save( CSave &save );
	int		Restore( CRestore &restore );
	static	TYPEDESCRIPTION m_SaveData[];
	void SetObjectCollisionBox( void );
	void EXPORT Cycle( void );
	void EXPORT CommandUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	void EXPORT Start( void );
	void EXPORT DieThink( void );
	void EXPORT Test( void );
	void EXPORT HitTouch( CBaseEntity *pOther );
	float HearingSensitivity( void ) ;
	int TakeDamage( entvars_t* pevInflictor, entvars_t* pevAttacker, float flDamage, dmg_t bitsDamageType );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	void Killed( entvars_t *pevAttacker, gib_t iGib );
	MONSTERSTATE GetIdealState ( void ) ;
	int CanPlaySequence( BOOL fDisregardState ) ;
	class_t Classify( void );
	int Level( float dz );
	int MyLevel( void );
	float MyHeight( void );
	float m_flInitialYaw;
	int m_iGoalAnim;
	int m_iLevel;
	int m_iDir;
	float m_flFramerateAdj;
	float m_flSoundYaw;
	int m_iSoundLevel;
	float m_flSoundTime;
	float m_flSoundRadius;
	int m_iHitDmg;
	float m_flHitTime;
	float m_flTapRadius;
	float m_flNextSong;
	static int g_fFlySound;
	static int g_fSquirmSound;
	float m_flMaxYaw;
	int m_iTapSound;
	Vector m_vecPrevSound;
	float m_flPrevSoundTime;
	static const char *pHitSilo[];
	static const char *pHitDirt[];
	static const char *pHitWater[];
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CTentacleMaw __packed
{
};
class __base(CBaseMonster, 0) CTentacleMaw __packed
{
  struct vtable_for_CTentacleMaw* vtable;
public:
	void Spawn( );
	void Precache( );
};
typedef enum
{
	TURRET_ANIM_NONE = 0,
	TURRET_ANIM_FIRE,
	TURRET_ANIM_SPIN,
	TURRET_ANIM_DEPLOY,
	TURRET_ANIM_RETIRE,
	TURRET_ANIM_DIE,
} TURRET_ANIM;
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CBaseTurret __packed
{
	void (*Precache)( class CBaseTurret* p);
	void (*TraceAttack)( class CBaseTurret* p,  entvars_t *pevAttacker, float flDamage, Vector vecDir, TraceResult *ptr, dmg_t bitsDamageType);
	int	 (*TakeDamage)( class CBaseTurret* p,  entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
	class_t	 (*Classify)( class CBaseTurret* p);
	void EXPORT (*SpinDownCall)( class CBaseTurret* p );
	void EXPORT (*SpinUpCall)( class CBaseTurret* p );
	void (*Ping)( class CBaseTurret* p);
	void (*EyeOn)( class CBaseTurret* p);
	void (*EyeOff)( class CBaseTurret* p);
	int		(*Save)( class CBaseTurret* p,  CSave &save );
	int		(*Restore)( class CBaseTurret* p,  CRestore &restore );
	void (*Shoot)( class CBaseTurret* p, Vector &vecSrc, Vector &vecDirToEnemy);
};
class __base(CBaseMonster, 0) CBaseTurret __packed
{
  struct vtable_for_CBaseTurret* vtable;
public:
	void Spawn(void);
	void KeyValue( KeyValueData *pkvd );
	void EXPORT TurretUse( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value );
	bloodcolor_t BloodColor( void ) ;
	void GibMonster( void ) ;
	void EXPORT ActiveThink(void);
	void EXPORT SearchThink(void);
	void EXPORT AutoSearchThink(void);
	void EXPORT TurretDeath(void);
	void EXPORT Deploy(void);
	void EXPORT Retire(void);
	void EXPORT Initialize(void);
	static	TYPEDESCRIPTION m_SaveData[];
	void SetTurretAnim(TURRET_ANIM anim);
	int MoveTurret(void);
	float m_flMaxSpin;
	int m_iSpin;
	CSprite *m_pEyeGlow;
	int		m_eyeBrightness;
	int	m_iDeployHeight;
	int	m_iRetractHeight;
	int m_iMinPitch;
	int m_iBaseTurnRate;
	float m_fTurnRate;
	int m_iOrientation;
	int	m_iOn;
	int m_fBeserk;
	int m_iAutoStart;
	Vector m_vecLastSight;
	float m_flLastSight;
	float m_flMaxWait;
	int m_iSearchSpeed;
	float	m_flStartYaw;
	Vector	m_vecCurAngles;
	Vector	m_vecGoalAngles;
	float	m_flPingTime;
	float	m_flSpinUpTime;
};
struct __base(vtable_for_CBaseTurret, 0) __data_var_refs vtable_for_CTurret __packed
{
	int		(*Save)( class CTurret* p,  CSave &save );
	int		(*Restore)( class CTurret* p,  CRestore &restore );
};
class __base(CBaseTurret, 0) CTurret __packed
{
  struct vtable_for_CTurret* vtable;
public:
	void Spawn(void);
	void Precache(void);
	void SpinUpCall(void);
	void SpinDownCall(void);
	static	TYPEDESCRIPTION m_SaveData[];
	void Shoot(Vector &vecSrc, Vector &vecDirToEnemy);
private:
	int m_iStartSpin;
};
struct __base(vtable_for_CBaseTurret, 0) __data_var_refs vtable_for_CMiniTurret __packed
{
};
class __base(CBaseTurret, 0) CMiniTurret __packed
{
  struct vtable_for_CMiniTurret* vtable;
public:
	void Spawn( );
	void Precache(void);
	void Shoot(Vector &vecSrc, Vector &vecDirToEnemy);
};
struct __base(vtable_for_CBaseTurret, 0) __data_var_refs vtable_for_CSentry __packed
{
};
class __base(CBaseTurret, 0) CSentry __packed
{
  struct vtable_for_CSentry* vtable;
public:
	void Spawn( );
	void Precache(void);
	void Shoot(Vector &vecSrc, Vector &vecDirToEnemy);
	int TakeDamage(entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType);
	void EXPORT SentryTouch( CBaseEntity *pOther );
	void EXPORT SentryDeath( void );
};
struct __base(vtable_for_CBaseMonster, 0) __data_var_refs vtable_for_CZombie __packed
{
};
class __base(CBaseMonster, 0) CZombie __packed
{
  struct vtable_for_CZombie* vtable;
public:
	void Spawn( void );
	void Precache( void );
	void SetYawSpeed( void );
	class_t  Classify ( void );
	void HandleAnimEvent( MonsterEvent_t *pEvent );
	bitscond_t IgnoreConditions ( void );
	float m_flNextFlinch;
	void PainSound( void );
	void AlertSound( void );
	void IdleSound( void );
	void AttackSound( void );
	static const char *pAttackSounds[];
	static const char *pIdleSounds[];
	static const char *pAlertSounds[];
	static const char *pPainSounds[];
	static const char *pAttackHitSounds[];
	static const char *pAttackMissSounds[];
	BOOL CheckRangeAttack1 ( float flDot, float flDist ) ;
	BOOL CheckRangeAttack2 ( float flDot, float flDist ) ;
	int TakeDamage( entvars_t *pevInflictor, entvars_t *pevAttacker, float flDamage, dmg_t bitsDamageType );
};
